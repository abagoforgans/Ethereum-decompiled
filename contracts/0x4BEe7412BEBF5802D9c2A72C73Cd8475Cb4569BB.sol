contract main {


// =======================  Init code  ======================


uint256 stor4;
array of uint256 stor6;
uint256 stor8;
uint256 stor9;

function _fallback() payable {
    stor4 = msg.sender or Mask(96, 160, stor4)
    stor8 = 3
    mem[128] = 'koad's solidity compiler infoBlo'
    mem[160] = 'b'
    stor6.length = 33
    s = 0
    idx = 128
    while 161 > idx:
        stor6[s] = mem[idx]
        s = s + 1
        idx = idx + 32
        continue 
    idx = 2
    while stor6.length + 31 / 32 > idx:
        stor6[idx] = 0
        idx = idx + 1
        continue 
    stor9 = block.timestamp
    return code.data[305 len 4090]
}



// =====================  Runtime code  =====================


array of struct stor0;
array of struct stor1;
array of struct stor2;
array of struct stor3;
address stor4;
array of struct stor5;
array of struct stor6;
array of struct stor7;
uint256 sub_381a8d9d;

function sub_381a8d9d(?) payable {
    return sub_381a8d9d
}

function _fallback() payable {
  stop
}

function sub_15180b32(?) payable {
    if stor2.length:
        mem[160] = uint256(stor2.field_0)
        idx = 160
        s = 0
        while stor2.length + 128 > idx:
            mem[idx + 32] = stor2[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    return Array(len=stor2.length, data=mem[160 len stor2.length])
}

function sub_5acbc516(?) payable {
    if stor0.length:
        mem[160] = uint256(stor0.field_0)
        idx = 160
        s = 0
        while stor0.length + 128 > idx:
            mem[idx + 32] = stor0[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    return Array(len=stor0.length, data=mem[160 len stor0.length])
}

function sub_61ac852b(?) payable {
    if stor5.length:
        mem[160] = uint256(stor5.field_0)
        idx = 160
        s = 0
        while stor5.length + 128 > idx:
            mem[idx + 32] = stor5[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    return Array(len=stor5.length, data=mem[160 len stor5.length])
}

function sub_d5f70876(?) payable {
    if stor3.length:
        mem[160] = uint256(stor3.field_0)
        idx = 160
        s = 0
        while stor3.length + 128 > idx:
            mem[idx + 32] = stor3[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    return Array(len=stor3.length, data=mem[160 len stor3.length])
}

function sub_e94ce41c(?) payable {
    if stor1.length:
        mem[160] = uint256(stor1.field_0)
        idx = 160
        s = 0
        while stor1.length + 128 > idx:
            mem[idx + 32] = stor1[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    return Array(len=stor1.length, data=mem[160 len stor1.length])
}

function sub_f37bac7e(?) payable {
    if stor7.length:
        mem[160] = uint256(stor7.field_0)
        idx = 160
        s = 0
        while stor7.length + 128 > idx:
            mem[idx + 32] = stor7[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    return Array(len=stor7.length, data=mem[160 len stor7.length])
}

function getContractName() payable {
    if stor6.length:
        mem[160] = uint256(stor6.field_0)
        idx = 160
        s = 0
        while stor6.length + 128 > idx:
            mem[idx + 32] = stor6[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    return Array(len=stor6.length, data=mem[160 len stor6.length])
}

function sub_1a03d342(?) payable {
    mem[128 len arg1.length] = arg1[all]
    if msg.sender == stor4:
        stor3.length = arg1.length
        if not arg1.length:
            idx = 0
            while stor3.length + 31 / 32 > idx:
                stor3[idx].field_0 = 0
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = 128
            while arg1.length + 128 > idx:
                stor3[s].field_0 = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, arg1.length + 31) >> 5
            while stor3.length + 31 / 32 > idx:
                stor3[idx].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_32dea6a1(?) payable {
    mem[128 len arg1.length] = arg1[all]
    if msg.sender == stor4:
        stor2.length = arg1.length
        if not arg1.length:
            idx = 0
            while stor2.length + 31 / 32 > idx:
                stor2[idx].field_0 = 0
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = 128
            while arg1.length + 128 > idx:
                stor2[s].field_0 = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, arg1.length + 31) >> 5
            while stor2.length + 31 / 32 > idx:
                stor2[idx].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_62431d91(?) payable {
    mem[128 len arg1.length] = arg1[all]
    if msg.sender == stor4:
        stor1.length = arg1.length
        if not arg1.length:
            idx = 0
            while stor1.length + 31 / 32 > idx:
                stor1[idx].field_0 = 0
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = 128
            while arg1.length + 128 > idx:
                stor1[s].field_0 = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, arg1.length + 31) >> 5
            while stor1.length + 31 / 32 > idx:
                stor1[idx].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_9bb13a76(?) payable {
    mem[128 len arg1.length] = arg1[all]
    if msg.sender == stor4:
        stor5.length = arg1.length
        if not arg1.length:
            idx = 0
            while stor5.length + 31 / 32 > idx:
                stor5[idx].field_0 = 0
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = 128
            while arg1.length + 128 > idx:
                stor5[s].field_0 = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, arg1.length + 31) >> 5
            while stor5.length + 31 / 32 > idx:
                stor5[idx].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_bc0e166a(?) payable {
    mem[128 len arg1.length] = arg1[all]
    if msg.sender == stor4:
        stor7.length = arg1.length
        if not arg1.length:
            idx = 0
            while stor7.length + 31 / 32 > idx:
                stor7[idx].field_0 = 0
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = 128
            while arg1.length + 128 > idx:
                stor7[s].field_0 = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, arg1.length + 31) >> 5
            while stor7.length + 31 / 32 > idx:
                stor7[idx].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_e4c9c4e9(?) payable {
    mem[128 len arg1.length] = arg1[all]
    if msg.sender == stor4:
        stor0.length = arg1.length
        if not arg1.length:
            idx = 0
            while stor0.length + 31 / 32 > idx:
                stor0[idx].field_0 = 0
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = 128
            while arg1.length + 128 > idx:
                stor0[s].field_0 = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, arg1.length + 31) >> 5
            while stor0.length + 31 / 32 > idx:
                stor0[idx].field_0 = 0
                idx = idx + 1
                continue 
}

function setContractName(string arg1) payable {
    mem[128 len arg1.length] = arg1[all]
    if msg.sender == stor4:
        stor6.length = arg1.length
        if not arg1.length:
            idx = 0
            while stor6.length + 31 / 32 > idx:
                stor6[idx].field_0 = 0
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = 128
            while arg1.length + 128 > idx:
                stor6[s].field_0 = mem[idx]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, arg1.length + 31) >> 5
            while stor6.length + 31 / 32 > idx:
                stor6[idx].field_0 = 0
                idx = idx + 1
                continue 
}



}
