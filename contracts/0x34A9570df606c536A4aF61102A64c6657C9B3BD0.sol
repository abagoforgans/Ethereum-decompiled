contract main {


// =======================  Init code  ======================


address stor1;

function _fallback() payable {
    stor1 = 0x57042a7e732e4bd4b0a38031c418a747e1016cbe
    return code.data[56 len 899]
}



// =====================  Runtime code  =====================


address stor0;
uint256 stor0;
address stor1;
array of struct stor2;

function kill() payable {
    if address(stor0) != msg.sender:
    selfdestruct(address(stor0))
}

function _fallback() payable {
  stop
}

function sub_1f445355(?) payable {
    emit 0x9a640132: Array(len=42, data='Ab jetzt werden Spenden entgegen', ' genommen!')
    uint256(stor0) = msg.sender or Mask(96, 160, uint256(stor0))
}

function donate(string arg1) payable {
    call stor1 with:
       value 95 * msg.value / 100 wei
         gas 0 wei
    emit 0x6460c894: Array(len=arg1.length, data=arg1[all]), 95 * msg.value / 100
    stor2.length++
    if not stor2.length <= stor2.length + 1:
        mem[0] = 2
        idx = 2 * stor2.length + 1
        while sha3(2) + (2 * stor2.length) > idx + sha3(mem[0]):
            stor[idx + sha3(mem[0])] = 0
            if 31 < stor[idx + sha3(mem[0])].length:
                mem[0] = idx + sha3(mem[0])
                s = sha3(idx + sha3(mem[0]))
                while sha3(idx + sha3(mem[0])) + (stor[idx + sha3(mem[0])].length + 31 / 32) > s:
                    stor[s] = 0
                    s = s + 1
                    continue 
            stor[idx + sha3(mem[0]) + 1] = 0
            idx = idx + 1
            continue 
    stor2[stor2.length][].field_0 = Array(len=arg1.length, data=arg1[all])
    stor2[stor2.length].field_256 = 95 * msg.value / 100
}



}
