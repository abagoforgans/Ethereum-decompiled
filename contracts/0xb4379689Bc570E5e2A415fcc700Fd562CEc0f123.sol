contract main {




// =====================  Runtime code  =====================


const sub_88845c95(?) = 'term', 0

const sub_90cfe999(?) = '', 0

const sub_9d25487e(?) = 'in', 0

const sub_e58be020(?) = 'disqua', 0


uint8 stor0;
address stor0;
address deployerAddress; offset 8
address operatorAddress;
uint256 sub_3b7bea6c;
address configurationAddress;
uint8 stor5; offset 160
address sub_19139092Address;
array of struct sub_1b90e3c1;
mapping of uint256 sub_66a6f36d;

function proposalsCount() {
    return sub_1b90e3c1.length
}

function sub_19139092(?) {
    return sub_19139092Address
}

function sub_1b90e3c1(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function isRegisteredService(address arg1) {
    require calldata.size - 4 >= 32
    return bool(uint8(stor2[address(arg1)].field_0))
}

function sub_2c1da19a(?) {
    return uint256(stor[(19 * stor7[address(arg1)][address(arg2)][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2][0 len stor[(19 * stor7[address(arg1)][address(arg2)][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2].length].field_0)
}

function sub_2ee2ed25(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_2f013a00(?) {
    return bool(uint8(stor0.field_0))
}

function sub_3b238528(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    return bool(sub_66a6f36d[address(arg1)][address(arg2)][arg3])
}

function sub_3b7bea6c(?) {
    return sub_3b7bea6c
}

function sub_3e59b706(?) {
    return bool(stor5)
}

function destructor() {
    return deployerAddress
}

function sub_5385f37b(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_553d90e9(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_56587229(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return address(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_56ec9075(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function operator() {
    return operatorAddress
}

function sub_600e461e(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_66a6f36d(?) {
    require calldata.size - 4 >= 96
    return sub_66a6f36d[arg1][arg2][arg3]
}

function configuration() {
    return configurationAddress
}

function sub_6e90a596(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_7ff81c37(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return bool(uint8(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0))
}

function sub_8b4ed4c2(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_b6e2fc33(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    require uint8(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0) < 2
    return uint8(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_c46fcd75(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function sub_cf293aac(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return bool(uint8(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0))
}

function deployer() {
    return deployerAddress
}

function triggerSelfDestruction() {
    require deployerAddress == msg.sender
    require not uint8(stor0.field_0)
    emit TriggerSelfDestructionEvent(msg.sender);
    selfdestruct(msg.sender)
}

function _fallback() payable {
    revert
}

function freezeBalanceTracker() {
    require msg.sender == deployerAddress
    stor5 = 1
    emit FreezeBalanceTrackerEvent()
}

function disableSelfDestruction() {
    require deployerAddress == msg.sender
    uint8(stor0.field_0) = 1
    emit SelfDestructionDisabledEvent(msg.sender);
}

function setServiceActivationTimeout(uint256 arg1) {
    require calldata.size - 4 >= 32
    require msg.sender == deployerAddress
    sub_3b7bea6c = arg1
    emit ServiceActivationTimeoutEvent(arg1);
}

function isRegisteredActiveService(address arg1) {
    require calldata.size - 4 >= 32
    if not uint8(stor2[address(arg1)].field_0):
        return bool(uint8(stor2[address(arg1)].field_0))
    return block.timestamp >= uint256(stor2[address(arg1)].field_256)
}

function setConfiguration(address arg1) {
    require calldata.size - 4 >= 32
    require msg.sender == deployerAddress
    require arg1
    if configurationAddress != arg1:
        configurationAddress = arg1
        emit 0x634f61bf: configurationAddress, arg1
}

function sub_598b75ad(?) {
    require calldata.size - 4 >= 32
    require msg.sender == deployerAddress
    require arg1
    if sub_19139092Address != arg1:
        require not stor5
        sub_19139092Address = arg1
        emit 0xb2a91d3a: sub_19139092Address, arg1
}

function setOperator(address arg1) {
    require calldata.size - 4 >= 32
    require msg.sender == operatorAddress
    require arg1
    require arg1 != this.address
    if operatorAddress != arg1:
        operatorAddress = arg1
        emit SetOperatorEvent(operatorAddress, arg1);
}

function setDeployer(address arg1) {
    require calldata.size - 4 >= 32
    require msg.sender == deployerAddress
    require arg1
    require arg1 != this.address
    if deployerAddress != arg1:
        deployerAddress = arg1
        emit SetDeployerEvent(address(stor0.field_0), arg1);
}

function deregisterService(address arg1) {
    require calldata.size - 4 >= 32
    require msg.sender == deployerAddress
    require arg1
    require arg1 != this.address
    require uint8(stor2[address(arg1)].field_0)
    uint8(stor2[address(arg1)].field_0) = 0
    emit DeregisterServiceEvent(arg1);
}

function sub_5482c735(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3]
    require sub_66a6f36d[address(arg1)][address(arg2)][arg3] - 1 < sub_1b90e3c1.length
    return block.timestamp >= uint256(sub_1b90e3c1[stor7[address(arg1)][address(arg2)][arg3]].field_0)
}

function registerService(address arg1) {
    require calldata.size - 4 >= 32
    require msg.sender == deployerAddress
    require arg1
    require arg1 != this.address
    if not uint8(stor2[address(arg1)].field_0):
        uint8(stor2[address(arg1)].field_0) = 1
        uint256(stor2[address(arg1)].field_256) = block.timestamp
    emit RegisterServiceEvent(arg1);
}

function registerServiceDeferred(address arg1) {
    require calldata.size - 4 >= 32
    require msg.sender == deployerAddress
    require arg1
    require arg1 != this.address
    if not uint8(stor2[address(arg1)].field_0):
        uint8(stor2[address(arg1)].field_0) = 1
        uint256(stor2[address(arg1)].field_256) = sub_3b7bea6c + block.timestamp
    emit RegisterServiceDeferredEvent(address(arg1), sub_3b7bea6c);
}

function sub_b3938a6c(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    mem[256 len 0] = None
    require uint8(stor2[address(msg.sender)].field_0)
    require block.timestamp >= uint256(stor2[address(msg.sender)].field_256)
    require uint8(stor2[address(msg.sender)][2][sha3(Mask(144, 0, mem[256 len 14], 0, 0))].field_0)
    if sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]:
        require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
        Mask(248, 0, sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = 1
        emit 0x4a79fdef: address(arg1), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), arg2 << 192, arg3, uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), bool(uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0))
}

function sub_a495a306(?) {
    require calldata.size - 4 >= 128
    require calldata.size - 36 >= 64
    mem[256 len 0] = None
    require uint8(stor2[address(msg.sender)].field_0)
    require block.timestamp >= uint256(stor2[address(msg.sender)].field_256)
    require uint8(stor2[address(msg.sender)][2][sha3(Mask(144, 0, mem[256 len 14], 0, 0))].field_0)
    if sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]:
        require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
        require arg4 == bool(uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0))
        require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
        Mask(248, 0, sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = 1
        emit 0x4a79fdef: address(arg1), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), arg2 << 192, arg3, uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), bool(uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0))
}

function disableServiceAction(address arg1, string arg2) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require calldata.size > arg2 + 35
    require arg2.length <= test266151307()
    require ceil32(arg2.length) + 128 >= 96 and ceil32(arg2.length) + 128 <= test266151307()
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    require msg.sender == deployerAddress
    require arg1
    require arg1 != this.address
    mem[ceil32(arg2.length) + 160 len floor32(arg2.length)] = call.data[arg2 + 36 len floor32(arg2.length)]
    mem[ceil32(arg2.length) + floor32(arg2.length) + -(arg2.length % 32) + 192 len arg2.length % 32] = mem[-(arg2.length % 32) + floor32(arg2.length) + 160 len arg2.length % 32]
    mem[ceil32(arg2.length) + 128] = arg2.length
    mem[64] = arg2.length + ceil32(arg2.length) + 160
    _28 = Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]
    mem[arg2.length + ceil32(arg2.length) + 160 len floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)])] = mem[ceil32(arg2.length) + 160 len floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)])]
    mem[arg2.length + ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] = mem[arg2.length + ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] and 256^(-(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)] % 32) + 32) - 1 or mem[ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] and !(256^(-(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)] % 32) + 32) - 1)
    require uint8(stor2[address(arg1)][2][sha3(mem[arg2.length + ceil32(arg2.length) + 160 len _28])].field_0)
    uint8(stor2[address(arg1)][2][sha3(mem[arg2.length + ceil32(arg2.length) + 160 len _28])].field_0) = 0
    emit DisableServiceActionEvent(address(arg1), Array(len=arg2.length, data=arg2[all]));
}

function isEnabledServiceAction(address arg1, string arg2) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require calldata.size > arg2 + 35
    require arg2.length <= test266151307()
    require ceil32(arg2.length) + 128 >= 96 and ceil32(arg2.length) + 128 <= test266151307()
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    mem[ceil32(arg2.length) + 160 len floor32(arg2.length)] = call.data[arg2 + 36 len floor32(arg2.length)]
    mem[ceil32(arg2.length) + floor32(arg2.length) + -(arg2.length % 32) + 192 len arg2.length % 32] = mem[-(arg2.length % 32) + floor32(arg2.length) + 160 len arg2.length % 32]
    mem[ceil32(arg2.length) + 128] = arg2.length
    mem[64] = arg2.length + ceil32(arg2.length) + 160
    _29 = Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]
    mem[arg2.length + ceil32(arg2.length) + 160 len floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)])] = mem[ceil32(arg2.length) + 160 len floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)])]
    mem[arg2.length + ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] = mem[arg2.length + ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] and 256^(-(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)] % 32) + 32) - 1 or mem[ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] and !(256^(-(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)] % 32) + 32) - 1)
    if not uint8(stor2[address(arg1)].field_0):
        return bool(uint8(stor2[address(arg1)].field_0))
    if block.timestamp < uint256(stor2[address(arg1)].field_256):
        return block.timestamp >= uint256(stor2[address(arg1)].field_256)
    mem[arg2.length + ceil32(arg2.length) + 160] = bool(uint8(stor2[address(arg1)][2][sha3(mem[arg2.length + ceil32(arg2.length) + 160 len _29])].field_0))
    return memory
      from arg2.length + ceil32(arg2.length) + 160
       len 32
}

function enableServiceAction(address arg1, string arg2) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require calldata.size > arg2 + 35
    require arg2.length <= test266151307()
    require ceil32(arg2.length) + 128 >= 96 and ceil32(arg2.length) + 128 <= test266151307()
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    require msg.sender == deployerAddress
    require arg1
    require arg1 != this.address
    mem[0] = arg1
    mem[32] = 2
    require uint8(stor2[address(arg1)].field_0)
    mem[ceil32(arg2.length) + 160 len floor32(arg2.length)] = call.data[arg2 + 36 len floor32(arg2.length)]
    mem[ceil32(arg2.length) + floor32(arg2.length) + -(arg2.length % 32) + 192 len arg2.length % 32] = mem[-(arg2.length % 32) + floor32(arg2.length) + 160 len arg2.length % 32]
    mem[ceil32(arg2.length) + 128] = arg2.length
    mem[64] = arg2.length + ceil32(arg2.length) + 160
    _30 = Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]
    mem[arg2.length + ceil32(arg2.length) + 160 len floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)])] = mem[ceil32(arg2.length) + 160 len floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)])]
    mem[arg2.length + ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] = mem[arg2.length + ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] and 256^(-(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)] % 32) + 32) - 1 or mem[ceil32(arg2.length) + floor32(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)]) + 160] and !(256^(-(Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[arg2.length + 160 len -arg2.length + ceil32(arg2.length)] % 32) + 32) - 1)
    require not uint8(stor2[address(arg1)][2][sha3(mem[arg2.length + ceil32(arg2.length) + 160 len _30])].field_0)
    uint8(stor2[address(arg1)][2][sha3(mem[arg2.length + ceil32(arg2.length) + 160 len _30])].field_0) = 1
    uint256(stor2[address(arg1)].field_768)++
    uint256(stor[('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'stor2', 2))) + uint256(stor2[address(arg1)].field_768)].field_0) = sha3(mem[arg2.length + ceil32(arg2.length) + 160 len _30])
    emit EnableServiceActionEvent(address(arg1), Array(len=arg2.length, data=arg2[all]));
}

function sub_667666c8(?) {
    require calldata.size - 4 >= 256
    require calldata.size - 36 >= 64
    mem[96] = arg2
    mem[128] = arg3
    require arg8 <= test266151307()
    require calldata.size > arg8 + 35
    require arg8.length <= test266151307()
    require ceil32(arg8.length) + 192 >= 160 and ceil32(arg8.length) + 192 <= test266151307()
    mem[160] = arg8.length
    require arg8 + arg8.length + 36 <= calldata.size
    mem[192 len arg8.length] = arg8[all]
    mem[arg8.length + 192] = 0
    mem[64] = ceil32(arg8.length) + 256
    mem[ceil32(arg8.length) + 192] = 19
    mem[ceil32(arg8.length) + 224] = 0x6469737175616c6966795f70726f706f73616c00000000000000000000000000
    mem[ceil32(arg8.length) + 288 len floor32(Mask(8 * -ceil32(arg8.length) + arg8.length + 32, 0, 0), mem[arg8.length + 224 len -arg8.length + ceil32(arg8.length)])] = mem[ceil32(arg8.length) + 224 len floor32(Mask(8 * -ceil32(arg8.length) + arg8.length + 32, 0, 0), mem[arg8.length + 224 len -arg8.length + ceil32(arg8.length)])]
    mem[ceil32(arg8.length) + floor32(Mask(8 * -ceil32(arg8.length) + arg8.length + 32, 0, 0), mem[arg8.length + 224 len -arg8.length + ceil32(arg8.length)]) + -(Mask(8 * -ceil32(arg8.length) + arg8.length + 32, 0, 0), mem[arg8.length + 224 len -arg8.length + ceil32(arg8.length)] % 32) + 320 len Mask(8 * -ceil32(arg8.length) + arg8.length + 32, 0, 0), mem[arg8.length + 224 len -arg8.length + ceil32(arg8.length)] % 32] = mem[ceil32(arg8.length) + -(Mask(8 * -ceil32(arg8.length) + arg8.length + 32, 0, 0), mem[arg8.length + 224 len -arg8.length + ceil32(arg8.length)] % 32) + floor32(Mask(8 * -ceil32(arg8.length) + arg8.length + 32, 0, 0), mem[arg8.length + 224 len -arg8.length + ceil32(arg8.length)]) + 256 len Mask(8 * -ceil32(arg8.length) + arg8.length + 32, 0, 0), mem[arg8.length + 224 len -arg8.length + ceil32(arg8.length)] % 32]
    require uint8(stor2[address(msg.sender)].field_0)
    require block.timestamp >= uint256(stor2[address(msg.sender)].field_256)
    require uint8(stor2[address(msg.sender)][2][sha3(Mask(152, 0, mem[ceil32(arg8.length) + 288 len 19], 0))].field_0)
    require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]
    require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
    uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = 1
    require ext_code.size(configurationAddress)
    call configurationAddress.0xfbdfd8e7 with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] + block.timestamp >= block.timestamp
    require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
    uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = ext_call.return_data[0] + block.timestamp
    require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
    address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = arg4
    uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = arg6
    require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
    uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = arg5
    uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = arg7
    uint256(stor[sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)][].field_0) = Array(len=arg8.length, data=arg8[all])
    require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
    emit 0x8bacef72: address(arg1), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), arg2 << 192, arg3, uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), bool(uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0)), address(arg4), arg6, arg7, Array(len=arg8.length, data=arg8[all])
}

function proposals(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < sub_1b90e3c1.length
    mem[352] = uint256(stor[sha3((19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11)].field_0)
    idx = 352
    s = 0
    while stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length + 320 > idx:
        mem[idx + 32] = uint256(stor[s + sha3((19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11)].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length) + 576] = uint256(stor[sha3((19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17)].field_0)
    idx = ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length) + 576
    s = 0
    while ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length) + stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length + 576 > idx + 32:
        mem[idx + 32] = uint256(stor[s + sha3((19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17)].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    require uint8(sub_1b90e3c1[arg1].field_1280) < 2
    if ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length) > stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length:
        mem[stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1152] = 0
    mem[(2 * ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1152] = address(sub_1b90e3c1[arg1].field_3584)
    mem[(2 * ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1184] = uint256(sub_1b90e3c1[arg1].field_3840)
    mem[(2 * ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1216] = uint256(sub_1b90e3c1[arg1].field_4096)
    mem[(2 * ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1248] = 128
    mem[(2 * ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1280] = 64
    mem[(2 * ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1344] = stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length
    mem[(2 * ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1376 len ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length)] = mem[ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length) + 576 len ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length)]
    if ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) > stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length:
        mem[stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length + (2 * ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)) + ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length) + 1376] = 0
    return address(sub_1b90e3c1[arg1].field_0), 
           uint256(sub_1b90e3c1[arg1].field_256),
           uint256(sub_1b90e3c1[arg1].field_512),
           uint256(sub_1b90e3c1[arg1].field_768),
           uint256(sub_1b90e3c1[arg1].field_1024),
           uint8(sub_1b90e3c1[arg1].field_1280),
           uint256(sub_1b90e3c1[arg1].field_1536),
           uint256(sub_1b90e3c1[arg1].field_1792),
           uint256(sub_1b90e3c1[arg1].field_2048),
           address(sub_1b90e3c1[arg1].field_2304),
           uint256(sub_1b90e3c1[arg1].field_2560),
           480,
           bool(uint8(sub_1b90e3c1[arg1].field_3328)),
           bool(uint8(sub_1b90e3c1[arg1].field_3336)),
           ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length) + 576,
           64,
           uint256(sub_1b90e3c1[arg1].field_3072),
           stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length,
           mem[352 len ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length)],
           address(sub_1b90e3c1[arg1].field_3584),
           uint256(sub_1b90e3c1[arg1].field_3840),
           uint256(sub_1b90e3c1[arg1].field_4096),
           128,
           64,
           uint256(sub_1b90e3c1[arg1].field_4608),
           stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length,
           mem[ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 11].length) + 576 len ceil32(stor[(19 * arg1) + ('name', 'sub_1b90e3c1', 6) + 17].length)]
}

function sub_ba515288(?) {
    require calldata.size - 4 >= 256
    require calldata.size - 132 >= 64
    mem[256 len 0] = None
    require uint8(stor2[address(msg.sender)].field_0)
    require block.timestamp >= uint256(stor2[address(msg.sender)].field_256)
    require uint8(stor2[address(msg.sender)][2][sha3(Mask(136, 0, mem[256 len 15], 0, 0))].field_0)
    require ext_code.size(0x2fcb98529d58669e229c453de4b4705bb6b2d414)
    delegate 0x2fcb98529d58669e229c453de4b4705bb6b2d414.isPositiveInt256(int256 arg1) with:
         gas gas_remaining wei
        args arg3
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require delegate.return_data[0]
    require ext_code.size(0x2fcb98529d58669e229c453de4b4705bb6b2d414)
    delegate 0x2fcb98529d58669e229c453de4b4705bb6b2d414.isPositiveInt256(int256 arg1) with:
         gas gas_remaining wei
        args arg4
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require delegate.return_data[0]
    if sub_66a6f36d[address(arg1)][uint64(arg5) << 96][arg6]:
        require sub_66a6f36d[address(arg1)][uint64(arg5) << 96][arg6] - 1 < sub_1b90e3c1.length
        address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = arg1
        uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = arg2
        uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = arg7
        uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = block.number
        require ext_code.size(configurationAddress)
        call configurationAddress.0xfbdfd8e7 with:
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] + block.timestamp >= block.timestamp
        require sub_66a6f36d[address(arg1)][uint64(arg5) << 96][arg6] - 1 < sub_1b90e3c1.length
        uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = ext_call.return_data[0] + block.timestamp
        require sub_66a6f36d[address(arg1)][uint64(arg5) << 96][arg6] - 1 < sub_1b90e3c1.length
        uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = 0
        require sub_66a6f36d[address(arg1)][uint64(arg5) << 96][arg6] - 1 < sub_1b90e3c1.length
        address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = uint64(arg5) << 96
        uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = arg6
        require sub_66a6f36d[address(arg1)][uint64(arg5) << 96][arg6] - 1 < sub_1b90e3c1.length
        uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = arg3
        uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = arg4
        uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = uint8(arg8)
        Mask(248, 0, sub_1b90e3c1[stor7[address(arg1)][uint64(arg5) << 96][arg6]].field_0) = 0
    else:
        sub_1b90e3c1.length++
        if sub_1b90e3c1.length > sub_1b90e3c1.length + 1:
            mem[0] = 6
            idx = (19 * sub_1b90e3c1.length) + 19
            while sha3(6) + (19 * sub_1b90e3c1.length) > idx + sha3(mem[0]):
                address(stor[idx + sha3(mem[0])]) = 0
                uint256(stor[idx + sha3(mem[0]) + 1]) = 0
                uint256(stor[idx + sha3(mem[0]) + 2]) = 0
                uint256(stor[idx + sha3(mem[0]) + 3]) = 0
                uint256(stor[idx + sha3(mem[0]) + 4]) = 0
                uint8(stor[idx + sha3(mem[0]) + 5]) = 0
                uint256(stor[idx + sha3(mem[0]) + 6]) = 0
                uint256(stor[idx + sha3(mem[0]) + 7]) = 0
                uint256(stor[idx + sha3(mem[0]) + 8]) = 0
                address(stor[idx + sha3(mem[0]) + 9]) = 0
                uint256(stor[idx + sha3(mem[0]) + 10]) = 0
                uint256(stor[idx + sha3(mem[0]) + 11]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 11].length:
                    mem[0] = idx + sha3(mem[0]) + 11
                    s = sha3(idx + sha3(mem[0]) + 11)
                    while sha3(idx + sha3(mem[0]) + 11) + (stor[idx + sha3(mem[0]) + 11].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 12]) = 0
                uint16(stor[idx + sha3(mem[0]) + 13]) = 0
                address(stor[idx + sha3(mem[0]) + 14]) = 0
                uint256(stor[idx + sha3(mem[0]) + 15]) = 0
                uint256(stor[idx + sha3(mem[0]) + 16]) = 0
                uint256(stor[idx + sha3(mem[0]) + 17]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 17].length:
                    mem[0] = idx + sha3(mem[0]) + 17
                    s = sha3(idx + sha3(mem[0]) + 17)
                    while sha3(idx + sha3(mem[0]) + 17) + (stor[idx + sha3(mem[0]) + 17].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 18]) = 0
                idx = idx + 19
                continue 
        sub_66a6f36d[address(arg1)][uint64(arg5) << 96][arg6] = sub_1b90e3c1.length + 1
        require sub_1b90e3c1.length < sub_1b90e3c1.length
        address(sub_1b90e3c1[sub_1b90e3c1.length].field_0) = arg1
        uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_256) = arg2
        uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_512) = arg7
        uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_768) = block.number
        require ext_code.size(configurationAddress)
        call configurationAddress.0xfbdfd8e7 with:
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] + block.timestamp >= block.timestamp
        require sub_1b90e3c1.length < sub_1b90e3c1.length
        uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_1024) = ext_call.return_data[0] + block.timestamp
        require sub_1b90e3c1.length < sub_1b90e3c1.length
        uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_1280) = 0
        require sub_1b90e3c1.length < sub_1b90e3c1.length
        address(sub_1b90e3c1[sub_1b90e3c1.length].field_2304) = uint64(arg5) << 96
        uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_2560) = arg6
        require sub_1b90e3c1.length < sub_1b90e3c1.length
        uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_1792) = arg3
        uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_2048) = arg4
        uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_3328) = uint8(arg8)
        Mask(248, 0, sub_1b90e3c1[sub_1b90e3c1.length].field_3336) = 0
    emit 0x4d1aefd5: address(arg1), arg2, arg3, arg4, arg5 << 192, arg6, arg7, arg8
}

function sub_26885b54(?) {
    require calldata.size - 4 >= 96
    require calldata.size - 36 >= 64
    mem[256 len 0] = None
    mem[256 len 0] = 0
    require uint8(stor2[address(msg.sender)].field_0)
    require block.timestamp >= uint256(stor2[address(msg.sender)].field_256)
    require uint8(stor2[address(msg.sender)][2][sha3(Mask(120, 0, mem[256 len 15], 0))].field_0)
    if sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]:
        require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
        emit 0x339eee9d: address(arg1), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), arg2 << 192, arg3, uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), bool(uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0))
        require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
        sub_66a6f36d[address(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)][address(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)][uint256(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)] = 0
        if sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] < sub_1b90e3c1.length:
            require sub_1b90e3c1.length - 1 < sub_1b90e3c1.length
            require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
            address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = address(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            require uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0) <= 1
            uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = address(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            if 31 >= stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 8].length:
                uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
                idx = 0
                while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32 > idx:
                    uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = Mask(255, 1, uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0) and (256 * not bool(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) - 1) + 1
                if not Mask(255, 1, uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0) and (256 * not bool(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) - 1):
                    idx = 0
                    while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32 > idx:
                        uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    s = 0
                    idx = 0
                    while stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32 > idx:
                        uint256(stor[s + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0) = uint256(stor[idx + sha3((19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0)
                        s = s + 1
                        idx = idx + 1
                        continue 
                    idx = stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32
                    while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32 > idx:
                        uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0) = 0
                        idx = idx + 1
                        continue 
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint8(bool(uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0)))
            uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint8(bool(uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0)))
            Mask(248, 0, sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = Mask(248, 0, bool(uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0)))
            Mask(240, 0, sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = Mask(240, 16, bool(uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0))) >> 16
            address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = address(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            if 31 >= stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 2].length:
                uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
                idx = 0
                while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32 > idx:
                    uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = Mask(255, 1, (256 * not bool(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) - 1 and uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) + 1
                if not Mask(255, 1, (256 * not bool(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) - 1 and uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)):
                    idx = 0
                    while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32 > idx:
                        uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    s = 0
                    idx = 0
                    while stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32 > idx:
                        uint256(stor[s + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0) = uint256(stor[idx + sha3((19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0)
                        s = s + 1
                        idx = idx + 1
                        continue 
                    idx = stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32
                    while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32 > idx:
                        uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0) = 0
                        idx = idx + 1
                        continue 
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
            sub_66a6f36d[address(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)][address(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)][uint256(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)] = sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]
        sub_1b90e3c1.length--
        if sub_1b90e3c1.length > sub_1b90e3c1.length - 1:
            mem[0] = 6
            idx = (19 * sub_1b90e3c1.length) - 19
            while sha3(6) + (19 * sub_1b90e3c1.length) > idx + sha3(mem[0]):
                address(stor[idx + sha3(mem[0])]) = 0
                uint256(stor[idx + sha3(mem[0]) + 1]) = 0
                uint256(stor[idx + sha3(mem[0]) + 2]) = 0
                uint256(stor[idx + sha3(mem[0]) + 3]) = 0
                uint256(stor[idx + sha3(mem[0]) + 4]) = 0
                uint8(stor[idx + sha3(mem[0]) + 5]) = 0
                uint256(stor[idx + sha3(mem[0]) + 6]) = 0
                uint256(stor[idx + sha3(mem[0]) + 7]) = 0
                uint256(stor[idx + sha3(mem[0]) + 8]) = 0
                address(stor[idx + sha3(mem[0]) + 9]) = 0
                uint256(stor[idx + sha3(mem[0]) + 10]) = 0
                uint256(stor[idx + sha3(mem[0]) + 11]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 11].length:
                    mem[0] = idx + sha3(mem[0]) + 11
                    s = sha3(idx + sha3(mem[0]) + 11)
                    while sha3(idx + sha3(mem[0]) + 11) + (stor[idx + sha3(mem[0]) + 11].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 12]) = 0
                uint16(stor[idx + sha3(mem[0]) + 13]) = 0
                address(stor[idx + sha3(mem[0]) + 14]) = 0
                uint256(stor[idx + sha3(mem[0]) + 15]) = 0
                uint256(stor[idx + sha3(mem[0]) + 16]) = 0
                uint256(stor[idx + sha3(mem[0]) + 17]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 17].length:
                    mem[0] = idx + sha3(mem[0]) + 17
                    s = sha3(idx + sha3(mem[0]) + 17)
                    while sha3(idx + sha3(mem[0]) + 17) + (stor[idx + sha3(mem[0]) + 17].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 18]) = 0
                idx = idx + 19
                continue 
}

function sub_52a0dd10(?) {
    require calldata.size - 4 >= 128
    require calldata.size - 36 >= 64
    mem[256 len 0] = None
    mem[256 len 0] = 0
    require uint8(stor2[address(msg.sender)].field_0)
    require block.timestamp >= uint256(stor2[address(msg.sender)].field_256)
    require uint8(stor2[address(msg.sender)][2][sha3(Mask(120, 0, mem[256 len 15], 0))].field_0)
    if sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]:
        require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
        require arg4 == bool(uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0))
        require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
        emit 0x339eee9d: address(arg1), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), arg2 << 192, arg3, uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0), bool(uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0))
        require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
        sub_66a6f36d[address(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)][address(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)][uint256(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)] = 0
        if sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] < sub_1b90e3c1.length:
            require sub_1b90e3c1.length - 1 < sub_1b90e3c1.length
            require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
            address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = address(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            require uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0) <= 1
            uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = address(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            if 31 >= stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 8].length:
                uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
                idx = 0
                while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32 > idx:
                    uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = Mask(255, 1, uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0) and (256 * not bool(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) - 1) + 1
                if not Mask(255, 1, uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0) and (256 * not bool(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) - 1):
                    idx = 0
                    while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32 > idx:
                        uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    s = 0
                    idx = 0
                    while stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32 > idx:
                        uint256(stor[s + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0) = uint256(stor[idx + sha3((19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0)
                        s = s + 1
                        idx = idx + 1
                        continue 
                    idx = stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32
                    while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8].length + 31 / 32 > idx:
                        uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 8)].field_0) = 0
                        idx = idx + 1
                        continue 
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint8(bool(uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0)))
            uint8(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint8(bool(uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0)))
            Mask(248, 0, sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = Mask(248, 0, bool(uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0)))
            Mask(240, 0, sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = Mask(240, 16, bool(uint8(sub_1b90e3c1[sub_1b90e3c1.length].field_0))) >> 16
            address(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = address(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            if 31 >= stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 2].length:
                uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
                idx = 0
                while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32 > idx:
                    uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = Mask(255, 1, (256 * not bool(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) - 1 and uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) + 1
                if not Mask(255, 1, (256 * not bool(sub_1b90e3c1[sub_1b90e3c1.length].field_0)) - 1 and uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)):
                    idx = 0
                    while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32 > idx:
                        uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0) = 0
                        idx = idx + 1
                        continue 
                else:
                    s = 0
                    idx = 0
                    while stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32 > idx:
                        uint256(stor[s + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0) = uint256(stor[idx + sha3((19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0)
                        s = s + 1
                        idx = idx + 1
                        continue 
                    idx = stor[(19 * sub_1b90e3c1.length) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32
                    while stor[(19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2].length + 31 / 32 > idx:
                        uint256(stor[idx + sha3((19 * stor7[address(arg1)][uint64(arg2) << 96][arg3]) + ('name', 'sub_1b90e3c1', 6) - 2)].field_0) = 0
                        idx = idx + 1
                        continue 
            uint256(sub_1b90e3c1[stor7[address(arg1)][uint64(arg2) << 96][arg3]].field_0) = uint256(sub_1b90e3c1[sub_1b90e3c1.length].field_0)
            require sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3] - 1 < sub_1b90e3c1.length
            sub_66a6f36d[address(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)][address(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)][uint256(stor6[sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]].field_0)] = sub_66a6f36d[address(arg1)][uint64(arg2) << 96][arg3]
        sub_1b90e3c1.length--
        if sub_1b90e3c1.length > sub_1b90e3c1.length - 1:
            mem[0] = 6
            idx = (19 * sub_1b90e3c1.length) - 19
            while sha3(6) + (19 * sub_1b90e3c1.length) > idx + sha3(mem[0]):
                address(stor[idx + sha3(mem[0])]) = 0
                uint256(stor[idx + sha3(mem[0]) + 1]) = 0
                uint256(stor[idx + sha3(mem[0]) + 2]) = 0
                uint256(stor[idx + sha3(mem[0]) + 3]) = 0
                uint256(stor[idx + sha3(mem[0]) + 4]) = 0
                uint8(stor[idx + sha3(mem[0]) + 5]) = 0
                uint256(stor[idx + sha3(mem[0]) + 6]) = 0
                uint256(stor[idx + sha3(mem[0]) + 7]) = 0
                uint256(stor[idx + sha3(mem[0]) + 8]) = 0
                address(stor[idx + sha3(mem[0]) + 9]) = 0
                uint256(stor[idx + sha3(mem[0]) + 10]) = 0
                uint256(stor[idx + sha3(mem[0]) + 11]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 11].length:
                    mem[0] = idx + sha3(mem[0]) + 11
                    s = sha3(idx + sha3(mem[0]) + 11)
                    while sha3(idx + sha3(mem[0]) + 11) + (stor[idx + sha3(mem[0]) + 11].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 12]) = 0
                uint16(stor[idx + sha3(mem[0]) + 13]) = 0
                address(stor[idx + sha3(mem[0]) + 14]) = 0
                uint256(stor[idx + sha3(mem[0]) + 15]) = 0
                uint256(stor[idx + sha3(mem[0]) + 16]) = 0
                uint256(stor[idx + sha3(mem[0]) + 17]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 17].length:
                    mem[0] = idx + sha3(mem[0]) + 17
                    s = sha3(idx + sha3(mem[0]) + 17)
                    while sha3(idx + sha3(mem[0]) + 17) + (stor[idx + sha3(mem[0]) + 17].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 18]) = 0
                idx = idx + 19
                continue 
}



}
