contract main {


// =======================  Init code  ======================


uint256 stor0;
array of uint256 stor1;
address stor2;
array of address stor3;
mapping of uint256 stor258;
uint256 stor261;
mapping of uint256 stor262;
array of struct stor266;
uint8 stor267;

function _fallback() payable {
    stor267 = 1
    mem[192] = 0x75abf69f2da1521e2769e7f093c8d8406a712bf
    stor1.length = 1
    stor0 = 1
    s = 0
    s = 0
    idx = 0
    while idx < 1:
        require idx < 1
        require mem[(32 * idx) + 204 len 20]
        require stor258[mem[(32 * idx) + 204 len 20]] <= 0
        require idx + 1
        require idx + 1 <= 250
        require idx + 1 < 256
        stor3[idx] = mem[(32 * idx) + 204 len 20]
        mem[0] = mem[(32 * idx) + 204 len 20]
        mem[32] = 258
        stor258[address(mem[(32 * idx) + 192])] = idx + 1
        s = idx + 1
        s = mem[(32 * idx) + 192]
        idx = idx + 1
        continue 
    require stor1.length > 0
    require stor1.length <= 250
    require not stor2
    require stor0
    require stor0 <= stor1.length
    stor261 = 2 * 10^13
    stor262[address(msg.sender)] = 2 * 10^13
    emit Transfer(2 * 10^13, 0, msg.sender);
    mem[0] = 0x81b7731daef3942e513d0746a75134012592bba3
    s = 0
    idx = 0
    while idx < stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0:
        require idx < stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0
        if uint128(stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_256) != 1528684200:
            mem[0] = 0x81b7731daef3942e513d0746a75134012592bba3
            mem[32] = 266
            s = (2 * idx) + sha3(sha3(0x81b7731daef3942e513d0746a75134012592bba3, 266))
            idx = idx + 1
            continue 
        if uint128(stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_384):
            mem[0] = 0x81b7731daef3942e513d0746a75134012592bba3
            mem[32] = 266
            s = (2 * idx) + sha3(sha3(0x81b7731daef3942e513d0746a75134012592bba3, 266))
            idx = idx + 1
            continue 
        require idx <= stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0
        if idx == stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0:
            stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0++
            if not stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0 <= stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0 + 1:
                mem[0] = sha3(0x81b7731daef3942e513d0746a75134012592bba3, 266)
                s = sha3(mem[0]) + (2 * stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0 + 1)
                while sha3(sha3(0x81b7731daef3942e513d0746a75134012592bba3, 266)) + (2 * stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0) > s:
                    stor[s] = 0
                    stor1[s] = 0
                    mem[0] = 0x81b7731daef3942e513d0746a75134012592bba3
                    mem[32] = 266
                    s = s + 2
                    continue 
            require idx < stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0
            require not stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_0
            stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_256 = 1528684200
        require idx < stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0
        require uint128(stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_256) == 1528684200
        require not uint128(stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_384)
        require stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_0 + 20 * 10^6 >= stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_0
        stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_0 += 20 * 10^6
        require stor261 + 20 * 10^6 >= stor261
        stor261 += 20 * 10^6
        call 0x325890465307fbac3226d2688165205098936674 with:
           value 4 * 10^16 wei
             gas 0 wei
        require ext_call.success
        call 0x65dd7690901500fdd6b26f0a4d722e1e859ad301 with:
           value 16 * 10^16 wei
             gas 0 wei
        return code.data[1852 len 10205]
    require idx <= stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0
    if idx == stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0:
        stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0++
        if not stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0 <= stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0 + 1:
            s = 2 * stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0 + 1
            while 2 * stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0 > s:
                stor266[0x81b7731daef3942e513d0746a75134012592bba3][s].field_0 = 0
                stor266[0x81b7731daef3942e513d0746a75134012592bba3][s].field_256 = 0
                s = s + 2
                continue 
        require idx < stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0
        require not stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_0
        stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_256 = 1528684200
    require idx < stor266[0x81b7731daef3942e513d0746a75134012592bba3].field_0
    require uint128(stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_256) == 1528684200
    require not uint128(stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_384)
    require stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_0 + 20 * 10^6 >= stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_0
    stor266[0x81b7731daef3942e513d0746a75134012592bba3][idx].field_0 += 20 * 10^6
    require stor261 + 20 * 10^6 >= stor261
    stor261 += 20 * 10^6
    call 0x325890465307fbac3226d2688165205098936674 with:
       value 4 * 10^16 wei
         gas 0 wei
    require ext_call.success
    call 0x65dd7690901500fdd6b26f0a4d722e1e859ad301 with:
       value 16 * 10^16 wei
         gas 0 wei
    return code.data[1852 len 10205]
}



// =====================  Runtime code  =====================


const name = 'StavCoin'

const decimals = 5

const symbol = 'STV'


uint256 m_multiOwnedRequired;
array of uint256 stor1;
array of address stor2;
array of address owner;
mapping of uint256 stor258;
mapping of struct stor259;
array of uint256 stor260;
uint256 totalSupply;
mapping of uint256 stor262;
mapping of uint256 allowance;
address m_KYCProviderAddress;
mapping of uint8 stor265;
array of struct frozenCellCount;
uint8 m_allowPrivileged;

function totalSupply() {
    return totalSupply
}

function m_allowPrivileged() {
    return bool(m_allowPrivileged)
}

function m_numOwners() {
    return stor1.length
}

function frozenCellCount(address arg1) {
    return frozenCellCount[address(arg1)].field_0
}

function m_multiOwnedRequired() {
    return m_multiOwnedRequired
}

function frozenBalances(address arg1, uint256 arg2) {
    require arg2 < frozenCellCount[arg1].field_0
    return frozenCellCount[arg1][arg2].field_0, 
           uint128(frozenCellCount[arg1][arg2].field_256),
           uint128(frozenCellCount[arg1][arg2].field_384)
}

function m_sales(address arg1) {
    return bool(stor265[arg1])
}

function getOwner(uint256 arg1) {
    require arg1 + 1 < 256
    return owner[arg1]
}

function allowance(address arg1, address arg2) {
    return allowance[address(arg1)][address(arg2)]
}

function m_KYCProvider() {
    return m_KYCProviderAddress
}

function frozenCell(address arg1, uint256 arg2) {
    require arg2 < frozenCellCount[address(arg1)].field_0
    require arg2 < frozenCellCount[address(arg1)].field_0
    require arg2 < frozenCellCount[address(arg1)].field_0
    require arg2 < frozenCellCount[address(arg1)].field_0
    return frozenCellCount[address(arg1)][arg2].field_0, 
           uint128(frozenCellCount[address(arg1)][arg2].field_256),
           bool(uint128(frozenCellCount[address(arg1)][arg2].field_384))
}

function _fallback() payable {
    revert
}

function isOwner(address arg1) {
    return (stor258[address(arg1)] > 0)
}

function amIOwner() {
    require stor258[address(msg.sender)] > 0
    return 1
}

function approve(address arg1, uint256 arg2) {
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function hasConfirmed(bytes32 arg1, address arg2) {
    require stor259[arg1].field_0
    require stor258[address(arg2)] > 0
    require stor258[address(arg2)]
    require stor258[address(arg2)] <= 250
    return bool(stor259[arg1].field_256 and 2^stor258[address(arg2)])
}

function increaseApproval(address arg1, uint256 arg2) {
    require arg2 + allowance[address(msg.sender)][address(arg1)] >= allowance[address(msg.sender)][address(arg1)]
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((arg2 + allowance[address(msg.sender)][address(arg1)]), msg.sender, arg1);
    return 1
}

function decreaseApproval(address arg1, uint256 arg2) {
    if arg2 <= allowance[address(msg.sender)][address(arg1)]:
        allowance[address(msg.sender)][address(arg1)] -= arg2
    else:
        allowance[address(msg.sender)][address(arg1)] = 0
    emit Approval(allowance[address(msg.sender)][address(arg1)], msg.sender, arg1);
    return 1
}

function approveAndCall(address arg1, uint256 arg2, bytes arg3) {
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    require ext_code.size(arg1)
    call arg1.receiveApproval(address arg1, uint256 arg2, bytes arg3) with:
         gas gas_remaining - 710 wei
        args msg.sender, arg2, Array(len=arg3.length, data=arg3[all])
    require ext_call.success
}

function getOwners() {
    idx = 0
    while idx < stor1.length:
        require idx + 1 < 256
        require idx < stor1.length
        mem[(32 * idx) + 192] = owner[idx]
        idx = idx + 1
        continue 
    mem[(32 * stor1.length) + 192] = 32
    mem[(32 * stor1.length) + 224] = stor1.length
    s = 0
    while stor1.length < 32 * stor1.length:
        mem[(34 * stor1.length) + 256] = mem[stor1.length + 192]
        s = stor1.length + 32
        continue 
    return memory
      from (32 * stor1.length) + 192
       len (96 * stor1.length) + 64
}

function balanceOf(address arg1) {
    idx = 0
    s = stor262[address(arg1)]
    while idx < frozenCellCount[address(arg1)].field_0:
        require idx < frozenCellCount[address(arg1)].field_0
        _9 = sha3(sha3(address(arg1), 266))
        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
        mem[0] = arg1
        mem[32] = 266
        idx = idx + 1
        s = frozenCellCount[address(arg1)][idx].field_0 + s
        continue 
    return (stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _9] * frozenCellCount[address(arg1)].field_0))
}

function revoke(bytes32 arg1) {
    require stor259[arg1].field_0
    require stor258[address(msg.sender)] > 0
    require stor258[address(msg.sender)]
    require stor258[address(msg.sender)] <= 250
    require 2^stor258[address(msg.sender)] and stor259[arg1].field_256 > 0
    require stor259[arg1].field_0
    require stor259[arg1].field_512 < stor260.length
    require stor260[stor259[arg1].field_512] == arg1
    require stor259[arg1].field_0 <= m_multiOwnedRequired
    stor259[arg1].field_0++
    stor259[arg1].field_256 -= 2^stor258[address(msg.sender)]
    require stor259[arg1].field_0
    require stor259[arg1].field_512 < stor260.length
    require stor260[stor259[arg1].field_512] == arg1
    require stor259[arg1].field_0 <= m_multiOwnedRequired
    emit Revoke(msg.sender, arg1);
}

function availableBalanceOf(address arg1) {
    idx = 0
    while idx < frozenCellCount[address(arg1)].field_0:
        require idx < frozenCellCount[address(arg1)].field_0
        if uint128(frozenCellCount[address(arg1)][idx].field_256) <= block.timestamp:
            if frozenCellCount[address(arg1)][idx].field_0:
                if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                    require idx < frozenCellCount[address(arg1)].field_0
                    require frozenCellCount[address(arg1)][idx].field_0 + stor262[address(arg1)] >= stor262[address(arg1)]
                else:
                    mem[128] = 0
                    mem[100] = arg1
                    require ext_code.size(m_KYCProviderAddress)
                    call m_KYCProviderAddress.isKYCPassed(address arg1) with:
                         gas gas_remaining - 710 wei
                        args arg1
                    mem[96] = ext_call.return_data[0]
                    require ext_call.success
                    if ext_call.return_data[0]:
                        require idx < frozenCellCount[address(arg1)].field_0
                        require frozenCellCount[address(arg1)][idx].field_0 + stor262[address(arg1)] >= stor262[address(arg1)]
        mem[0] = arg1
        mem[32] = 266
        idx = idx + 1
        continue 
    return stor262[address(arg1)]
}

function disablePrivileged() {
    require m_allowPrivileged
    require stor258[address(msg.sender)] > 0
    if 512 == stor260.length:
        require stor258[address(msg.sender)] > 0
        idx = 0
        while idx < stor260.length:
            mem[0] = 260
            if stor260[idx]:
                require idx < stor260.length
                mem[0] = stor260[idx]
                mem[32] = 259
                stor259[stor260[idx]].field_0 = 0
                stor259[stor260[idx]].field_256 = 0
                stor259[stor260[idx]].field_512 = 0
            idx = idx + 1
            continue 
        stor260.length = 0
        idx = 0
        while stor260.length > idx:
            stor260[idx] = 0
            idx = idx + 1
            continue 
    if not stor259[call.data[0 len calldata.size]].field_0:
        stor259[call.data[0 len calldata.size]].field_0 = m_multiOwnedRequired
        stor259[call.data[0 len calldata.size]].field_256 = 0
        stor260.length++
        if not stor260.length <= stor260.length + 1:
            idx = stor260.length + 1
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
        stor259[call.data[0 len calldata.size]].field_512 = stor260.length
        require stor260.length < stor260.length
        stor260[stor260.length] = sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0
        require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
        require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
    require stor258[address(msg.sender)]
    require stor258[address(msg.sender)] <= 250
    if 0 == stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)]:
        require stor259[call.data[0 len calldata.size]].field_0 > 0
        if stor259[call.data[0 len calldata.size]].field_0 != 1:
            stor259[call.data[0 len calldata.size]].field_0--
            stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
            require stor259[call.data[0 len calldata.size]].field_0
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
            require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
            emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
        else:
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
            stor259[call.data[0 len calldata.size]].field_0 = 0
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor259[call.data[0 len calldata.size]].field_512 = 0
            emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            m_allowPrivileged = 0
}

function setKYCProvider(address arg1) {
    require arg1
    require m_allowPrivileged
    require stor258[address(msg.sender)] > 0
    if 512 == stor260.length:
        require stor258[address(msg.sender)] > 0
        idx = 0
        while idx < stor260.length:
            mem[0] = 260
            if stor260[idx]:
                require idx < stor260.length
                mem[0] = stor260[idx]
                mem[32] = 259
                stor259[stor260[idx]].field_0 = 0
                stor259[stor260[idx]].field_256 = 0
                stor259[stor260[idx]].field_512 = 0
            idx = idx + 1
            continue 
        stor260.length = 0
        idx = 0
        while stor260.length > idx:
            stor260[idx] = 0
            idx = idx + 1
            continue 
    if not stor259[call.data[0 len calldata.size]].field_0:
        stor259[call.data[0 len calldata.size]].field_0 = m_multiOwnedRequired
        stor259[call.data[0 len calldata.size]].field_256 = 0
        stor260.length++
        if not stor260.length <= stor260.length + 1:
            idx = stor260.length + 1
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
        stor259[call.data[0 len calldata.size]].field_512 = stor260.length
        require stor260.length < stor260.length
        stor260[stor260.length] = sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0
        require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
        require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
    require stor258[address(msg.sender)]
    require stor258[address(msg.sender)] <= 250
    if 0 == stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)]:
        require stor259[call.data[0 len calldata.size]].field_0 > 0
        if stor259[call.data[0 len calldata.size]].field_0 != 1:
            stor259[call.data[0 len calldata.size]].field_0--
            stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
            require stor259[call.data[0 len calldata.size]].field_0
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
            require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
            emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
        else:
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
            stor259[call.data[0 len calldata.size]].field_0 = 0
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor259[call.data[0 len calldata.size]].field_512 = 0
            emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            m_KYCProviderAddress = arg1
}

function setSale(address arg1, bool arg2) {
    require arg1
    require m_allowPrivileged
    require stor258[address(msg.sender)] > 0
    if 512 == stor260.length:
        require stor258[address(msg.sender)] > 0
        idx = 0
        while idx < stor260.length:
            mem[0] = 260
            if stor260[idx]:
                require idx < stor260.length
                mem[0] = stor260[idx]
                mem[32] = 259
                stor259[stor260[idx]].field_0 = 0
                stor259[stor260[idx]].field_256 = 0
                stor259[stor260[idx]].field_512 = 0
            idx = idx + 1
            continue 
        stor260.length = 0
        idx = 0
        while stor260.length > idx:
            stor260[idx] = 0
            idx = idx + 1
            continue 
    if not stor259[call.data[0 len calldata.size]].field_0:
        stor259[call.data[0 len calldata.size]].field_0 = m_multiOwnedRequired
        stor259[call.data[0 len calldata.size]].field_256 = 0
        stor260.length++
        if not stor260.length <= stor260.length + 1:
            idx = stor260.length + 1
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
        stor259[call.data[0 len calldata.size]].field_512 = stor260.length
        require stor260.length < stor260.length
        stor260[stor260.length] = sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0
        require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
        require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
    require stor258[address(msg.sender)]
    require stor258[address(msg.sender)] <= 250
    if 0 == stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)]:
        require stor259[call.data[0 len calldata.size]].field_0 > 0
        if stor259[call.data[0 len calldata.size]].field_0 != 1:
            stor259[call.data[0 len calldata.size]].field_0--
            stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
            require stor259[call.data[0 len calldata.size]].field_0
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
            require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
            emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
        else:
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
            stor259[call.data[0 len calldata.size]].field_0 = 0
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor259[call.data[0 len calldata.size]].field_512 = 0
            emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            stor265[address(arg1)] = uint8(arg2)
}

function changeRequirement(uint256 arg1) {
    require arg1 > 0
    require arg1 <= stor1.length
    require stor258[address(msg.sender)] > 0
    if 512 == stor260.length:
        require stor258[address(msg.sender)] > 0
        idx = 0
        while idx < stor260.length:
            mem[0] = 260
            if stor260[idx]:
                require idx < stor260.length
                mem[0] = stor260[idx]
                mem[32] = 259
                stor259[stor260[idx]].field_0 = 0
                stor259[stor260[idx]].field_256 = 0
                stor259[stor260[idx]].field_512 = 0
            idx = idx + 1
            continue 
        stor260.length = 0
        idx = 0
        while stor260.length > idx:
            stor260[idx] = 0
            idx = idx + 1
            continue 
    if not stor259[call.data[0 len calldata.size]].field_0:
        stor259[call.data[0 len calldata.size]].field_0 = m_multiOwnedRequired
        stor259[call.data[0 len calldata.size]].field_256 = 0
        stor260.length++
        if not stor260.length <= stor260.length + 1:
            idx = stor260.length + 1
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
        stor259[call.data[0 len calldata.size]].field_512 = stor260.length
        require stor260.length < stor260.length
        stor260[stor260.length] = sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0
        require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
        require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
    require stor258[address(msg.sender)]
    require stor258[address(msg.sender)] <= 250
    if 0 == stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)]:
        require stor259[call.data[0 len calldata.size]].field_0 > 0
        if stor259[call.data[0 len calldata.size]].field_0 != 1:
            stor259[call.data[0 len calldata.size]].field_0--
            stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
            require stor259[call.data[0 len calldata.size]].field_0
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
            require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
            emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
        else:
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
            stor259[call.data[0 len calldata.size]].field_0 = 0
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor259[call.data[0 len calldata.size]].field_512 = 0
            emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            m_multiOwnedRequired = arg1
            require stor258[address(msg.sender)] > 0
            idx = 0
            while idx < stor260.length:
                mem[0] = 260
                if stor260[idx]:
                    require idx < stor260.length
                    mem[0] = stor260[idx]
                    mem[32] = 259
                    stor259[stor260[idx]].field_0 = 0
                    stor259[stor260[idx]].field_256 = 0
                    stor259[stor260[idx]].field_512 = 0
                idx = idx + 1
                continue 
            stor260.length = 0
            idx = 0
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
            emit RequirementChanged(arg1);
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require 100 == calldata.size
    if stor262[address(arg1)] < arg3:
        idx = 0
        while idx < frozenCellCount[address(arg1)].field_0:
            require idx < frozenCellCount[address(arg1)].field_0
            if uint128(frozenCellCount[address(arg1)][idx].field_256) <= block.timestamp:
                if frozenCellCount[address(arg1)][idx].field_0:
                    if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                        require idx < frozenCellCount[address(arg1)].field_0
                        require frozenCellCount[address(arg1)][idx].field_0 + stor262[address(arg1)] >= stor262[address(arg1)]
                    else:
                        mem[128] = 0
                        mem[100] = arg1
                        require ext_code.size(m_KYCProviderAddress)
                        call m_KYCProviderAddress.isKYCPassed(address arg1) with:
                             gas gas_remaining - 710 wei
                            args arg1
                        mem[96] = ext_call.return_data[0]
                        require ext_call.success
                        if ext_call.return_data[0]:
                            require idx < frozenCellCount[address(arg1)].field_0
                            require frozenCellCount[address(arg1)][idx].field_0 + stor262[address(arg1)] >= stor262[address(arg1)]
            mem[0] = arg1
            mem[32] = 266
            idx = idx + 1
            continue 
        require stor262[address(arg1)] >= arg3
        idx = 0
        while idx < frozenCellCount[address(arg1)].field_0:
            require idx < frozenCellCount[address(arg1)].field_0
            if uint128(frozenCellCount[address(arg1)][idx].field_256) <= block.timestamp:
                if frozenCellCount[address(arg1)][idx].field_0:
                    if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                        require idx < frozenCellCount[address(arg1)].field_0
                        require idx < frozenCellCount[address(arg1)].field_0
                        frozenCellCount[address(arg1)][idx].field_0 = 0
                        require frozenCellCount[address(arg1)][idx].field_0 + stor262[address(arg1)] >= stor262[address(arg1)]
                        stor262[address(arg1)] += frozenCellCount[address(arg1)][idx].field_0
                    else:
                        mem[128] = 0
                        mem[100] = arg1
                        require ext_code.size(m_KYCProviderAddress)
                        call m_KYCProviderAddress.isKYCPassed(address arg1) with:
                             gas gas_remaining - 710 wei
                            args arg1
                        mem[96] = ext_call.return_data[0]
                        require ext_call.success
                        if ext_call.return_data[0]:
                            require idx < frozenCellCount[address(arg1)].field_0
                            require idx < frozenCellCount[address(arg1)].field_0
                            frozenCellCount[address(arg1)][idx].field_0 = 0
                            require frozenCellCount[address(arg1)][idx].field_0 + stor262[address(arg1)] >= stor262[address(arg1)]
                            stor262[address(arg1)] += frozenCellCount[address(arg1)][idx].field_0
            mem[0] = arg1
            mem[32] = 266
            idx = idx + 1
            continue 
        require stor262[address(arg1)] >= arg3
    require arg2
    require arg3 <= stor262[address(arg1)]
    require arg3 <= allowance[address(arg1)][address(msg.sender)]
    require arg3 <= stor262[address(arg1)]
    stor262[address(arg1)] -= arg3
    require arg3 + stor262[arg2] >= stor262[arg2]
    stor262[address(arg2)] = arg3 + stor262[arg2]
    require arg3 <= allowance[address(arg1)][address(msg.sender)]
    allowance[address(arg1)][address(msg.sender)] -= arg3
    emit Transfer(arg3, arg1, arg2);
    return 1
}

function transfer(address arg1, uint256 arg2) {
    require 68 == calldata.size
    if stor262[address(msg.sender)] < arg2:
        idx = 0
        while idx < frozenCellCount[address(msg.sender)].field_0:
            require idx < frozenCellCount[address(msg.sender)].field_0
            if uint128(frozenCellCount[address(msg.sender)][idx].field_256) <= block.timestamp:
                if frozenCellCount[address(msg.sender)][idx].field_0:
                    if not uint128(frozenCellCount[address(msg.sender)][idx].field_384):
                        require idx < frozenCellCount[address(msg.sender)].field_0
                        require frozenCellCount[address(msg.sender)][idx].field_0 + stor262[address(msg.sender)] >= stor262[address(msg.sender)]
                    else:
                        mem[128] = 0
                        mem[100] = msg.sender
                        require ext_code.size(m_KYCProviderAddress)
                        call m_KYCProviderAddress.isKYCPassed(address arg1) with:
                             gas gas_remaining - 710 wei
                            args msg.sender
                        mem[96] = ext_call.return_data[0]
                        require ext_call.success
                        if ext_call.return_data[0]:
                            require idx < frozenCellCount[address(msg.sender)].field_0
                            require frozenCellCount[address(msg.sender)][idx].field_0 + stor262[address(msg.sender)] >= stor262[address(msg.sender)]
            mem[0] = msg.sender
            mem[32] = 266
            idx = idx + 1
            continue 
        require stor262[address(msg.sender)] >= arg2
        idx = 0
        while idx < frozenCellCount[address(msg.sender)].field_0:
            require idx < frozenCellCount[address(msg.sender)].field_0
            if uint128(frozenCellCount[address(msg.sender)][idx].field_256) <= block.timestamp:
                if frozenCellCount[address(msg.sender)][idx].field_0:
                    if not uint128(frozenCellCount[address(msg.sender)][idx].field_384):
                        require idx < frozenCellCount[address(msg.sender)].field_0
                        require idx < frozenCellCount[address(msg.sender)].field_0
                        frozenCellCount[address(msg.sender)][idx].field_0 = 0
                        require frozenCellCount[address(msg.sender)][idx].field_0 + stor262[address(msg.sender)] >= stor262[address(msg.sender)]
                        stor262[address(msg.sender)] += frozenCellCount[address(msg.sender)][idx].field_0
                    else:
                        mem[128] = 0
                        mem[100] = msg.sender
                        require ext_code.size(m_KYCProviderAddress)
                        call m_KYCProviderAddress.isKYCPassed(address arg1) with:
                             gas gas_remaining - 710 wei
                            args msg.sender
                        mem[96] = ext_call.return_data[0]
                        require ext_call.success
                        if ext_call.return_data[0]:
                            require idx < frozenCellCount[address(msg.sender)].field_0
                            require idx < frozenCellCount[address(msg.sender)].field_0
                            frozenCellCount[address(msg.sender)][idx].field_0 = 0
                            require frozenCellCount[address(msg.sender)][idx].field_0 + stor262[address(msg.sender)] >= stor262[address(msg.sender)]
                            stor262[address(msg.sender)] += frozenCellCount[address(msg.sender)][idx].field_0
            mem[0] = msg.sender
            mem[32] = 266
            idx = idx + 1
            continue 
        require stor262[address(msg.sender)] >= arg2
    require arg1
    require arg2 <= stor262[address(msg.sender)]
    require arg2 <= stor262[address(msg.sender)]
    stor262[address(msg.sender)] -= arg2
    require arg2 + stor262[arg1] >= stor262[arg1]
    stor262[address(arg1)] = arg2 + stor262[arg1]
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function addOwner(address arg1) {
    require stor258[address(arg1)] <= 0
    require stor1.length + 1 > 0
    require stor1.length + 1 <= 250
    require stor258[address(msg.sender)] > 0
    if 512 == stor260.length:
        require stor258[address(msg.sender)] > 0
        idx = 0
        while idx < stor260.length:
            mem[0] = 260
            if stor260[idx]:
                require idx < stor260.length
                mem[0] = stor260[idx]
                mem[32] = 259
                stor259[stor260[idx]].field_0 = 0
                stor259[stor260[idx]].field_256 = 0
                stor259[stor260[idx]].field_512 = 0
            idx = idx + 1
            continue 
        stor260.length = 0
        idx = 0
        while stor260.length > idx:
            stor260[idx] = 0
            idx = idx + 1
            continue 
    if not stor259[call.data[0 len calldata.size]].field_0:
        stor259[call.data[0 len calldata.size]].field_0 = m_multiOwnedRequired
        stor259[call.data[0 len calldata.size]].field_256 = 0
        stor260.length++
        if not stor260.length <= stor260.length + 1:
            idx = stor260.length + 1
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
        stor259[call.data[0 len calldata.size]].field_512 = stor260.length
        require stor260.length < stor260.length
        stor260[stor260.length] = sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0
        require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
        require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
    require stor258[address(msg.sender)]
    require stor258[address(msg.sender)] <= 250
    if 0 == stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)]:
        require stor259[call.data[0 len calldata.size]].field_0 > 0
        if stor259[call.data[0 len calldata.size]].field_0 != 1:
            stor259[call.data[0 len calldata.size]].field_0--
            stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
            require stor259[call.data[0 len calldata.size]].field_0
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
            require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
            emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
        else:
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
            stor259[call.data[0 len calldata.size]].field_0 = 0
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor259[call.data[0 len calldata.size]].field_512 = 0
            emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            require stor1.length > 0
            require stor1.length <= 250
            require not stor2.length
            require m_multiOwnedRequired
            require m_multiOwnedRequired <= stor1.length
            require stor258[address(msg.sender)] > 0
            idx = 0
            while idx < stor260.length:
                mem[0] = 260
                if stor260[idx]:
                    require idx < stor260.length
                    mem[0] = stor260[idx]
                    mem[32] = 259
                    stor259[stor260[idx]].field_0 = 0
                    stor259[stor260[idx]].field_256 = 0
                    stor259[stor260[idx]].field_512 = 0
                idx = idx + 1
                continue 
            stor260.length = 0
            idx = 0
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
            stor1.length++
            require stor1.length + 1 < 256
            owner[stor1.length] = arg1
            require stor1.length
            require stor1.length <= 250
            stor258[address(arg1)] = stor1.length
            require stor1.length > 0
            require stor1.length <= 250
            require not stor2.length
            require m_multiOwnedRequired
            require m_multiOwnedRequired <= stor1.length
            emit OwnerAdded(arg1);
}

function changeOwner(address arg1, address arg2) {
    require stor258[address(arg1)] > 0
    require stor258[address(arg2)] <= 0
    require stor258[address(msg.sender)] > 0
    if 512 == stor260.length:
        require stor258[address(msg.sender)] > 0
        idx = 0
        while idx < stor260.length:
            mem[0] = 260
            if stor260[idx]:
                require idx < stor260.length
                mem[0] = stor260[idx]
                mem[32] = 259
                stor259[stor260[idx]].field_0 = 0
                stor259[stor260[idx]].field_256 = 0
                stor259[stor260[idx]].field_512 = 0
            idx = idx + 1
            continue 
        stor260.length = 0
        idx = 0
        while stor260.length > idx:
            stor260[idx] = 0
            idx = idx + 1
            continue 
    if not stor259[call.data[0 len calldata.size]].field_0:
        stor259[call.data[0 len calldata.size]].field_0 = m_multiOwnedRequired
        stor259[call.data[0 len calldata.size]].field_256 = 0
        stor260.length++
        if not stor260.length <= stor260.length + 1:
            idx = stor260.length + 1
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
        stor259[call.data[0 len calldata.size]].field_512 = stor260.length
        require stor260.length < stor260.length
        stor260[stor260.length] = sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0
        require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
        require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
        require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
    require stor258[address(msg.sender)]
    require stor258[address(msg.sender)] <= 250
    if 0 == stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)]:
        require stor259[call.data[0 len calldata.size]].field_0 > 0
        if stor259[call.data[0 len calldata.size]].field_0 != 1:
            stor259[call.data[0 len calldata.size]].field_0--
            stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
            require stor259[call.data[0 len calldata.size]].field_0
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
            require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
            emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
        else:
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
            stor259[call.data[0 len calldata.size]].field_0 = 0
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor259[call.data[0 len calldata.size]].field_512 = 0
            emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            require stor1.length > 0
            require stor1.length <= 250
            require not stor2.length
            require m_multiOwnedRequired
            require m_multiOwnedRequired <= stor1.length
            require stor258[address(msg.sender)] > 0
            idx = 0
            while idx < stor260.length:
                mem[0] = 260
                if stor260[idx]:
                    require idx < stor260.length
                    mem[0] = stor260[idx]
                    mem[32] = 259
                    stor259[stor260[idx]].field_0 = 0
                    stor259[stor260[idx]].field_256 = 0
                    stor259[stor260[idx]].field_512 = 0
                idx = idx + 1
                continue 
            stor260.length = 0
            idx = 0
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
            require stor258[address(arg1)]
            require stor258[address(arg1)] <= 250
            require stor258[address(arg1)] < 256
            stor2[stor258[address(arg1)]] = arg2
            stor258[address(arg1)] = 0
            stor258[arg2] = stor258[address(arg1)]
            require stor1.length > 0
            require stor1.length <= 250
            require not stor2.length
            require m_multiOwnedRequired
            require m_multiOwnedRequired <= stor1.length
            emit OwnerChanged(address(arg1), arg2);
}

function frozenTransferFrom(address arg1, address arg2, uint256 arg3, uint256 arg4, bool arg5) {
    require arg2
    require arg4 >= 1522046326
    require arg4 <= 500000 * 3600
    require 164 == calldata.size
    require m_allowPrivileged
    idx = 0
    s = stor262[address(arg2)]
    while idx < frozenCellCount[address(arg2)].field_0:
        require idx < frozenCellCount[address(arg2)].field_0
        _105 = sha3(sha3(address(arg2), 266))
        require frozenCellCount[address(arg2)][idx].field_0 + s >= s
        mem[0] = arg2
        mem[32] = 266
        idx = idx + 1
        s = frozenCellCount[address(arg2)][idx].field_0 + s
        continue 
    idx = 0
    s = stor262[address(arg1)]
    while idx < frozenCellCount[address(arg1)].field_0:
        require idx < frozenCellCount[address(arg1)].field_0
        _206 = sha3(sha3(address(arg1), 266))
        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
        mem[0] = arg1
        mem[32] = 266
        idx = idx + 1
        s = frozenCellCount[address(arg1)][idx].field_0 + s
        continue 
    if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _105] * frozenCellCount[address(arg2)].field_0) >= 0:
        require stor265[address(msg.sender)]
        require stor265[address(arg2)]
        require arg3 <= allowance[address(arg1)][address(msg.sender)]
        if arg3 <= allowance[address(arg1)][address(msg.sender)]:
            allowance[address(arg1)][address(msg.sender)] -= arg3
            require arg4 >= 1522046326
            require arg4 <= 500000 * 3600
            if arg5:
                s = 0
                idx = 0
                while idx < frozenCellCount[address(arg1)].field_0:
                    require idx < frozenCellCount[address(arg1)].field_0
                    if uint128(frozenCellCount[address(arg1)][idx].field_256) != uint128(arg4):
                        mem[0] = arg1
                        mem[32] = 266
                        s = (2 * idx) + sha3(sha3(address(arg1), 266))
                        idx = idx + 1
                        continue 
                    if uint128(frozenCellCount[address(arg1)][idx].field_384) != 1:
                        mem[0] = arg1
                        mem[32] = 266
                        s = (2 * idx) + sha3(sha3(address(arg1), 266))
                        idx = idx + 1
                        continue 
                    require idx <= frozenCellCount[address(arg1)].field_0
                    require idx != frozenCellCount[address(arg1)].field_0
                    require idx < frozenCellCount[address(arg1)].field_0
                    require frozenCellCount[address(arg1)][idx].field_0 >= arg3
                    require arg3 <= frozenCellCount[address(arg1)][idx].field_0
                    frozenCellCount[address(arg1)][idx].field_0 -= arg3
                    require arg3 + stor262[address(arg2)] >= stor262[address(arg2)]
                    stor262[address(arg2)] += arg3
                    emit Transfer(arg3, arg1, arg2);
                    idx = 0
                    s = stor262[address(arg2)]
                    while idx < frozenCellCount[address(arg2)].field_0:
                        require idx < frozenCellCount[address(arg2)].field_0
                        _396 = sha3(sha3(address(arg2), 266))
                        require frozenCellCount[address(arg2)][idx].field_0 + s >= s
                        mem[0] = arg2
                        mem[32] = 266
                        idx = idx + 1
                        s = frozenCellCount[address(arg2)][idx].field_0 + s
                        continue 
                    idx = 0
                    s = stor262[address(arg1)]
                    while idx < frozenCellCount[address(arg1)].field_0:
                        require idx < frozenCellCount[address(arg1)].field_0
                        _432 = sha3(sha3(address(arg1), 266))
                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                        mem[0] = arg1
                        mem[32] = 266
                        idx = idx + 1
                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                        continue 
                    if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _396] * frozenCellCount[address(arg2)].field_0) >= 0:
                        if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _396] * frozenCellCount[address(arg2)].field_0) + stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _432] * frozenCellCount[address(arg1)].field_0) == stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _105] * frozenCellCount[address(arg2)].field_0) + stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _206] * frozenCellCount[address(arg1)].field_0):
                            return 1
                    revert
                if idx <= frozenCellCount[address(arg1)].field_0:
                    require idx != frozenCellCount[address(arg1)].field_0
                    if idx < frozenCellCount[address(arg1)].field_0:
                        require frozenCellCount[address(arg1)][idx].field_0 >= arg3
                        if arg3 <= frozenCellCount[address(arg1)][idx].field_0:
                            frozenCellCount[address(arg1)][idx].field_0 -= arg3
                            if arg3 + stor262[address(arg2)] >= stor262[address(arg2)]:
                                stor262[address(arg2)] += arg3
                                emit Transfer(arg3, arg1, arg2);
                                idx = 0
                                s = stor262[address(arg2)]
                                while idx < frozenCellCount[address(arg2)].field_0:
                                    require idx < frozenCellCount[address(arg2)].field_0
                                    _395 = sha3(sha3(address(arg2), 266))
                                    require frozenCellCount[address(arg2)][idx].field_0 + s >= s
                                    mem[0] = arg2
                                    mem[32] = 266
                                    idx = idx + 1
                                    s = frozenCellCount[address(arg2)][idx].field_0 + s
                                    continue 
                                idx = 0
                                s = stor262[address(arg1)]
                                while idx < frozenCellCount[address(arg1)].field_0:
                                    require idx < frozenCellCount[address(arg1)].field_0
                                    _431 = sha3(sha3(address(arg1), 266))
                                    require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                    mem[0] = arg1
                                    mem[32] = 266
                                    idx = idx + 1
                                    s = frozenCellCount[address(arg1)][idx].field_0 + s
                                    continue 
                                if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _395] * frozenCellCount[address(arg2)].field_0) >= 0:
                                    if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _395] * frozenCellCount[address(arg2)].field_0) + stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _431] * frozenCellCount[address(arg1)].field_0) == stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _105] * frozenCellCount[address(arg2)].field_0) + stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _206] * frozenCellCount[address(arg1)].field_0):
                                        return 1
            else:
                s = 0
                idx = 0
                while idx < frozenCellCount[address(arg1)].field_0:
                    require idx < frozenCellCount[address(arg1)].field_0
                    if uint128(frozenCellCount[address(arg1)][idx].field_256) != uint128(arg4):
                        mem[0] = arg1
                        mem[32] = 266
                        s = (2 * idx) + sha3(sha3(address(arg1), 266))
                        idx = idx + 1
                        continue 
                    if uint128(frozenCellCount[address(arg1)][idx].field_384):
                        mem[0] = arg1
                        mem[32] = 266
                        s = (2 * idx) + sha3(sha3(address(arg1), 266))
                        idx = idx + 1
                        continue 
                    require idx <= frozenCellCount[address(arg1)].field_0
                    require idx != frozenCellCount[address(arg1)].field_0
                    require idx < frozenCellCount[address(arg1)].field_0
                    require frozenCellCount[address(arg1)][idx].field_0 >= arg3
                    require arg3 <= frozenCellCount[address(arg1)][idx].field_0
                    frozenCellCount[address(arg1)][idx].field_0 -= arg3
                    require arg3 + stor262[address(arg2)] >= stor262[address(arg2)]
                    stor262[address(arg2)] += arg3
                    emit Transfer(arg3, arg1, arg2);
                    idx = 0
                    s = stor262[address(arg2)]
                    while idx < frozenCellCount[address(arg2)].field_0:
                        require idx < frozenCellCount[address(arg2)].field_0
                        _398 = sha3(sha3(address(arg2), 266))
                        require frozenCellCount[address(arg2)][idx].field_0 + s >= s
                        mem[0] = arg2
                        mem[32] = 266
                        idx = idx + 1
                        s = frozenCellCount[address(arg2)][idx].field_0 + s
                        continue 
                    idx = 0
                    s = stor262[address(arg1)]
                    while idx < frozenCellCount[address(arg1)].field_0:
                        require idx < frozenCellCount[address(arg1)].field_0
                        _434 = sha3(sha3(address(arg1), 266))
                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                        mem[0] = arg1
                        mem[32] = 266
                        idx = idx + 1
                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                        continue 
                    if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _398] * frozenCellCount[address(arg2)].field_0) >= 0:
                        if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _398] * frozenCellCount[address(arg2)].field_0) + stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _434] * frozenCellCount[address(arg1)].field_0) == stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _105] * frozenCellCount[address(arg2)].field_0) + stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _206] * frozenCellCount[address(arg1)].field_0):
                            return 1
                    revert
                if idx <= frozenCellCount[address(arg1)].field_0:
                    require idx != frozenCellCount[address(arg1)].field_0
                    if idx < frozenCellCount[address(arg1)].field_0:
                        require frozenCellCount[address(arg1)][idx].field_0 >= arg3
                        if arg3 <= frozenCellCount[address(arg1)][idx].field_0:
                            frozenCellCount[address(arg1)][idx].field_0 -= arg3
                            if arg3 + stor262[address(arg2)] >= stor262[address(arg2)]:
                                stor262[address(arg2)] += arg3
                                emit Transfer(arg3, arg1, arg2);
                                idx = 0
                                s = stor262[address(arg2)]
                                while idx < frozenCellCount[address(arg2)].field_0:
                                    require idx < frozenCellCount[address(arg2)].field_0
                                    _397 = sha3(sha3(address(arg2), 266))
                                    require frozenCellCount[address(arg2)][idx].field_0 + s >= s
                                    mem[0] = arg2
                                    mem[32] = 266
                                    idx = idx + 1
                                    s = frozenCellCount[address(arg2)][idx].field_0 + s
                                    continue 
                                idx = 0
                                s = stor262[address(arg1)]
                                while idx < frozenCellCount[address(arg1)].field_0:
                                    require idx < frozenCellCount[address(arg1)].field_0
                                    _433 = sha3(sha3(address(arg1), 266))
                                    require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                    mem[0] = arg1
                                    mem[32] = 266
                                    idx = idx + 1
                                    s = frozenCellCount[address(arg1)][idx].field_0 + s
                                    continue 
                                if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _397] * frozenCellCount[address(arg2)].field_0) >= 0:
                                    if stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _397] * frozenCellCount[address(arg2)].field_0) + stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _433] * frozenCellCount[address(arg1)].field_0) == stor262[address(arg2)] + (stor[(2 * stor266[address(arg2)].field_0) + _105] * frozenCellCount[address(arg2)].field_0) + stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _206] * frozenCellCount[address(arg1)].field_0):
                                        return 1
    revert
}

function removeOwner(address arg1) {
    require stor258[address(arg1)] > 0
    require stor1.length - 1 > 0
    require stor1.length - 1 <= 250
    require m_multiOwnedRequired > 0
    require m_multiOwnedRequired <= stor1.length - 1
    require stor258[address(msg.sender)] > 0
    if stor260.length != 512:
        if stor259[call.data[0 len calldata.size]].field_0:
            require stor258[address(msg.sender)]
            require stor258[address(msg.sender)] <= 250
            if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)] != 0:
            require stor259[call.data[0 len calldata.size]].field_0 > 0
            if stor259[call.data[0 len calldata.size]].field_0 != 1:
                stor259[call.data[0 len calldata.size]].field_0--
                stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
                require stor259[call.data[0 len calldata.size]].field_0
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
            stor259[call.data[0 len calldata.size]].field_0 = 0
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor259[call.data[0 len calldata.size]].field_512 = 0
            emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            require stor1.length > 0
            require stor1.length <= 250
            require not stor2.length
            require m_multiOwnedRequired
            require m_multiOwnedRequired <= stor1.length
            require stor258[address(msg.sender)] > 0
            idx = 0
            while idx < stor260.length:
                mem[0] = 260
                if stor260[idx]:
                    require idx < stor260.length
                    mem[0] = stor260[idx]
                    mem[32] = 259
                    stor259[stor260[idx]].field_0 = 0
                    stor259[stor260[idx]].field_256 = 0
                    stor259[stor260[idx]].field_512 = 0
                idx = idx + 1
                continue 
            stor260.length = 0
            idx = 0
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
            require stor258[address(arg1)]
            require stor258[address(arg1)] <= 250
            require stor258[address(arg1)] < 256
            stor2[stor258[address(arg1)]] = 0
            stor258[address(arg1)] = 0
            # nil
        else:
            stor259[call.data[0 len calldata.size]].field_0 = m_multiOwnedRequired
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor260.length++
            if not stor260.length > stor260.length + 1:
                stor259[call.data[0 len calldata.size]].field_512 = stor260.length
                require stor260.length < stor260.length
                stor260[stor260.length] = sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                require stor258[address(msg.sender)]
                require stor258[address(msg.sender)] <= 250
                if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)] != 0:
                require stor259[call.data[0 len calldata.size]].field_0 > 0
                if stor259[call.data[0 len calldata.size]].field_0 != 1:
                    stor259[call.data[0 len calldata.size]].field_0--
                    stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
                    require stor259[call.data[0 len calldata.size]].field_0
                    require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                    require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                    require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                    emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
                stor259[call.data[0 len calldata.size]].field_0 = 0
                stor259[call.data[0 len calldata.size]].field_256 = 0
                stor259[call.data[0 len calldata.size]].field_512 = 0
                emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
                require stor1.length > 0
                require stor1.length <= 250
                require not stor2.length
                require m_multiOwnedRequired
                require m_multiOwnedRequired <= stor1.length
                require stor258[address(msg.sender)] > 0
                idx = 0
                while idx < stor260.length:
                    mem[0] = 260
                    if stor260[idx]:
                        require idx < stor260.length
                        mem[0] = stor260[idx]
                        mem[32] = 259
                        stor259[stor260[idx]].field_0 = 0
                        stor259[stor260[idx]].field_256 = 0
                        stor259[stor260[idx]].field_512 = 0
                    idx = idx + 1
                    continue 
                stor260.length = 0
                idx = 0
                while stor260.length > idx:
                    stor260[idx] = 0
                    idx = idx + 1
                    continue 
                require stor258[address(arg1)]
                require stor258[address(arg1)] <= 250
                require stor258[address(arg1)] < 256
                stor2[stor258[address(arg1)]] = 0
                stor258[address(arg1)] = 0
                # nil
            else:
                idx = stor260.length + 1
                while stor260.length > idx:
                    stor260[idx] = 0
                    idx = idx + 1
                    continue 
                stor259[call.data[0 len calldata.size]].field_512 = stor260.length
                require stor260.length < stor260.length
                stor260[stor260.length] = sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                require stor258[address(msg.sender)]
                require stor258[address(msg.sender)] <= 250
                if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)] != 0:
                require stor259[call.data[0 len calldata.size]].field_0 > 0
                if stor259[call.data[0 len calldata.size]].field_0 != 1:
                    stor259[call.data[0 len calldata.size]].field_0--
                    stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
                    require stor259[call.data[0 len calldata.size]].field_0
                    require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                    require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                    require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                    emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
                stor259[call.data[0 len calldata.size]].field_0 = 0
                stor259[call.data[0 len calldata.size]].field_256 = 0
                stor259[call.data[0 len calldata.size]].field_512 = 0
                emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
                require stor1.length > 0
                require stor1.length <= 250
                require not stor2.length
                require m_multiOwnedRequired
                require m_multiOwnedRequired <= stor1.length
                require stor258[address(msg.sender)] > 0
                idx = 0
                while idx < stor260.length:
                    mem[0] = 260
                    if stor260[idx]:
                        require idx < stor260.length
                        mem[0] = stor260[idx]
                        mem[32] = 259
                        stor259[stor260[idx]].field_0 = 0
                        stor259[stor260[idx]].field_256 = 0
                        stor259[stor260[idx]].field_512 = 0
                    idx = idx + 1
                    continue 
                stor260.length = 0
                idx = 0
                while stor260.length > idx:
                    stor260[idx] = 0
                    idx = idx + 1
                    continue 
                require stor258[address(arg1)]
                require stor258[address(arg1)] <= 250
                require stor258[address(arg1)] < 256
                stor2[stor258[address(arg1)]] = 0
                stor258[address(arg1)] = 0
                if 1 < stor1.length:
                    # nil
                else:
                    require stor1.length > 0
                    require stor1.length <= 250
                    require not stor2.length
                    require m_multiOwnedRequired
                    require m_multiOwnedRequired <= stor1.length
                    emit OwnerRemoved(arg1);
    else:
        require stor258[address(msg.sender)] > 0
        idx = 0
        while idx < stor260.length:
            mem[0] = 260
            if stor260[idx]:
                require idx < stor260.length
                mem[0] = stor260[idx]
                mem[32] = 259
                stor259[stor260[idx]].field_0 = 0
                stor259[stor260[idx]].field_256 = 0
                stor259[stor260[idx]].field_512 = 0
            idx = idx + 1
            continue 
        stor260.length = 0
        idx = 0
        while stor260.length > idx:
            stor260[idx] = 0
            idx = idx + 1
            continue 
        if stor259[call.data[0 len calldata.size]].field_0:
            require stor258[address(msg.sender)]
            require stor258[address(msg.sender)] <= 250
            if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)] != 0:
            require stor259[call.data[0 len calldata.size]].field_0 > 0
            if stor259[call.data[0 len calldata.size]].field_0 != 1:
                stor259[call.data[0 len calldata.size]].field_0--
                stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
                require stor259[call.data[0 len calldata.size]].field_0
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
            stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
            stor259[call.data[0 len calldata.size]].field_0 = 0
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor259[call.data[0 len calldata.size]].field_512 = 0
            emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
            require stor1.length > 0
            require stor1.length <= 250
            require not stor2.length
            require m_multiOwnedRequired
            require m_multiOwnedRequired <= stor1.length
            require stor258[address(msg.sender)] > 0
            idx = 0
            while idx < stor260.length:
                mem[0] = 260
                if stor260[idx]:
                    require idx < stor260.length
                    mem[0] = stor260[idx]
                    mem[32] = 259
                    stor259[stor260[idx]].field_0 = 0
                    stor259[stor260[idx]].field_256 = 0
                    stor259[stor260[idx]].field_512 = 0
                idx = idx + 1
                continue 
            stor260.length = 0
            idx = 0
            while stor260.length > idx:
                stor260[idx] = 0
                idx = idx + 1
                continue 
            require stor258[address(arg1)]
            require stor258[address(arg1)] <= 250
            require stor258[address(arg1)] < 256
            stor2[stor258[address(arg1)]] = 0
            stor258[address(arg1)] = 0
            # nil
        else:
            stor259[call.data[0 len calldata.size]].field_0 = m_multiOwnedRequired
            stor259[call.data[0 len calldata.size]].field_256 = 0
            stor260.length++
            if not stor260.length > stor260.length + 1:
                stor259[call.data[0 len calldata.size]].field_512 = stor260.length
                require stor260.length < stor260.length
                stor260[stor260.length] = sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                require stor258[address(msg.sender)]
                require stor258[address(msg.sender)] <= 250
                if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)] != 0:
                require stor259[call.data[0 len calldata.size]].field_0 > 0
                if stor259[call.data[0 len calldata.size]].field_0 != 1:
                    stor259[call.data[0 len calldata.size]].field_0--
                    stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
                    require stor259[call.data[0 len calldata.size]].field_0
                    require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                    require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                    require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                    emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
                stor259[call.data[0 len calldata.size]].field_0 = 0
                stor259[call.data[0 len calldata.size]].field_256 = 0
                stor259[call.data[0 len calldata.size]].field_512 = 0
                emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
                require stor1.length > 0
                require stor1.length <= 250
                require not stor2.length
                require m_multiOwnedRequired
                require m_multiOwnedRequired <= stor1.length
                require stor258[address(msg.sender)] > 0
                idx = 0
                while idx < stor260.length:
                    mem[0] = 260
                    if stor260[idx]:
                        require idx < stor260.length
                        mem[0] = stor260[idx]
                        mem[32] = 259
                        stor259[stor260[idx]].field_0 = 0
                        stor259[stor260[idx]].field_256 = 0
                        stor259[stor260[idx]].field_512 = 0
                    idx = idx + 1
                    continue 
                stor260.length = 0
                idx = 0
                while stor260.length > idx:
                    stor260[idx] = 0
                    idx = idx + 1
                    continue 
                require stor258[address(arg1)]
                require stor258[address(arg1)] <= 250
                require stor258[address(arg1)] < 256
                stor2[stor258[address(arg1)]] = 0
                stor258[address(arg1)] = 0
                # nil
            else:
                idx = stor260.length + 1
                while stor260.length > idx:
                    stor260[idx] = 0
                    idx = idx + 1
                    continue 
                stor259[call.data[0 len calldata.size]].field_512 = stor260.length
                require stor260.length < stor260.length
                stor260[stor260.length] = sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                require stor258[address(msg.sender)]
                require stor258[address(msg.sender)] <= 250
                if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[address(msg.sender)] != 0:
                require stor259[call.data[0 len calldata.size]].field_0 > 0
                if stor259[call.data[0 len calldata.size]].field_0 != 1:
                    stor259[call.data[0 len calldata.size]].field_0--
                    stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[address(msg.sender)] or stor259[call.data[0 len calldata.size]].field_256
                    require stor259[call.data[0 len calldata.size]].field_0
                    require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                    require stor260[stor259[call.data[0 len calldata.size]].field_512] == sha3(call.data[0 len calldata.size])
                    require stor259[call.data[0 len calldata.size]].field_0 <= m_multiOwnedRequired
                    emit Confirmation(msg.sender, sha3(call.data[0 len calldata.size]));
                require stor259[call.data[0 len calldata.size]].field_512 < stor260.length
                stor260[stor259[call.data[0 len calldata.size]].field_512] = 0
                stor259[call.data[0 len calldata.size]].field_0 = 0
                stor259[call.data[0 len calldata.size]].field_256 = 0
                stor259[call.data[0 len calldata.size]].field_512 = 0
                emit FinalConfirmation(msg.sender, sha3(call.data[0 len calldata.size]));
                require stor1.length > 0
                require stor1.length <= 250
                require not stor2.length
                require m_multiOwnedRequired
                require m_multiOwnedRequired <= stor1.length
                require stor258[address(msg.sender)] > 0
                idx = 0
                while idx < stor260.length:
                    mem[0] = 260
                    if stor260[idx]:
                        require idx < stor260.length
                        mem[0] = stor260[idx]
                        mem[32] = 259
                        stor259[stor260[idx]].field_0 = 0
                        stor259[stor260[idx]].field_256 = 0
                        stor259[stor260[idx]].field_512 = 0
                    idx = idx + 1
                    continue 
                stor260.length = 0
                idx = 0
                while stor260.length > idx:
                    stor260[idx] = 0
                    idx = idx + 1
                    continue 
                require stor258[address(arg1)]
                require stor258[address(arg1)] <= 250
                require stor258[address(arg1)] < 256
                stor2[stor258[address(arg1)]] = 0
                stor258[address(arg1)] = 0
                if 1 < stor1.length:
                    # nil
                else:
                    require stor1.length > 0
                    require stor1.length <= 250
                    require not stor2.length
                    require m_multiOwnedRequired
                    require m_multiOwnedRequired <= stor1.length
                    emit OwnerRemoved(arg1);
}

function frozenTransfer(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require arg1
    require arg3 >= 1522046326
    require arg3 <= 500000 * 3600
    require 132 == calldata.size
    require m_allowPrivileged
    require stor265[address(msg.sender)]
    idx = 0
    s = stor262[address(arg1)]
    while idx < frozenCellCount[address(arg1)].field_0:
        require idx < frozenCellCount[address(arg1)].field_0
        _245 = sha3(sha3(address(arg1), 266))
        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
        mem[0] = arg1
        mem[32] = 266
        idx = idx + 1
        s = frozenCellCount[address(arg1)][idx].field_0 + s
        continue 
    idx = 0
    s = stor262[address(msg.sender)]
    while idx < frozenCellCount[address(msg.sender)].field_0:
        require idx < frozenCellCount[address(msg.sender)].field_0
        _485 = sha3(sha3(address(msg.sender), 266))
        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
        mem[0] = msg.sender
        mem[32] = 266
        idx = idx + 1
        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
        continue 
    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) >= 0:
        require arg2 <= stor262[address(msg.sender)]
        if arg2 <= stor262[address(msg.sender)]:
            stor262[address(msg.sender)] -= arg2
            require arg1
            require arg3 >= 1522046326
            require arg3 <= 500000 * 3600
            mem[0] = arg1
            if not arg4:
                s = 0
                idx = 0
                while idx < frozenCellCount[address(arg1)].field_0:
                    require idx < frozenCellCount[address(arg1)].field_0
                    if uint128(frozenCellCount[address(arg1)][idx].field_256) != uint128(arg3):
                        mem[0] = arg1
                        mem[32] = 266
                        s = (2 * idx) + sha3(sha3(address(arg1), 266))
                        idx = idx + 1
                        continue 
                    if uint128(frozenCellCount[address(arg1)][idx].field_384):
                        mem[0] = arg1
                        mem[32] = 266
                        s = (2 * idx) + sha3(sha3(address(arg1), 266))
                        idx = idx + 1
                        continue 
                    require idx <= frozenCellCount[address(arg1)].field_0
                    if idx != frozenCellCount[address(arg1)].field_0:
                        if idx < frozenCellCount[address(arg1)].field_0:
                            if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                                    if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                        frozenCellCount[address(arg1)][idx].field_0 += arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                        idx = 0
                                        s = stor262[address(arg1)]
                                        while idx < frozenCellCount[address(arg1)].field_0:
                                            require idx < frozenCellCount[address(arg1)].field_0
                                            _971 = sha3(sha3(address(arg1), 266))
                                            require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                            mem[0] = arg1
                                            mem[32] = 266
                                            idx = idx + 1
                                            s = frozenCellCount[address(arg1)][idx].field_0 + s
                                            continue 
                                        idx = 0
                                        s = stor262[address(msg.sender)]
                                        while idx < frozenCellCount[address(msg.sender)].field_0:
                                            require idx < frozenCellCount[address(msg.sender)].field_0
                                            _1126 = sha3(sha3(address(msg.sender), 266))
                                            require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                            mem[0] = msg.sender
                                            mem[32] = 266
                                            idx = idx + 1
                                            s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                            continue 
                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _971] * frozenCellCount[address(arg1)].field_0) >= 0:
                                            if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _971] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1126] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                return 1
                    else:
                        frozenCellCount[address(arg1)].field_0++
                        if not frozenCellCount[address(arg1)].field_0 > frozenCellCount[address(arg1)].field_0 + 1:
                            if idx < frozenCellCount[address(arg1)].field_0:
                                if not frozenCellCount[address(arg1)][idx].field_0:
                                    uint128(frozenCellCount[address(arg1)][idx].field_256) = uint128(arg3)
                                    uint128(frozenCellCount[address(arg1)][idx].field_384) = 0
                                    if idx < frozenCellCount[address(arg1)].field_0:
                                        if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                            if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                                                if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                                    frozenCellCount[address(arg1)][idx].field_0 += arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    idx = 0
                                                    s = stor262[address(arg1)]
                                                    while idx < frozenCellCount[address(arg1)].field_0:
                                                        require idx < frozenCellCount[address(arg1)].field_0
                                                        _972 = sha3(sha3(address(arg1), 266))
                                                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                                        mem[0] = arg1
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                                                        continue 
                                                    idx = 0
                                                    s = stor262[address(msg.sender)]
                                                    while idx < frozenCellCount[address(msg.sender)].field_0:
                                                        require idx < frozenCellCount[address(msg.sender)].field_0
                                                        _1127 = sha3(sha3(address(msg.sender), 266))
                                                        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                                        mem[0] = msg.sender
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                                        continue 
                                                    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _972] * frozenCellCount[address(arg1)].field_0) >= 0:
                                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _972] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1127] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                            return 1
                        else:
                            mem[0] = sha3(address(arg1), 266)
                            s = sha3(mem[0]) + (2 * frozenCellCount[address(arg1)].field_0 + 1)
                            while sha3(sha3(address(arg1), 266)) + (2 * frozenCellCount[address(arg1)].field_0) > s:
                                stor[s] = 0
                                stor1[s] = 0
                                mem[0] = arg1
                                mem[32] = 266
                                s = s + 2
                                continue 
                            if idx < frozenCellCount[address(arg1)].field_0:
                                if not frozenCellCount[address(arg1)][idx].field_0:
                                    uint128(frozenCellCount[address(arg1)][idx].field_256) = uint128(arg3)
                                    uint128(frozenCellCount[address(arg1)][idx].field_384) = 0
                                    if idx < frozenCellCount[address(arg1)].field_0:
                                        if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                            if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                                                if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                                    frozenCellCount[address(arg1)][idx].field_0 += arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    idx = 0
                                                    s = stor262[address(arg1)]
                                                    while idx < frozenCellCount[address(arg1)].field_0:
                                                        require idx < frozenCellCount[address(arg1)].field_0
                                                        _1128 = sha3(sha3(address(arg1), 266))
                                                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                                        mem[0] = arg1
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                                                        continue 
                                                    idx = 0
                                                    s = stor262[address(msg.sender)]
                                                    while idx < frozenCellCount[address(msg.sender)].field_0:
                                                        require idx < frozenCellCount[address(msg.sender)].field_0
                                                        _1180 = sha3(sha3(address(msg.sender), 266))
                                                        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                                        mem[0] = msg.sender
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                                        continue 
                                                    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _1128] * frozenCellCount[address(arg1)].field_0) >= 0:
                                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _1128] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1180] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                            return 1
                    revert
                if idx <= frozenCellCount[address(arg1)].field_0:
                    if idx != frozenCellCount[address(arg1)].field_0:
                        if idx < frozenCellCount[address(arg1)].field_0:
                            if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                                    if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                        frozenCellCount[address(arg1)][idx].field_0 += arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                        idx = 0
                                        s = stor262[address(arg1)]
                                        while idx < frozenCellCount[address(arg1)].field_0:
                                            require idx < frozenCellCount[address(arg1)].field_0
                                            _969 = sha3(sha3(address(arg1), 266))
                                            require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                            mem[0] = arg1
                                            mem[32] = 266
                                            idx = idx + 1
                                            s = frozenCellCount[address(arg1)][idx].field_0 + s
                                            continue 
                                        idx = 0
                                        s = stor262[address(msg.sender)]
                                        while idx < frozenCellCount[address(msg.sender)].field_0:
                                            require idx < frozenCellCount[address(msg.sender)].field_0
                                            _1123 = sha3(sha3(address(msg.sender), 266))
                                            require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                            mem[0] = msg.sender
                                            mem[32] = 266
                                            idx = idx + 1
                                            s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                            continue 
                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _969] * frozenCellCount[address(arg1)].field_0) >= 0:
                                            if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _969] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1123] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                return 1
                    else:
                        frozenCellCount[address(arg1)].field_0++
                        if not frozenCellCount[address(arg1)].field_0 > frozenCellCount[address(arg1)].field_0 + 1:
                            if idx < frozenCellCount[address(arg1)].field_0:
                                if not frozenCellCount[address(arg1)][idx].field_0:
                                    uint128(frozenCellCount[address(arg1)][idx].field_256) = uint128(arg3)
                                    uint128(frozenCellCount[address(arg1)][idx].field_384) = 0
                                    if idx < frozenCellCount[address(arg1)].field_0:
                                        if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                            if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                                                if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                                    frozenCellCount[address(arg1)][idx].field_0 += arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    idx = 0
                                                    s = stor262[address(arg1)]
                                                    while idx < frozenCellCount[address(arg1)].field_0:
                                                        require idx < frozenCellCount[address(arg1)].field_0
                                                        _970 = sha3(sha3(address(arg1), 266))
                                                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                                        mem[0] = arg1
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                                                        continue 
                                                    idx = 0
                                                    s = stor262[address(msg.sender)]
                                                    while idx < frozenCellCount[address(msg.sender)].field_0:
                                                        require idx < frozenCellCount[address(msg.sender)].field_0
                                                        _1124 = sha3(sha3(address(msg.sender), 266))
                                                        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                                        mem[0] = msg.sender
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                                        continue 
                                                    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _970] * frozenCellCount[address(arg1)].field_0) >= 0:
                                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _970] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1124] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                            return 1
                        else:
                            s = 2 * frozenCellCount[address(arg1)].field_0 + 1
                            while 2 * frozenCellCount[address(arg1)].field_0 > s:
                                frozenCellCount[address(arg1)][s].field_0 = 0
                                frozenCellCount[address(arg1)][s].field_256 = 0
                                s = s + 2
                                continue 
                            if idx < frozenCellCount[address(arg1)].field_0:
                                if not frozenCellCount[address(arg1)][idx].field_0:
                                    uint128(frozenCellCount[address(arg1)][idx].field_256) = uint128(arg3)
                                    uint128(frozenCellCount[address(arg1)][idx].field_384) = 0
                                    if idx < frozenCellCount[address(arg1)].field_0:
                                        if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                            if not uint128(frozenCellCount[address(arg1)][idx].field_384):
                                                if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                                    frozenCellCount[address(arg1)][idx].field_0 += arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    idx = 0
                                                    s = stor262[address(arg1)]
                                                    while idx < frozenCellCount[address(arg1)].field_0:
                                                        require idx < frozenCellCount[address(arg1)].field_0
                                                        _1125 = sha3(sha3(address(arg1), 266))
                                                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                                        mem[0] = arg1
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                                                        continue 
                                                    idx = 0
                                                    s = stor262[address(msg.sender)]
                                                    while idx < frozenCellCount[address(msg.sender)].field_0:
                                                        require idx < frozenCellCount[address(msg.sender)].field_0
                                                        _1179 = sha3(sha3(address(msg.sender), 266))
                                                        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                                        mem[0] = msg.sender
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                                        continue 
                                                    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _1125] * frozenCellCount[address(arg1)].field_0) >= 0:
                                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _1125] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1179] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                            return 1
            else:
                s = 0
                idx = 0
                while idx < frozenCellCount[address(arg1)].field_0:
                    require idx < frozenCellCount[address(arg1)].field_0
                    if uint128(frozenCellCount[address(arg1)][idx].field_256) != uint128(arg3):
                        mem[0] = arg1
                        mem[32] = 266
                        s = (2 * idx) + sha3(sha3(address(arg1), 266))
                        idx = idx + 1
                        continue 
                    if uint128(frozenCellCount[address(arg1)][idx].field_384) != 1:
                        mem[0] = arg1
                        mem[32] = 266
                        s = (2 * idx) + sha3(sha3(address(arg1), 266))
                        idx = idx + 1
                        continue 
                    require idx <= frozenCellCount[address(arg1)].field_0
                    if idx != frozenCellCount[address(arg1)].field_0:
                        if idx < frozenCellCount[address(arg1)].field_0:
                            if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                if uint128(frozenCellCount[address(arg1)][idx].field_384) == 1:
                                    if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                        frozenCellCount[address(arg1)][idx].field_0 += arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                        idx = 0
                                        s = stor262[address(arg1)]
                                        while idx < frozenCellCount[address(arg1)].field_0:
                                            require idx < frozenCellCount[address(arg1)].field_0
                                            _967 = sha3(sha3(address(arg1), 266))
                                            require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                            mem[0] = arg1
                                            mem[32] = 266
                                            idx = idx + 1
                                            s = frozenCellCount[address(arg1)][idx].field_0 + s
                                            continue 
                                        idx = 0
                                        s = stor262[address(msg.sender)]
                                        while idx < frozenCellCount[address(msg.sender)].field_0:
                                            require idx < frozenCellCount[address(msg.sender)].field_0
                                            _1120 = sha3(sha3(address(msg.sender), 266))
                                            require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                            mem[0] = msg.sender
                                            mem[32] = 266
                                            idx = idx + 1
                                            s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                            continue 
                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _967] * frozenCellCount[address(arg1)].field_0) >= 0:
                                            if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _967] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1120] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                return 1
                    else:
                        frozenCellCount[address(arg1)].field_0++
                        if not frozenCellCount[address(arg1)].field_0 > frozenCellCount[address(arg1)].field_0 + 1:
                            if idx < frozenCellCount[address(arg1)].field_0:
                                if not frozenCellCount[address(arg1)][idx].field_0:
                                    uint128(frozenCellCount[address(arg1)][idx].field_256) = uint128(arg3)
                                    uint8(frozenCellCount[address(arg1)][idx].field_384) = 1
                                    Mask(120, 0, frozenCellCount[address(arg1)][idx].field_392) = 0
                                    if idx < frozenCellCount[address(arg1)].field_0:
                                        if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                            if uint128(frozenCellCount[address(arg1)][idx].field_384) == 1:
                                                if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                                    frozenCellCount[address(arg1)][idx].field_0 += arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    idx = 0
                                                    s = stor262[address(arg1)]
                                                    while idx < frozenCellCount[address(arg1)].field_0:
                                                        require idx < frozenCellCount[address(arg1)].field_0
                                                        _968 = sha3(sha3(address(arg1), 266))
                                                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                                        mem[0] = arg1
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                                                        continue 
                                                    idx = 0
                                                    s = stor262[address(msg.sender)]
                                                    while idx < frozenCellCount[address(msg.sender)].field_0:
                                                        require idx < frozenCellCount[address(msg.sender)].field_0
                                                        _1121 = sha3(sha3(address(msg.sender), 266))
                                                        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                                        mem[0] = msg.sender
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                                        continue 
                                                    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _968] * frozenCellCount[address(arg1)].field_0) >= 0:
                                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _968] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1121] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                            return 1
                        else:
                            mem[0] = sha3(address(arg1), 266)
                            s = sha3(mem[0]) + (2 * frozenCellCount[address(arg1)].field_0 + 1)
                            while sha3(sha3(address(arg1), 266)) + (2 * frozenCellCount[address(arg1)].field_0) > s:
                                stor[s] = 0
                                stor1[s] = 0
                                mem[0] = arg1
                                mem[32] = 266
                                s = s + 2
                                continue 
                            if idx < frozenCellCount[address(arg1)].field_0:
                                if not frozenCellCount[address(arg1)][idx].field_0:
                                    uint128(frozenCellCount[address(arg1)][idx].field_256) = uint128(arg3)
                                    uint8(frozenCellCount[address(arg1)][idx].field_384) = 1
                                    Mask(120, 0, frozenCellCount[address(arg1)][idx].field_392) = 0
                                    if idx < frozenCellCount[address(arg1)].field_0:
                                        if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                            if uint128(frozenCellCount[address(arg1)][idx].field_384) == 1:
                                                if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                                    frozenCellCount[address(arg1)][idx].field_0 += arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    idx = 0
                                                    s = stor262[address(arg1)]
                                                    while idx < frozenCellCount[address(arg1)].field_0:
                                                        require idx < frozenCellCount[address(arg1)].field_0
                                                        _1122 = sha3(sha3(address(arg1), 266))
                                                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                                        mem[0] = arg1
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                                                        continue 
                                                    idx = 0
                                                    s = stor262[address(msg.sender)]
                                                    while idx < frozenCellCount[address(msg.sender)].field_0:
                                                        require idx < frozenCellCount[address(msg.sender)].field_0
                                                        _1178 = sha3(sha3(address(msg.sender), 266))
                                                        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                                        mem[0] = msg.sender
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                                        continue 
                                                    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _1122] * frozenCellCount[address(arg1)].field_0) >= 0:
                                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _1122] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1178] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                            return 1
                    revert
                if idx <= frozenCellCount[address(arg1)].field_0:
                    if idx != frozenCellCount[address(arg1)].field_0:
                        if idx < frozenCellCount[address(arg1)].field_0:
                            if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                if uint128(frozenCellCount[address(arg1)][idx].field_384) == 1:
                                    if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                        frozenCellCount[address(arg1)][idx].field_0 += arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                        idx = 0
                                        s = stor262[address(arg1)]
                                        while idx < frozenCellCount[address(arg1)].field_0:
                                            require idx < frozenCellCount[address(arg1)].field_0
                                            _965 = sha3(sha3(address(arg1), 266))
                                            require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                            mem[0] = arg1
                                            mem[32] = 266
                                            idx = idx + 1
                                            s = frozenCellCount[address(arg1)][idx].field_0 + s
                                            continue 
                                        idx = 0
                                        s = stor262[address(msg.sender)]
                                        while idx < frozenCellCount[address(msg.sender)].field_0:
                                            require idx < frozenCellCount[address(msg.sender)].field_0
                                            _1117 = sha3(sha3(address(msg.sender), 266))
                                            require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                            mem[0] = msg.sender
                                            mem[32] = 266
                                            idx = idx + 1
                                            s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                            continue 
                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _965] * frozenCellCount[address(arg1)].field_0) >= 0:
                                            if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _965] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1117] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                return 1
                    else:
                        frozenCellCount[address(arg1)].field_0++
                        if not frozenCellCount[address(arg1)].field_0 > frozenCellCount[address(arg1)].field_0 + 1:
                            if idx < frozenCellCount[address(arg1)].field_0:
                                if not frozenCellCount[address(arg1)][idx].field_0:
                                    uint128(frozenCellCount[address(arg1)][idx].field_256) = uint128(arg3)
                                    uint8(frozenCellCount[address(arg1)][idx].field_384) = 1
                                    Mask(120, 0, frozenCellCount[address(arg1)][idx].field_392) = 0
                                    if idx < frozenCellCount[address(arg1)].field_0:
                                        if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                            if uint128(frozenCellCount[address(arg1)][idx].field_384) == 1:
                                                if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                                    frozenCellCount[address(arg1)][idx].field_0 += arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    idx = 0
                                                    s = stor262[address(arg1)]
                                                    while idx < frozenCellCount[address(arg1)].field_0:
                                                        require idx < frozenCellCount[address(arg1)].field_0
                                                        _966 = sha3(sha3(address(arg1), 266))
                                                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                                        mem[0] = arg1
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                                                        continue 
                                                    idx = 0
                                                    s = stor262[address(msg.sender)]
                                                    while idx < frozenCellCount[address(msg.sender)].field_0:
                                                        require idx < frozenCellCount[address(msg.sender)].field_0
                                                        _1118 = sha3(sha3(address(msg.sender), 266))
                                                        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                                        mem[0] = msg.sender
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                                        continue 
                                                    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _966] * frozenCellCount[address(arg1)].field_0) >= 0:
                                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _966] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1118] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                            return 1
                        else:
                            s = 2 * frozenCellCount[address(arg1)].field_0 + 1
                            while 2 * frozenCellCount[address(arg1)].field_0 > s:
                                frozenCellCount[address(arg1)][s].field_0 = 0
                                frozenCellCount[address(arg1)][s].field_256 = 0
                                s = s + 2
                                continue 
                            if idx < frozenCellCount[address(arg1)].field_0:
                                if not frozenCellCount[address(arg1)][idx].field_0:
                                    uint128(frozenCellCount[address(arg1)][idx].field_256) = uint128(arg3)
                                    uint8(frozenCellCount[address(arg1)][idx].field_384) = 1
                                    Mask(120, 0, frozenCellCount[address(arg1)][idx].field_392) = 0
                                    if idx < frozenCellCount[address(arg1)].field_0:
                                        if uint128(frozenCellCount[address(arg1)][idx].field_256) == uint128(arg3):
                                            if uint128(frozenCellCount[address(arg1)][idx].field_384) == 1:
                                                if arg2 + frozenCellCount[address(arg1)][idx].field_0 >= frozenCellCount[address(arg1)][idx].field_0:
                                                    frozenCellCount[address(arg1)][idx].field_0 += arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    idx = 0
                                                    s = stor262[address(arg1)]
                                                    while idx < frozenCellCount[address(arg1)].field_0:
                                                        require idx < frozenCellCount[address(arg1)].field_0
                                                        _1119 = sha3(sha3(address(arg1), 266))
                                                        require frozenCellCount[address(arg1)][idx].field_0 + s >= s
                                                        mem[0] = arg1
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(arg1)][idx].field_0 + s
                                                        continue 
                                                    idx = 0
                                                    s = stor262[address(msg.sender)]
                                                    while idx < frozenCellCount[address(msg.sender)].field_0:
                                                        require idx < frozenCellCount[address(msg.sender)].field_0
                                                        _1177 = sha3(sha3(address(msg.sender), 266))
                                                        require frozenCellCount[address(msg.sender)][idx].field_0 + s >= s
                                                        mem[0] = msg.sender
                                                        mem[32] = 266
                                                        idx = idx + 1
                                                        s = frozenCellCount[address(msg.sender)][idx].field_0 + s
                                                        continue 
                                                    if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _1119] * frozenCellCount[address(arg1)].field_0) >= 0:
                                                        if stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _1119] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _1177] * frozenCellCount[address(msg.sender)].field_0) == stor262[address(arg1)] + (stor[(2 * stor266[address(arg1)].field_0) + _245] * frozenCellCount[address(arg1)].field_0) + stor262[address(msg.sender)] + (stor[(2 * stor266[address(msg.sender)].field_0) + _485] * frozenCellCount[address(msg.sender)].field_0):
                                                            return 1
    revert
}



}
