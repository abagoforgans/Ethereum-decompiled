contract main {




// =====================  Runtime code  =====================


const Hello = 'hello world!', 0


array of struct stor1;
array of uint256 stor2;

function sub_d3a72ea1(?) {
    return uint256(sub_d3a72ea1[address(arg1)][0 len sub_d3a72ea1[address(arg1)].length].field_0)
}

function _fallback() payable {
    revert
}

function sub_817791b2(?) {
    require calldata.size - 4 >= 32
    if not Mask(255, 1, (256 * not bool(sub_d3a72ea1[address(arg1)].field_0)) - 1 and uint256(sub_d3a72ea1[address(arg1)].field_0)):
        revert with 0, 'Lover not registered'
    require address(sub_d3a72ea1[address(msg.sender)].field_256)
    revert with 0, 'Already have a lover'
}

function SetName(string arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require ceil32(arg1.length) + 128 <= test266151307() and ceil32(arg1.length) + 128 >= 96
    require arg1 + arg1.length + 36 <= calldata.size
    if arg1.length >= 32:
        revert with 0, 'Name too long'
    if arg1.length <= 0:
        revert with 0, 'Name cannot be empty'
    uint256(sub_d3a72ea1[address(msg.sender)][].field_0) = Array(len=arg1.length, data=arg1[all])
    if not Mask(255, 1, (256 * not bool(sub_d3a72ea1[address(msg.sender)].field_0)) - 1 and uint256(sub_d3a72ea1[address(msg.sender)].field_0)):
        return 'ok', 0
    return 'new user', 0
}

function sub_be95dd1b(?) {
    require calldata.size - 4 >= 64
    if not arg2:
        require arg1 < stor1.length
        mem[64] = 128
        uint8(stor1[arg1].field_8) = 0
        idx = 0
        s = 1
        t = 96
        while idx < uint256(stor1[arg1].field_1024):
            require idx < uint256(stor1[arg1].field_256)
            mem[0] = (7 * arg1) + sha3(1) + 1
            require stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)] <= 2
            if address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + idx].field_0) == msg.sender:
                if stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)]:
                    _76 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_76] = 17
                    mem[_76 + 32] = 'already confirmed'
                    require idx < uint256(stor1[arg1].field_256)
                    mem[0] = (7 * arg1) + sha3(1) + 1
                    require stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)] <= 2
                    if stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)] == 1:
                        idx = idx + 1
                        s = s
                        t = _76
                        continue 
                    idx = idx + 1
                    s = 0
                    t = _76
                    continue 
                require idx < uint256(stor1[arg1].field_256)
                if arg2 == 1:
                    uint256(stor[(0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1)].field_0) = 256^(idx % 32) or !(255 * 256^(idx % 32)) and uint256(stor[(0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1)].field_0)
                else:
                    uint255(stor[(0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1)].field_0) = uint255(256^(idx % 32))
                    bool(stor[(0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1)].field_255) = 0
                    uint8(stor1[arg1].field_8) = 2
            if stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)] == 1:
                idx = idx + 1
                s = s
                t = t
                continue 
            idx = idx + 1
            s = 0
            t = t
            continue 
    else:
        if arg2 != 1:
            revert with 0, 'Invalid confirmation message!'
        require arg1 < stor1.length
        mem[64] = 128
        uint8(stor1[arg1].field_8) = 0
        idx = 0
        s = 1
        t = 96
        while idx < uint256(stor1[arg1].field_1024):
            require idx < uint256(stor1[arg1].field_256)
            mem[0] = (7 * arg1) + sha3(1) + 1
            require stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)] <= 2
            if address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + idx].field_0) == msg.sender:
                if stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)]:
                    _78 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_78] = 17
                    mem[_78 + 32] = 'already confirmed'
                    require idx < uint256(stor1[arg1].field_256)
                    mem[0] = (7 * arg1) + sha3(1) + 1
                    require stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)] <= 2
                    if stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)] == 1:
                        idx = idx + 1
                        s = s
                        t = _78
                        continue 
                    idx = idx + 1
                    s = 0
                    t = _78
                    continue 
                require idx < uint256(stor1[arg1].field_256)
                if arg2 == 1:
                    uint256(stor[(0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1)].field_0) = 256^(idx % 32) or !(255 * 256^(idx % 32)) and uint256(stor[(0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1)].field_0)
                else:
                    uint255(stor[(0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1)].field_0) = uint255(256^(idx % 32))
                    bool(stor[(0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1)].field_255) = 0
                    uint8(stor1[arg1].field_8) = 2
            if stor((0.03125 / idx) + sha3((7 * arg1) + ('name', 'stor1', 1) + 1))[uint8(idx)] == 1:
                idx = idx + 1
                s = s
                t = t
                continue 
            idx = idx + 1
            s = 0
            t = t
            continue 
    if s:
        uint8(stor1[arg1].field_8) = 1
        s = 0
        while s < uint256(stor1[arg1].field_1024):
            mem[32] = 0
            uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)++
            require uint8(stor1[arg1].field_512) <= 2
            uint8(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_0) = uint8(stor1[arg1].field_512)
            uint256(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_256) = uint256(stor1[arg1].field_768)
            uint256(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_512) = uint256(stor1[arg1].field_1024)
            if not uint256(stor1[arg1].field_1024):
                t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 2)
                while sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 2) + uint256(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_512) > t:
                    address(stor[t]) = 0
                    t = t + 1
                    continue 
                mem[0] = (4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3
                if 31 >= stor[(7 * arg1) + ('name', 'stor1', 1) + 5].length:
                    uint256(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_768) = uint256(stor1[arg1].field_1280)
                    t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3)
                    while sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) > t:
                        uint256(stor[t]) = 0
                        t = t + 1
                        continue 
                    s = s + 1
                    continue 
                uint256(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_768) = Mask(255, 1, (256 * not bool(stor1[arg1].field_1280)) - 1 and uint256(stor1[arg1].field_1280)) + 1
                if not Mask(255, 1, (256 * not bool(stor1[arg1].field_1280)) - 1 and uint256(stor1[arg1].field_1280)):
                    t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3)
                    while sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) > t:
                        uint256(stor[t]) = 0
                        t = t + 1
                        continue 
                    s = s + 1
                    continue 
                mem[0] = (7 * arg1) + sha3(1) + 5
                t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3)
                idx = sha3((7 * arg1) + sha3(1) + 5)
                while sha3((7 * arg1) + sha3(1) + 5) + (stor[(7 * arg1) + ('name', 'stor1', 1) + 5].length + 31 / 32) > idx:
                    uint256(stor[t]) = uint256(stor[idx])
                    t = t + 1
                    idx = idx + 1
                    continue 
                t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3) + (stor[(7 * arg1) + ('name', 'stor1', 1) + 5].length + 31 / 32)
                while sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 2))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
                t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 2))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) + 1
                continue 
            t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 2)
            idx = sha3((7 * arg1) + sha3(1) + 4)
            while sha3((7 * arg1) + sha3(1) + 4) + uint256(stor1[arg1].field_1024) > idx:
                uint256(stor[t]) = uint256(stor[idx])
                t = t + 1
                idx = idx + 1
                continue 
            t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 2) + uint256(stor1[arg1].field_1024)
            while sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 2) + uint256(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_512) > t:
                address(stor[t]) = 0
                t = t + 1
                continue 
            mem[0] = (4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3
            if 31 >= stor[(7 * arg1) + ('name', 'stor1', 1) + 5].length:
                uint256(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_768) = uint256(stor1[arg1].field_1280)
                t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3)
                while sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 2))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
                t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 2))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) + 1
                continue 
            uint256(stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0)))].field_768) = Mask(255, 1, (256 * not bool(stor1[arg1].field_1280)) - 1 and uint256(stor1[arg1].field_1280)) + 1
            if not Mask(255, 1, (256 * not bool(stor1[arg1].field_1280)) - 1 and uint256(stor1[arg1].field_1280)):
                t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3)
                while sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 2))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
                t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + t].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 2))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) + 1
                continue 
            mem[0] = (7 * arg1) + sha3(1) + 5
            t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3)
            idx = sha3((7 * arg1) + sha3(1) + 5)
            while sha3((7 * arg1) + sha3(1) + 5) + (stor[(7 * arg1) + ('name', 'stor1', 1) + 5].length + 31 / 32) > idx:
                uint256(stor[t]) = uint256(stor[idx])
                t = t + 1
                idx = idx + 1
                continue 
            t = sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3) + (stor[(7 * arg1) + ('name', 'stor1', 1) + 5].length + 31 / 32)
            while sha3((4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + sha3(sha3(address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0), 0) + 3) + 3) + (stor[(4 * uint256(sub_d3a72ea1[address(stor[sha3((7 * arg1) + ('name', 'stor1', 1) + 4) + s].field_0)].field_768)) + ('array', 3, ('map', ('type', 160, ('field', 0, ('stor', ('add', ('sha3', ('add', 4, ('mul', 7, ('param', 'arg1')), ('name', 'stor1', 1))), ('var', 1))))), ('name', 'sub_d3a72ea1', 0))) + 3].length + 31 / 32) > t:
                uint256(stor[t]) = 0
                t = t + 1
                continue 
            s = s + 1
            continue 
    return 'ok', 0
}

function sub_7823c104(?) {
    require calldata.size - 4 >= 32
    mem[96] = 96
    mem[128] = 0
    mem[160] = 96
    mem[192] = 96
    mem[32] = 0
    mem[352] = sub_d3a72ea1[address(arg1)].length
    mem[0] = sha3(address(arg1), 0)
    mem[384] = uint256(sub_d3a72ea1[address(arg1)].field_0)
    idx = 384
    s = 0
    while sub_d3a72ea1[address(arg1)].length + 352 > idx:
        mem[idx + 32] = uint256(sub_d3a72ea1[address(arg1)][s].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[224] = 352
    mem[256] = address(sub_d3a72ea1[address(arg1)].field_256)
    mem[ceil32(sub_d3a72ea1[address(arg1)].length) + 384] = uint256(sub_d3a72ea1[address(arg1)].field_512)
    if not uint256(sub_d3a72ea1[address(arg1)].field_512):
        mem[288] = ceil32(sub_d3a72ea1[address(arg1)].length) + 384
        mem[64] = ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_768)) + 448
        mem[ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + 416] = uint256(sub_d3a72ea1[address(arg1)].field_768)
        s = ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + 448
        idx = 0
        while idx < uint256(sub_d3a72ea1[address(arg1)].field_768):
            mem[0] = sha3(address(arg1), 0) + 3
            _274 = mem[64]
            mem[64] = mem[64] + 128
            require uint8(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_0) <= 2
            mem[_274] = uint8(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_0)
            mem[_274 + 32] = uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_256)
            _282 = mem[64]
            mem[64] = mem[64] + (32 * uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_512)) + 32
            mem[_282] = uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_512)
            if not uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_512):
                mem[_274 + 64] = _282
                _286 = mem[64]
                mem[64] = mem[64] + ceil32(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length) + 32
                mem[_286] = stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 0) + 3) + 3
                mem[_286 + 32] = uint256(stor[sha3((4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3)].field_0)
                t = _286 + 32
                u = sha3(mem[0])
                while _286 + stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length > t:
                    mem[t + 32] = uint256(stor1[u].field_0)
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_274 + 96] = _286
            else:
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 0) + 3) + 2
                mem[_282 + 32] = address(stor[sha3((4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 2)].field_0)
                t = _282 + 32
                u = sha3(mem[0])
                while _282 + (32 * uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_512)) > t:
                    mem[t + 32] = address(stor1[u].field_0)
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_274 + 64] = _282
                _680 = mem[64]
                mem[64] = mem[64] + ceil32(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length) + 32
                mem[_680] = stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 0) + 3) + 3
                mem[_680 + 32] = uint256(stor[sha3((4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3)].field_0)
                t = _680 + 32
                u = sha3(mem[0])
                while _680 + stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length > t:
                    mem[t + 32] = uint256(stor1[u].field_0)
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_274 + 96] = _680
            mem[s] = _274
            s = s + 32
            idx = idx + 1
            continue 
        mem[320] = ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + 416
        _278 = mem[64]
        mem[mem[64]] = 32
        _285 = mem[224]
        mem[mem[64] + 32] = 128
        _296 = mem[_285]
        mem[mem[64] + 160] = mem[_285]
        mem[mem[64] + 192 len ceil32(_296)] = mem[_285 + 32 len ceil32(_296)]
        var34001 = ceil32(_296)
        if ceil32(_296) <= _296:
            mem[mem[64] + 64] = mem[268 len 20]
            _524 = mem[288]
            mem[mem[64] + 96] = ceil32(_296) + 160
            _528 = mem[_524]
            mem[mem[64] + ceil32(_296) + 192] = mem[_524]
            idx = 0
            s = _524 + 32
            t = mem[64] + ceil32(_296) + 224
            while idx < _528:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _693 = mem[320]
            mem[_278 + 128] = ceil32(_296) + (32 * _528) + 192
            _702 = mem[_693]
            mem[_278 + ceil32(_296) + (32 * _528) + 224] = mem[_693]
            idx = 0
            s = _693 + 32
            t = _278 + ceil32(_296) + (32 * _528) + (32 * _702) + 256
            u = _278 + ceil32(_296) + (32 * _528) + 256
            while idx < _702:
                mem[u] = t + -_278 + -ceil32(_296) + -(32 * _528) - 256
                _862 = mem[s]
                require mem[mem[s]] < 3
                mem[t] = mem[mem[s]]
                mem[t + 32] = mem[_862 + 32]
                _912 = mem[_862 + 64]
                mem[t + 64] = 128
                _916 = mem[_912]
                mem[t + 128] = mem[_912]
                v = 0
                w = _912 + 32
                x = t + 160
                while v < _916:
                    mem[x] = mem[w + 12 len 20]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _996 = mem[_862 + 96]
                mem[t + 96] = (32 * _916) + 160
                _1005 = mem[_996]
                mem[t + (32 * _916) + 160] = mem[_996]
                v = 0
                while _916 < _1005:
                    mem[t + (34 * _916) + 192] = mem[_996 + _916 + 32]
                    v = _916 + 32
                    continue 
                if _916 > _1005:
                    mem[t + (32 * _916) + _1005 + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + (32 * _916) + ceil32(_1005) + 192
                u = u + 32
                continue 
        else:
            mem[mem[64] + _296 + 192] = 0
            mem[mem[64] + 64] = mem[268 len 20]
            _527 = mem[288]
            mem[_278 + 96] = ceil32(_296) + 160
            _530 = mem[_527]
            mem[_278 + ceil32(_296) + 192] = mem[_527]
            idx = 0
            s = _527 + 32
            t = _278 + ceil32(_296) + 224
            while idx < _530:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _694 = mem[320]
            mem[_278 + 128] = ceil32(_296) + (32 * _530) + 192
            _703 = mem[_694]
            mem[_278 + ceil32(_296) + (32 * _530) + 224] = mem[_694]
            idx = 0
            s = _694 + 32
            t = _278 + ceil32(_296) + (32 * _530) + (32 * _703) + 256
            u = _278 + ceil32(_296) + (32 * _530) + 256
            while idx < _703:
                mem[u] = t + -_278 + -ceil32(_296) + -(32 * _530) - 256
                _863 = mem[s]
                require mem[mem[s]] < 3
                mem[t] = mem[mem[s]]
                mem[t + 32] = mem[_863 + 32]
                _913 = mem[_863 + 64]
                mem[t + 64] = 128
                _917 = mem[_913]
                mem[t + 128] = mem[_913]
                v = 0
                w = _913 + 32
                x = t + 160
                while v < _917:
                    mem[x] = mem[w + 12 len 20]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _997 = mem[_863 + 96]
                mem[t + 96] = (32 * _917) + 160
                _1006 = mem[_997]
                mem[t + (32 * _917) + 160] = mem[_997]
                v = 0
                while _917 < _1006:
                    mem[t + (34 * _917) + 192] = mem[_997 + _917 + 32]
                    v = _917 + 32
                    continue 
                if _917 > _1006:
                    mem[t + (32 * _917) + _1006 + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + (32 * _917) + ceil32(_1006) + 192
                u = u + 32
                continue 
    else:
        mem[0] = sha3(address(arg1), 0) + 2
        mem[ceil32(sub_d3a72ea1[address(arg1)].length) + 416] = address(sub_d3a72ea1[address(arg1)][2].field_0)
        idx = ceil32(sub_d3a72ea1[address(arg1)].length) + 416
        s = 0
        while ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + 384 > idx:
            mem[idx + 32] = address(sub_d3a72ea1[address(arg1)][s + 2].field_256)
            idx = idx + 32
            s = s + 1
            continue 
        mem[288] = ceil32(sub_d3a72ea1[address(arg1)].length) + 384
        mem[64] = ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_768)) + 448
        mem[ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + 416] = uint256(sub_d3a72ea1[address(arg1)].field_768)
        s = ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + 448
        idx = 0
        while idx < uint256(sub_d3a72ea1[address(arg1)].field_768):
            mem[0] = sha3(address(arg1), 0) + 3
            _687 = mem[64]
            mem[64] = mem[64] + 128
            require uint8(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_0) <= 2
            mem[_687] = uint8(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_0)
            mem[_687 + 32] = uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_256)
            _699 = mem[64]
            mem[64] = mem[64] + (32 * uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_512)) + 32
            mem[_699] = uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_512)
            if not uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_512):
                mem[_687 + 64] = _699
                _705 = mem[64]
                mem[64] = mem[64] + ceil32(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length) + 32
                mem[_705] = stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 0) + 3) + 3
                mem[_705 + 32] = uint256(stor[sha3((4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3)].field_0)
                t = _705 + 32
                u = sha3(mem[0])
                while _705 + stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length > t:
                    mem[t + 32] = uint256(stor1[u].field_0)
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_687 + 96] = _705
            else:
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 0) + 3) + 2
                mem[_699 + 32] = address(stor[sha3((4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 2)].field_0)
                t = _699 + 32
                u = sha3(mem[0])
                while _699 + (32 * uint256(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0)))].field_512)) > t:
                    mem[t + 32] = address(stor1[u].field_0)
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_687 + 64] = _699
                _981 = mem[64]
                mem[64] = mem[64] + ceil32(stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length) + 32
                mem[_981] = stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 0) + 3) + 3
                mem[_981 + 32] = uint256(stor[sha3((4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3)].field_0)
                t = _981 + 32
                u = sha3(mem[0])
                while _981 + stor[(4 * idx) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'sub_d3a72ea1', 0))) + 3].length > t:
                    mem[t + 32] = uint256(stor1[u].field_0)
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_687 + 96] = _981
            mem[s] = _687
            s = s + 32
            idx = idx + 1
            continue 
        mem[320] = ceil32(sub_d3a72ea1[address(arg1)].length) + (32 * uint256(sub_d3a72ea1[address(arg1)].field_512)) + 416
        _696 = mem[64]
        mem[mem[64]] = 32
        _704 = mem[224]
        mem[mem[64] + 32] = 128
        _710 = mem[_704]
        mem[mem[64] + 160] = mem[_704]
        mem[mem[64] + 192 len ceil32(_710)] = mem[_704 + 32 len ceil32(_710)]
        if ceil32(_710) <= _710:
            mem[mem[64] + 64] = mem[268 len 20]
            _909 = mem[288]
            mem[mem[64] + 96] = ceil32(_710) + 160
            _915 = mem[_909]
            mem[mem[64] + ceil32(_710) + 192] = mem[_909]
            idx = 0
            s = _909 + 32
            t = mem[64] + ceil32(_710) + 224
            while idx < _915:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _998 = mem[320]
            mem[mem[64] + 128] = ceil32(_710) + (32 * _915) + 192
            _1007 = mem[_998]
            mem[mem[64] + ceil32(_710) + (32 * _915) + 224] = mem[_998]
            idx = 0
            s = _998 + 32
            t = mem[64] + ceil32(_710) + (32 * _915) + (32 * _1007) + 256
            u = mem[64] + ceil32(_710) + (32 * _915) + 256
            while idx < _1007:
                mem[u] = t + -_696 + -ceil32(_710) + -(32 * _915) - 256
                _1065 = mem[s]
                require mem[mem[s]] < 3
                mem[t] = mem[mem[s]]
                mem[t + 32] = mem[_1065 + 32]
                _1087 = mem[_1065 + 64]
                mem[t + 64] = 128
                _1089 = mem[_1087]
                mem[t + 128] = mem[_1087]
                v = 0
                w = _1087 + 32
                x = t + 160
                while v < _1089:
                    mem[x] = mem[w + 12 len 20]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _1105 = mem[_1065 + 96]
                mem[t + 96] = (32 * _1089) + 160
                _1107 = mem[_1105]
                mem[t + (32 * _1089) + 160] = mem[_1105]
                v = 0
                while _1089 < _1107:
                    mem[t + (34 * _1089) + 192] = mem[_1105 + _1089 + 32]
                    v = _1089 + 32
                    continue 
                if _1089 > _1107:
                    mem[t + (32 * _1089) + _1107 + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + (32 * _1089) + ceil32(_1107) + 192
                u = u + 32
                continue 
        else:
            mem[mem[64] + _710 + 192] = 0
            mem[mem[64] + 64] = mem[268 len 20]
            _914 = mem[288]
            mem[mem[64] + 96] = ceil32(_710) + 160
            _918 = mem[_914]
            mem[mem[64] + ceil32(_710) + 192] = mem[_914]
            idx = 0
            s = _914 + 32
            t = mem[64] + ceil32(_710) + 224
            while idx < _918:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _999 = mem[320]
            mem[mem[64] + 128] = ceil32(_710) + (32 * _918) + 192
            _1008 = mem[_999]
            mem[mem[64] + ceil32(_710) + (32 * _918) + 224] = mem[_999]
            idx = 0
            s = _999 + 32
            t = mem[64] + ceil32(_710) + (32 * _918) + (32 * _1008) + 256
            u = mem[64] + ceil32(_710) + (32 * _918) + 256
            while idx < _1008:
                mem[u] = t + -_696 + -ceil32(_710) + -(32 * _918) - 256
                _1066 = mem[s]
                require mem[mem[s]] < 3
                mem[t] = mem[mem[s]]
                mem[t + 32] = mem[_1066 + 32]
                _1088 = mem[_1066 + 64]
                mem[t + 64] = 128
                _1090 = mem[_1088]
                mem[t + 128] = mem[_1088]
                v = 0
                w = _1088 + 32
                x = t + 160
                while v < _1090:
                    mem[x] = mem[w + 12 len 20]
                    v = v + 1
                    w = w + 32
                    x = x + 32
                    continue 
                _1106 = mem[_1066 + 96]
                mem[t + 96] = (32 * _1090) + 160
                _1108 = mem[_1106]
                mem[t + (32 * _1090) + 160] = mem[_1106]
                v = 0
                while _1090 < _1108:
                    mem[t + (34 * _1090) + 192] = mem[_1106 + _1090 + 32]
                    v = _1090 + 32
                    continue 
                if _1090 > _1108:
                    mem[t + (32 * _1090) + _1108 + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + (32 * _1090) + ceil32(_1108) + 192
                u = u + 32
                continue 
    return memory
      from mem[64]
       len t - mem[64]
}

function sub_893f3a6d(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 <= test266151307() and (32 * ('cd', 4).length) + 128 >= 96
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        mem[t] = address(cd[s])
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 160 <= test266151307() and ceil32(('cd', 36).length) + 160 >= 128
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 36).length
    require cd[36] + ('cd', 36).length + 36 <= calldata.size
    mem[(32 * ('cd', 4).length) + 160 len ('cd', 36).length] = call.data[cd[36] + 36 len ('cd', 36).length]
    mem[(32 * ('cd', 4).length) + ('cd', 36).length + 160] = 0
    if ('cd', 36).length >= 256:
        revert with 0, 'Description too long'
    if ('cd', 4).length == 1:
        require 0 < ('cd', 4).length
        if mem[140 len 20] != msg.sender:
            revert with 0, 'Cannot write other's activity'
        uint256(sub_d3a72ea1[address(msg.sender)].field_768)++
        uint8(stor[(4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0)))].field_0) = 0
        stor[(4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0)))].field_256 % 1 = 0
        uint256(stor[(4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0)))].field_256) = block.timestamp
        uint256(stor[(4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0)))].field_512) = ('cd', 4).length
        if not ('cd', 4).length:
            idx = 0
            while uint256(stor[(4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0)))].field_512) > idx:
                address(stor[idx + sha3((4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0))) + 2)].field_0) = 0
                idx = idx + 1
                continue 
            uint256(stor[sha3((4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0))) + 3)][].field_0) = Array(len=('cd', 36).length, data=call.data[cd[36] + 36 len ('cd', 36).length])
        else:
            s = 0
            idx = 128
            while (32 * ('cd', 4).length) + 128 > idx:
                address(stor[s + sha3((4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0))) + 2)].field_0) = mem[idx + 12 len 20]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, (32 * ('cd', 4).length) + 31) >> 5
            while uint256(stor[(4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0)))].field_512) > idx:
                address(stor[idx + sha3((4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0))) + 2)].field_0) = 0
                idx = idx + 1
                continue 
            uint256(stor[sha3((4 * uint256(sub_d3a72ea1[address(msg.sender)].field_768)) + ('array', 3, ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_d3a72ea1', 0))) + 3)][].field_0) = Array(len=('cd', 36).length, data=call.data[cd[36] + 36 len ('cd', 36).length])
            var76001 = 32
        return 'ok', 0
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 160] = 0
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 192] = 0
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 224] = 96
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 256] = 96
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 288] = 0
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 320] = block.timestamp
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 352] = 96
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 384] = (32 * ('cd', 4).length) + 128
    mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 416] = ('cd', 4).length
    if not ('cd', 4).length:
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 448] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 480] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 512] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 544] = 96
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 736] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 768] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 800] = 96
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 832] = 96
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 576] = (64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 736
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 608] = 0
        mem[64] = (64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 1056
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 864] = 1
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 896] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 928] = msg.sender
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960] = (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 416
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] = (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 288
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 1024] = stor1.length
        idx = 0
        while idx < ('cd', 4).length:
            require idx < ('cd', 4).length
            require idx < ('cd', 4).length
            if mem[(32 * idx) + 140 len 20] == msg.sender:
                mem[(32 * idx) + (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 448] = 1
            else:
                mem[(32 * idx) + (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 448] = 0
                require idx < ('cd', 4).length
                mem[32] = 2
                stor2[mem[(32 * idx) + 140 len 20]]++
                mem[0] = sha3(mem[(32 * idx) + 140 len 20], 2)
                stor2[mem[(32 * idx) + 140 len 20]][stor2[mem[(32 * idx) + 140 len 20]]] = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 1024]
            idx = idx + 1
            continue 
        stor1.length++
        mem[0] = 1
        require mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 864] <= 1
        uint256(stor1[stor1.length].field_0) = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 864]
        require mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 896] <= 2
        Mask(248, 0, stor1[stor1.length].field_8) = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 897 len 31]
        address(stor1[stor1.length].field_16) = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 940 len 20]
        _677 = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960]]
        uint256(stor1[stor1.length].field_256) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960]]
        mem[0] = (7 * stor1.length) + sha3(1) + 1
        if not _677:
            idx = 0
            while uint256(stor1[stor1.length].field_256) + 31 / 32 > idx:
                uint8(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 1)].field_0) = 0
                idx = idx + 1
                continue 
            require mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992]] <= 2
            uint256(stor1[stor1.length].field_512) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992]]
            uint256(stor1[stor1.length].field_768) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 32]
            _972 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64]]
            uint256(stor1[stor1.length].field_1024) = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64]]
            mem[0] = (7 * stor1.length) + sha3(1) + 4
            if not _972:
                idx = 0
                while uint256(stor1[stor1.length].field_1024) > idx:
                    address(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = 0
                    idx = idx + 1
                    continue 
                _1221 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96]]
                mem[0] = (7 * stor1.length) + sha3(1) + 5
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 5)][].field_0) = Array(len=_1221, data=mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96] + 32 len _1221])
            else:
                s = 0
                idx = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64] + 32
                while mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64] + (32 * _972) + 32 > idx:
                    address(stor[s + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * _972) + 31) >> 5
                while uint256(stor1[stor1.length].field_1024) > idx:
                    address(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = 0
                    idx = idx + 1
                    continue 
                _1454 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96]]
                mem[0] = (7 * stor1.length) + sha3(1) + 5
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 5)][].field_0) = Array(len=_1454, data=mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96] + 32 len _1454])
        else:
            s = 0
            idx = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960] + 32
            while mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960] + (32 * _677) + 32 > idx:
                require mem[idx] <= 2
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 1)].field_0) = mem[idx] * 256^s or !(255 * 256^s) and uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 1)].field_0)
                s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, (32 * _677) + 31) >> 5
            s = sha3((7 * stor1.length) + sha3(1) + 1)
            while idx:
                uint256(stor[s]) = !(255 * 256^idx) and uint256(stor[s])
                idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1
                s = (idx + 1 / 32) + s
                continue 
            idx = (floor32(None + 3) >> 4) + (None * None + 3 / 32) - (Mask(251, 0, (32 * _677) + 31) >> 5 * None + 3 / 32)
            while uint256(stor1[stor1.length].field_256) + 31 / 32 > idx:
                uint8(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 1)].field_0) = 0
                idx = idx + 1
                continue 
            require mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992]] <= 2
            uint256(stor1[stor1.length].field_512) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992]]
            uint256(stor1[stor1.length].field_768) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 32]
            _1467 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64]]
            uint256(stor1[stor1.length].field_1024) = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64]]
            mem[0] = (7 * stor1.length) + sha3(1) + 4
            if not _1467:
                idx = 0
                while uint256(stor1[stor1.length].field_1024) > idx:
                    address(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = 0
                    idx = idx + 1
                    continue 
                _1664 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96]]
                mem[0] = (7 * stor1.length) + sha3(1) + 5
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 5)][].field_0) = Array(len=_1664, data=mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96] + 32 len _1664])
            else:
                s = 0
                idx = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64] + 32
                while mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64] + (32 * _1467) + 32 > idx:
                    address(stor[s + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * _1467) + 31) >> 5
                while uint256(stor1[stor1.length].field_1024) > idx:
                    address(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = 0
                    idx = idx + 1
                    continue 
                _1822 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96]]
                mem[0] = (7 * stor1.length) + sha3(1) + 5
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 5)][].field_0) = Array(len=_1822, data=mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96] + 32 len _1822])
    else:
        mem[(32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 448 len 32 * ('cd', 4).length] = code.data[11613 len 32 * ('cd', 4).length]
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 448] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 480] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 512] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 544] = 96
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 736] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 768] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 800] = 96
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 832] = 96
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 576] = (64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 736
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 608] = 0
        mem[64] = (64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 1056
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 864] = 1
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 896] = 0
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 928] = msg.sender
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960] = (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 416
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] = (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 288
        mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 1024] = stor1.length
        idx = 0
        while idx < ('cd', 4).length:
            require idx < ('cd', 4).length
            require idx < ('cd', 4).length
            if mem[(32 * idx) + 140 len 20] == msg.sender:
                mem[(32 * idx) + (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 448] = 1
            else:
                mem[(32 * idx) + (32 * ('cd', 4).length) + ceil32(('cd', 36).length) + 448] = 0
                require idx < ('cd', 4).length
                mem[32] = 2
                stor2[mem[(32 * idx) + 140 len 20]]++
                mem[0] = sha3(mem[(32 * idx) + 140 len 20], 2)
                stor2[mem[(32 * idx) + 140 len 20]][stor2[mem[(32 * idx) + 140 len 20]]] = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 1024]
            idx = idx + 1
            continue 
        stor1.length++
        mem[0] = 1
        require mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 864] <= 1
        uint256(stor1[stor1.length].field_0) = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 864]
        require mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 896] <= 2
        Mask(248, 0, stor1[stor1.length].field_8) = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 897 len 31]
        address(stor1[stor1.length].field_16) = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 940 len 20]
        _682 = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960]]
        uint256(stor1[stor1.length].field_256) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960]]
        mem[0] = (7 * stor1.length) + sha3(1) + 1
        if not _682:
            idx = 0
            while uint256(stor1[stor1.length].field_256) + 31 / 32 > idx:
                uint8(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 1)].field_0) = 0
                idx = idx + 1
                continue 
            require mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992]] <= 2
            uint256(stor1[stor1.length].field_512) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992]]
            uint256(stor1[stor1.length].field_768) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 32]
            _975 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64]]
            uint256(stor1[stor1.length].field_1024) = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64]]
            mem[0] = (7 * stor1.length) + sha3(1) + 4
            if not _975:
                idx = 0
                while uint256(stor1[stor1.length].field_1024) > idx:
                    address(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = 0
                    idx = idx + 1
                    continue 
                _1223 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96]]
                mem[0] = (7 * stor1.length) + sha3(1) + 5
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 5)][].field_0) = Array(len=_1223, data=mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96] + 32 len _1223])
            else:
                s = 0
                idx = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64] + 32
                while mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64] + (32 * _975) + 32 > idx:
                    address(stor[s + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * _975) + 31) >> 5
                while uint256(stor1[stor1.length].field_1024) > idx:
                    address(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = 0
                    idx = idx + 1
                    continue 
                _1460 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96]]
                mem[0] = (7 * stor1.length) + sha3(1) + 5
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 5)][].field_0) = Array(len=_1460, data=mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96] + 32 len _1460])
        else:
            s = 0
            idx = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960] + 32
            while mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 960] + (32 * _682) + 32 > idx:
                require mem[idx] <= 2
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 1)].field_0) = mem[idx] * 256^s or !(255 * 256^s) and uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 1)].field_0)
                s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, (32 * _682) + 31) >> 5
            s = sha3((7 * stor1.length) + sha3(1) + 1)
            while idx:
                uint256(stor[s]) = !(255 * 256^idx) and uint256(stor[s])
                idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1
                s = (idx + 1 / 32) + s
                continue 
            idx = (floor32(None + 3) >> 4) + (None * None + 3 / 32) - (Mask(251, 0, (32 * _682) + 31) >> 5 * None + 3 / 32)
            while uint256(stor1[stor1.length].field_256) + 31 / 32 > idx:
                uint8(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 1)].field_0) = 0
                idx = idx + 1
                continue 
            require mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992]] <= 2
            uint256(stor1[stor1.length].field_512) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992]]
            uint256(stor1[stor1.length].field_768) = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 32]
            _1471 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64]]
            uint256(stor1[stor1.length].field_1024) = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64]]
            mem[0] = (7 * stor1.length) + sha3(1) + 4
            if not _1471:
                idx = 0
                while uint256(stor1[stor1.length].field_1024) > idx:
                    address(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = 0
                    idx = idx + 1
                    continue 
                _1669 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96]]
                mem[0] = (7 * stor1.length) + sha3(1) + 5
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 5)][].field_0) = Array(len=_1669, data=mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96] + 32 len _1669])
            else:
                s = 0
                idx = mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64] + 32
                while mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 64] + (32 * _1471) + 32 > idx:
                    address(stor[s + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * _1471) + 31) >> 5
                while uint256(stor1[stor1.length].field_1024) > idx:
                    address(stor[idx + sha3((7 * stor1.length) + ('name', 'stor1', 1) + 4)].field_0) = 0
                    idx = idx + 1
                    continue 
                _1827 = mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96]]
                mem[0] = (7 * stor1.length) + sha3(1) + 5
                uint256(stor[sha3((7 * stor1.length) + ('name', 'stor1', 1) + 5)][].field_0) = Array(len=_1827, data=mem[mem[mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 992] + 96] + 32 len _1827])
    uint256(stor1[stor1.length].field_1536) = mem[(64 * ('cd', 4).length) + ceil32(('cd', 36).length) + 1024]
    return Array(len=('cd', 4).length, data=mem[128 len ceil32(('cd', 4).length)])
}

function sub_52f6069c(?) {
    require calldata.size - 4 >= 32
    mem[0] = arg1
    mem[96] = stor2[address(arg1)]
    mem[64] = (32 * stor2[address(arg1)]) + 128
    if not stor2[address(arg1)]:
        mem[0] = arg1
        mem[32] = 2
        idx = 0
        while idx < stor2[address(arg1)]:
            mem[32] = 2
            require idx < stor2[address(arg1)]
            require stor2[address(arg1)][idx] < stor1.length
            mem[0] = 1
            _99 = mem[64]
            mem[64] = mem[64] + 192
            require uint8(stor1[stor2[address(arg1)][idx]].field_0) <= 1
            mem[_99] = uint8(stor1[stor2[address(arg1)][idx]].field_0)
            require uint8(stor1[stor2[address(arg1)][idx]].field_8) <= 2
            mem[_99 + 32] = uint8(stor1[stor2[address(arg1)][idx]].field_8)
            mem[_99 + 64] = address(stor1[stor2[address(arg1)][idx]].field_16)
            _102 = mem[64]
            mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) + 32
            mem[_102] = uint256(stor1[stor2[address(arg1)][idx]].field_256)
            if not uint256(stor1[stor2[address(arg1)][idx]].field_256):
                mem[_99 + 96] = _102
                _103 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_103] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_103 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _106 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_106] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_103 + 64] = _106
                    _109 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_109] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_109 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _109 + 32
                    t = sha3(mem[0])
                    while _109 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_103 + 96] = _109
                    mem[_99 + 128] = _103
                    mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = _99
                    mem[0] = arg1
                    mem[32] = 2
                    idx = idx + 1
                    continue 
                mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                mem[_106 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                s = _106 + 32
                t = sha3(mem[0])
                while _106 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                    mem[0] = arg1
                    mem[32] = 2
                    mem[s + 32] = address(stor1[t].field_0)
                    s = s + 32
                    t = t + 1
                    continue 
                mem[_103 + 64] = _106
                _258 = mem[64]
                mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                mem[_258] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                mem[_258 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                s = _258 + 32
                t = sha3(mem[0])
                while _258 + stor[(7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5].length > s:
                    mem[0] = arg1
                    mem[32] = 2
                    mem[s + 32] = uint256(stor1[t].field_0)
                    s = s + 32
                    t = t + 1
                    continue 
                mem[_103 + 96] = _258
                mem[_99 + 128] = _103
                mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][s]].field_1536)
                require s < mem[96]
                mem[(32 * s) + 128] = _99
                mem[0] = arg1
                mem[32] = 2
                s = s + 1
                continue 
            mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 1
            require storsha3((7 * stor[('array', ('var', 0), ('map', ('mask_shl', 160, 0, 96, ('param', 'arg1')), ('name', 'stor2', 2)))]) + ('name', 'stor1', 1) + 1)[var26002] <= 2
            mem[var28002] = var28001
            if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var28002:
                mem[_99 + 96] = _102
                _263 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_263] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_263 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _268 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_268] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_263 + 64] = _268
                    _270 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_270] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_270 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _270 + 32
                    t = sha3(mem[0])
                    while _270 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_263 + 96] = _270
                    mem[_99 + 128] = _263
                    mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = _99
                    mem[0] = arg1
                    mem[32] = 2
                    idx = idx + 1
                    continue 
                mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                mem[_268 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                s = _268 + 32
                t = sha3(mem[0])
                while _268 + (32 * uint256(stor1[stor2[address(arg1)][s]].field_1024)) > s:
                    mem[0] = arg1
                    mem[32] = 2
                    mem[s + 32] = address(stor1[t].field_0)
                    s = s + 32
                    t = t + 1
                    continue 
                mem[_263 + 64] = _268
                _397 = mem[64]
                mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5].length) + 32
                mem[_397] = stor[(7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5].length
                mem[0] = (7 * stor2[address(arg1)][s]) + sha3(1) + 5
                mem[_397 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5)].field_0)
                t = _397 + 32
                u = sha3(mem[0])
                while _397 + stor[(7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5].length > t:
                    mem[0] = arg1
                    mem[32] = 2
                    mem[t + 32] = uint256(stor1[u].field_0)
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_263 + 96] = _397
                mem[_99 + 128] = _263
                mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][s]].field_1536)
                require s < mem[96]
                mem[(32 * s) + 128] = _99
                mem[0] = arg1
                mem[32] = 2
                s = s + 1
                continue 
            require storvar30003[var30002] <= 2
            mem[var32002] = var32001
            if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var32002:
                mem[_99 + 96] = _102
                _401 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_401] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_401 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _409 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_409] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_401 + 64] = _409
                    _410 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_410] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_410 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _410 + 32
                    t = sha3(mem[0])
                    while _410 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_401 + 96] = _410
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_409 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _409 + 32
                    t = sha3(mem[0])
                    while _409 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_401 + 64] = _409
                    _492 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_492] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_492 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _492 + 32
                    t = sha3(mem[0])
                    while _492 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_401 + 96] = _492
                mem[_99 + 128] = _401
                mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _99
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar34003[var34002] <= 2
            mem[var36002] = var36001
            if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var36002:
                mem[_99 + 96] = _102
                _495 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_495] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_495 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _503 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_503] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_495 + 64] = _503
                    _505 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_505] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_505 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _505 + 32
                    t = sha3(mem[0])
                    while _505 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_495 + 96] = _505
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_503 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _503 + 32
                    t = sha3(mem[0])
                    while _503 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_495 + 64] = _503
                    _563 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_563] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_563 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _563 + 32
                    t = sha3(mem[0])
                    while _563 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_495 + 96] = _563
                mem[_99 + 128] = _495
                mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _99
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar38003[var38002] <= 2
            mem[var40002] = var40001
            if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var40002:
                mem[_99 + 96] = _102
                _565 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_565] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_565 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _572 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_572] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_565 + 64] = _572
                    _573 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_573] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_573 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _573 + 32
                    t = sha3(mem[0])
                    while _573 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_565 + 96] = _573
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_572 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _572 + 32
                    t = sha3(mem[0])
                    while _572 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_565 + 64] = _572
                    _625 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_625] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_625 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _625 + 32
                    t = sha3(mem[0])
                    while _625 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_565 + 96] = _625
                mem[_99 + 128] = _565
                mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _99
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar42003[var42002] <= 2
            mem[var44002] = var44001
            if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var44002:
                mem[_99 + 96] = _102
                _627 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_627] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_627 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _634 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_634] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_627 + 64] = _634
                    _635 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_635] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_635 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _635 + 32
                    t = sha3(mem[0])
                    while _635 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_627 + 96] = _635
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_634 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _634 + 32
                    t = sha3(mem[0])
                    while _634 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_627 + 64] = _634
                    _687 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_687] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_687 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _687 + 32
                    t = sha3(mem[0])
                    while _687 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_627 + 96] = _687
                mem[_99 + 128] = _627
                mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _99
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar46003[var46002] <= 2
            mem[var48002] = var48001
            if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var48002:
                mem[_99 + 96] = _102
                _689 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_689] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_689 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _696 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_696] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_689 + 64] = _696
                    _697 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_697] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_697 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _697 + 32
                    t = sha3(mem[0])
                    while _697 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_689 + 96] = _697
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_696 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _696 + 32
                    t = sha3(mem[0])
                    while _696 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_689 + 64] = _696
                    _749 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_749] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_749 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _749 + 32
                    t = sha3(mem[0])
                    while _749 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_689 + 96] = _749
                mem[_99 + 128] = _689
                mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _99
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar50003[var50002] <= 2
            mem[var52002] = var52001
            if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) > var52002:
                require storvar54003[var54002] <= 2
                mem[var56002] = var56001
                if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) > var56002:
                    require storvar58003[var58002] <= 2
                    mem[var60002] = var60001
                    if _102 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) > var60002:
                        # nil
                    else:
                        mem[_99 + 96] = _102
                        _875 = mem[64]
                        mem[64] = mem[64] + 128
                        require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                        mem[_875] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                        mem[_875 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                        _882 = mem[64]
                        mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                        mem[_882] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                        if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                            mem[_875 + 64] = _882
                            _883 = mem[64]
                        # nil
                else:
                    mem[_99 + 96] = _102
                    _813 = mem[64]
                    mem[64] = mem[64] + 128
                    require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                    mem[_813] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                    mem[_813 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                    _820 = mem[64]
                    mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                    mem[_820] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                    if uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                        mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                        mem[_820 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                        s = _820 + 32
                        t = sha3(mem[0])
                        while _820 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                            mem[0] = arg1
                            mem[32] = 2
                            mem[s + 32] = address(stor1[t].field_0)
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_813 + 64] = _820
                        _873 = mem[64]
                        # nil
                    else:
                        mem[_813 + 64] = _820
                        _821 = mem[64]
                        mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                        mem[_821] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                        mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                        mem[_821 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                        s = _821 + 32
                        t = sha3(mem[0])
                        while _821 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                            mem[0] = arg1
                            mem[32] = 2
                            mem[s + 32] = uint256(stor1[t].field_0)
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_813 + 96] = _821
                        mem[_99 + 128] = _813
                        mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = _99
                        mem[0] = arg1
                        mem[32] = 2
                        idx = idx + 1
                        continue 
            else:
                mem[_99 + 96] = _102
                _751 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_751] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_751 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _758 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_758] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_751 + 64] = _758
                    _759 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_759] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_759 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _759 + 32
                    t = sha3(mem[0])
                    while _759 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_751 + 96] = _759
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_758 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _758 + 32
                    t = sha3(mem[0])
                    while _758 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_751 + 64] = _758
                    _811 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_811] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_811 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _811 + 32
                    t = sha3(mem[0])
                    while _811 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_751 + 96] = _811
                mem[_99 + 128] = _751
                mem[_99 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _99
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
        _96 = mem[64]
        mem[mem[64]] = 32
        _101 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + (32 * mem[96]) + 64
        u = mem[64] + 64
        while idx < _101:
            mem[u] = t + -_96 - 64
            _184 = mem[s]
            require mem[mem[s]] < 2
            mem[t] = mem[mem[s]]
            require mem[_184 + 32] < 3
            mem[t + 32] = mem[_184 + 32]
            mem[t + 64] = mem[_184 + 76 len 20]
            _218 = mem[_184 + 96]
            mem[t + 96] = 192
            _222 = mem[_218]
            mem[t + 192] = mem[_218]
            v = 0
            w = _218 + 32
            x = t + 224
            while v < _222:
                require mem[w] < 3
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _261 = mem[_184 + 128]
            mem[t + 128] = (32 * _222) + 224
            require mem[_261] < 3
            mem[t + (32 * _222) + 224] = mem[_261]
            mem[t + (32 * _222) + 256] = mem[_261 + 32]
            _292 = mem[_261 + 64]
            mem[t + (32 * _222) + 288] = 128
            _294 = mem[_292]
            mem[t + (32 * _222) + 352] = mem[_292]
            v = 0
            w = _292 + 32
            x = t + (32 * _222) + 384
            while v < _294:
                mem[x] = mem[w + 12 len 20]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _340 = mem[_261 + 96]
            mem[t + (32 * _222) + 320] = (32 * _294) + 160
            _348 = mem[_340]
            mem[t + (32 * _222) + (32 * _294) + 384] = mem[_340]
            v = 0
            while _294 < _348:
                mem[t + (32 * _222) + (34 * _294) + 416] = mem[_340 + _294 + 32]
                v = _294 + 32
                continue 
            if _294 > _348:
                mem[t + (32 * _222) + (32 * _294) + _348 + 416] = 0
            mem[t + 160] = mem[_184 + 160]
            idx = idx + 1
            s = s + 32
            t = t + (32 * _222) + (32 * _294) + ceil32(_348) + 416
            u = u + 32
            continue 
    else:
        mem[(32 * stor2[address(arg1)]) + 128] = 0
        mem[(32 * stor2[address(arg1)]) + 160] = 0
        mem[(32 * stor2[address(arg1)]) + 192] = 0
        mem[(32 * stor2[address(arg1)]) + 224] = 96
        mem[64] = (32 * stor2[address(arg1)]) + 544
        mem[(32 * stor2[address(arg1)]) + 416] = 0
        mem[(32 * stor2[address(arg1)]) + 448] = 0
        mem[(32 * stor2[address(arg1)]) + 480] = 96
        mem[(32 * stor2[address(arg1)]) + 512] = 96
        mem[(32 * stor2[address(arg1)]) + 256] = (32 * stor2[address(arg1)]) + 416
        mem[(32 * stor2[address(arg1)]) + 288] = 0
        mem[var24002] = (32 * stor2[address(arg1)]) + 128
        s = (32 * stor2[address(arg1)]) + 128
        s = (32 * stor2[address(arg1)]) + 128
        s = var24002
        idx = var24003
        while idx - 1:
            _277 = mem[64]
            mem[64] = mem[64] + 288
            mem[_277] = 0
            mem[_277 + 32] = 0
            mem[_277 + 64] = 0
            mem[_277 + 96] = 96
            mem[64] = mem[64] + 128
            mem[(32 * stor2[address(arg1)]) + 416] = 0
            mem[(32 * stor2[address(arg1)]) + 448] = 0
            mem[(32 * stor2[address(arg1)]) + 480] = 96
            mem[(32 * stor2[address(arg1)]) + 512] = 96
            mem[_277 + 128] = (32 * stor2[address(arg1)]) + 416
            mem[_277 + 160] = 0
            mem[s + 32] = _277
            s = _277
            s = _277
            s = s + 32
            idx = idx - 1
            continue 
        mem[0] = arg1
        mem[32] = 2
        idx = 0
        while idx < stor2[address(arg1)]:
            mem[32] = 2
            require idx < stor2[address(arg1)]
            require stor2[address(arg1)][idx] < stor1.length
            mem[0] = 1
            _347 = mem[64]
            mem[64] = mem[64] + 192
            require uint8(stor1[stor2[address(arg1)][idx]].field_0) <= 1
            mem[_347] = uint8(stor1[stor2[address(arg1)][idx]].field_0)
            require uint8(stor1[stor2[address(arg1)][idx]].field_8) <= 2
            mem[_347 + 32] = uint8(stor1[stor2[address(arg1)][idx]].field_8)
            mem[_347 + 64] = address(stor1[stor2[address(arg1)][idx]].field_16)
            _354 = mem[64]
            mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) + 32
            mem[_354] = uint256(stor1[stor2[address(arg1)][idx]].field_256)
            if not uint256(stor1[stor2[address(arg1)][idx]].field_256):
                mem[_347 + 96] = _354
                _357 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_357] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_357 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _361 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_361] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_357 + 64] = _361
                    _364 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_364] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_364 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _364 + 32
                    t = sha3(mem[0])
                    while _364 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_357 + 96] = _364
                    mem[_347 + 128] = _357
                    mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = _347
                    mem[0] = arg1
                    mem[32] = 2
                    idx = idx + 1
                    continue 
                mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                mem[_361 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                s = _361 + 32
                t = sha3(mem[0])
                while _361 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                    mem[0] = arg1
                    mem[32] = 2
                    mem[s + 32] = address(stor1[t].field_0)
                    s = s + 32
                    t = t + 1
                    continue 
                mem[_357 + 64] = _361
                _449 = mem[64]
                mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                mem[_449] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                mem[_449 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                s = _449 + 32
                t = sha3(mem[0])
                while _449 + stor[(7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5].length > s:
                    mem[0] = arg1
                    mem[32] = 2
                    mem[s + 32] = uint256(stor1[t].field_0)
                    s = s + 32
                    t = t + 1
                    continue 
                mem[_357 + 96] = _449
                mem[_347 + 128] = _357
                mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][s]].field_1536)
                require s < mem[96]
                mem[(32 * s) + 128] = _347
                mem[0] = arg1
                mem[32] = 2
                s = s + 1
                continue 
            mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 1
            require storsha3((7 * stor[('array', ('var', 0), ('map', ('mask_shl', 160, 0, 96, ('param', 'arg1')), ('name', 'stor2', 2)))]) + ('name', 'stor1', 1) + 1)[var39002] <= 2
            mem[var41002] = var41001
            if _354 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var41002:
                mem[_347 + 96] = _354
                _456 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_456] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_456 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _461 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_461] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_456 + 64] = _461
                    _464 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_464] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_464 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _464 + 32
                    t = sha3(mem[0])
                    while _464 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_456 + 96] = _464
                    mem[_347 + 128] = _456
                    mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = _347
                    mem[0] = arg1
                    mem[32] = 2
                    idx = idx + 1
                    continue 
                mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                mem[_461 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                s = _461 + 32
                t = sha3(mem[0])
                while _461 + (32 * uint256(stor1[stor2[address(arg1)][s]].field_1024)) > s:
                    mem[0] = arg1
                    mem[32] = 2
                    mem[s + 32] = address(stor1[t].field_0)
                    s = s + 32
                    t = t + 1
                    continue 
                mem[_456 + 64] = _461
                _529 = mem[64]
                mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5].length) + 32
                mem[_529] = stor[(7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5].length
                mem[0] = (7 * stor2[address(arg1)][s]) + sha3(1) + 5
                mem[_529 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5)].field_0)
                t = _529 + 32
                u = sha3(mem[0])
                while _529 + stor[(7 * stor2[address(arg1)][s]) + ('name', 'stor1', 1) + 5].length > t:
                    mem[0] = arg1
                    mem[32] = 2
                    mem[t + 32] = uint256(stor1[u].field_0)
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_456 + 96] = _529
                mem[_347 + 128] = _456
                mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][s]].field_1536)
                require s < mem[96]
                mem[(32 * s) + 128] = _347
                mem[0] = arg1
                mem[32] = 2
                s = s + 1
                continue 
            require storvar43003[var43002] <= 2
            mem[var45002] = var45001
            if _354 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var45002:
                mem[_347 + 96] = _354
                _534 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_534] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_534 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _539 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_539] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_534 + 64] = _539
                    _541 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_541] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_541 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _541 + 32
                    t = sha3(mem[0])
                    while _541 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_534 + 96] = _541
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_539 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _539 + 32
                    t = sha3(mem[0])
                    while _539 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_534 + 64] = _539
                    _594 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_594] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_594 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _594 + 32
                    t = sha3(mem[0])
                    while _594 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_534 + 96] = _594
                mem[_347 + 128] = _534
                mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _347
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar47003[var47002] <= 2
            mem[var49002] = var49001
            if _354 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var49002:
                mem[_347 + 96] = _354
                _598 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_598] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_598 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _603 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_603] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_598 + 64] = _603
                    _605 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_605] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_605 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _605 + 32
                    t = sha3(mem[0])
                    while _605 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_598 + 96] = _605
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_603 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _603 + 32
                    t = sha3(mem[0])
                    while _603 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_598 + 64] = _603
                    _656 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_656] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_656 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _656 + 32
                    t = sha3(mem[0])
                    while _656 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_598 + 96] = _656
                mem[_347 + 128] = _598
                mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _347
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar51003[var51002] <= 2
            mem[var53002] = var53001
            if _354 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var53002:
                mem[_347 + 96] = _354
                _660 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_660] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_660 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _665 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_665] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_660 + 64] = _665
                    _667 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_667] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_667 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _667 + 32
                    t = sha3(mem[0])
                    while _667 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_660 + 96] = _667
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_665 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _665 + 32
                    t = sha3(mem[0])
                    while _665 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_660 + 64] = _665
                    _718 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_718] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_718 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _718 + 32
                    t = sha3(mem[0])
                    while _718 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_660 + 96] = _718
                mem[_347 + 128] = _660
                mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _347
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar55003[var55002] <= 2
            mem[var57002] = var57001
            if _354 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) <= var57002:
                mem[_347 + 96] = _354
                _722 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_722] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_722 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _727 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_727] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_722 + 64] = _727
                    _729 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_729] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_729 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _729 + 32
                    t = sha3(mem[0])
                    while _729 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_722 + 96] = _729
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_727 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _727 + 32
                    t = sha3(mem[0])
                    while _727 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_722 + 64] = _727
                    _780 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_780] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_780 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _780 + 32
                    t = sha3(mem[0])
                    while _780 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_722 + 96] = _780
                mem[_347 + 128] = _722
                mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _347
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
            require storvar59003[var59002] <= 2
            mem[var61002] = var61001
            if _354 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) > var61002:
                require storvar63003[var63002] <= 2
                mem[var65002] = var65001
                if _354 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_256)) > var65002:
                    require storvar67003[var67002] <= 2
                    # nil
                else:
                    mem[_347 + 96] = _354
                    _846 = mem[64]
                    mem[64] = mem[64] + 128
                    require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                    mem[_846] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                    mem[_846 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                    _851 = mem[64]
                    mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                    mem[_851] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                    if uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                        mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                        s = _851 + 32
                        t = sha3(mem[0])
                        while _851 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                            mem[0] = arg1
                            mem[32] = 2
                            mem[s + 32] = address(stor1[t].field_0)
                            s = s + 32
                            t = t + 1
                            continue 
                        # nil
                    else:
                        mem[_846 + 64] = _851
                        _853 = mem[64]
                        mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                        mem[_853] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                        mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                        mem[_853 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                        s = _853 + 32
                        t = sha3(mem[0])
                        while _853 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                            mem[0] = arg1
                            mem[32] = 2
                            mem[s + 32] = uint256(stor1[t].field_0)
                            s = s + 32
                            t = t + 1
                            continue 
                        mem[_846 + 96] = _853
                        mem[_347 + 128] = _846
                        mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                        require idx < mem[96]
                        mem[(32 * idx) + 128] = _347
                        mem[0] = arg1
                        mem[32] = 2
                        idx = idx + 1
                        continue 
            else:
                mem[_347 + 96] = _354
                _784 = mem[64]
                mem[64] = mem[64] + 128
                require uint8(stor1[stor2[address(arg1)][idx]].field_512) <= 2
                mem[_784] = uint8(stor1[stor2[address(arg1)][idx]].field_512)
                mem[_784 + 32] = uint256(stor1[stor2[address(arg1)][idx]].field_768)
                _789 = mem[64]
                mem[64] = mem[64] + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) + 32
                mem[_789] = uint256(stor1[stor2[address(arg1)][idx]].field_1024)
                if not uint256(stor1[stor2[address(arg1)][idx]].field_1024):
                    mem[_784 + 64] = _789
                    _791 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_791] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_791 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _791 + 32
                    t = sha3(mem[0])
                    while _791 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_784 + 96] = _791
                else:
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 4
                    mem[_789 + 32] = address(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 4)].field_0)
                    s = _789 + 32
                    t = sha3(mem[0])
                    while _789 + (32 * uint256(stor1[stor2[address(arg1)][idx]].field_1024)) > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = address(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_784 + 64] = _789
                    _842 = mem[64]
                    mem[64] = mem[64] + ceil32(stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length) + 32
                    mem[_842] = stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length
                    mem[0] = (7 * stor2[address(arg1)][idx]) + sha3(1) + 5
                    mem[_842 + 32] = uint256(stor[sha3((7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5)].field_0)
                    s = _842 + 32
                    t = sha3(mem[0])
                    while _842 + stor[(7 * stor2[address(arg1)][idx]) + ('name', 'stor1', 1) + 5].length > s:
                        mem[0] = arg1
                        mem[32] = 2
                        mem[s + 32] = uint256(stor1[t].field_0)
                        s = s + 32
                        t = t + 1
                        continue 
                    mem[_784 + 96] = _842
                mem[_347 + 128] = _784
                mem[_347 + 160] = uint256(stor1[stor2[address(arg1)][idx]].field_1536)
                require idx < mem[96]
                mem[(32 * idx) + 128] = _347
                mem[0] = arg1
                mem[32] = 2
                idx = idx + 1
                continue 
        _343 = mem[64]
        mem[mem[64]] = 32
        _350 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + (32 * mem[96]) + 64
        u = mem[64] + 64
        while idx < _350:
            mem[u] = t + -_343 - 64
            _400 = mem[s]
            require mem[mem[s]] < 2
            mem[t] = mem[mem[s]]
            require mem[_400 + 32] < 3
            mem[t + 32] = mem[_400 + 32]
            mem[t + 64] = mem[_400 + 76 len 20]
            _435 = mem[_400 + 96]
            mem[t + 96] = 192
            _436 = mem[_435]
            mem[t + 192] = mem[_435]
            v = 0
            w = _435 + 32
            x = t + 224
            while v < _436:
                require mem[w] < 3
                mem[x] = mem[w]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _454 = mem[_400 + 128]
            mem[t + 128] = (32 * _436) + 224
            require mem[_454] < 3
            mem[t + (32 * _436) + 224] = mem[_454]
            mem[t + (32 * _436) + 256] = mem[_454 + 32]
            _484 = mem[_454 + 64]
            mem[t + (32 * _436) + 288] = 128
            _485 = mem[_484]
            mem[t + (32 * _436) + 352] = mem[_484]
            v = 0
            w = _484 + 32
            x = t + (32 * _436) + 384
            while v < _485:
                mem[x] = mem[w + 12 len 20]
                v = v + 1
                w = w + 32
                x = x + 32
                continue 
            _497 = mem[_454 + 96]
            mem[t + (32 * _436) + 320] = (32 * _485) + 160
            _504 = mem[_497]
            mem[t + (32 * _436) + (32 * _485) + 384] = mem[_497]
            v = 0
            while _485 < _504:
                mem[t + (32 * _436) + (34 * _485) + 416] = mem[_497 + _485 + 32]
                v = _485 + 32
                continue 
            if _485 > _504:
                mem[t + (32 * _436) + (32 * _485) + _504 + 416] = 0
            mem[t + 160] = mem[_400 + 160]
            idx = idx + 1
            s = s + 32
            t = t + (32 * _436) + (32 * _485) + ceil32(_504) + 416
            u = u + 32
            continue 
    return memory
      from mem[64]
       len t - mem[64]
}



}
