contract main {


// =======================  Init code  ======================


uint8 stor1;

function _fallback() payable {
    stor1 = 6
    return code.data[31 len 605]
}



// =====================  Runtime code  =====================


array of uint256 stor0;
uint8 stor1;

function numbers(uint256 arg1) payable {
    require arg1 < stor0.length
    return numbers[uint8(arg1)]
}

function _fallback() payable {
  stop
}

function sub_bbbe9eae(?) payable {
    stor0.length = 0
    if not stor0.length <= 0:
        idx = 0
        while stor0.length + 31 / 32 > idx:
            stor0[idx] = 0
            idx = idx + 1
            continue 
    mem[128] = 32
    idx = 0
    s = 0
    while idx < 128:
        mem[1184] = block.timestamp
        mem[1216] = address(msg.sender)
        require sha3(block.timestamp, msg.sender) % 32 < mem[128]
        if 1 == mem[(32 * sha3(block.timestamp, msg.sender) % 32) + 191 len 1]:
            idx = idx + 1
            s = sha3(block.timestamp, msg.sender) % 32
            continue 
        require sha3(block.timestamp, msg.sender) % 32 < mem[128]
        mem[(32 * sha3(block.timestamp, msg.sender) % 32) + 160] = 1
        stor0.length++
        if not stor0.length <= stor0.length + 1:
            s = sha3(0) + (stor0.length + 32 / 32)
            while sha3(0) + (stor0.length + 31 / 32) > s:
                stor[s] = 0
                s = s + 1
                continue 
        require idx < stor0.length
        mem[0] = 0
        stor0[0.03125 / idx] = stor0[0.03125 / idx] and !(255 * 256^(idx % 32)) or 256^(idx % 32) * sha3(block.timestamp, msg.sender) % 32
        if stor1 != stor0.length:
            idx = idx + 1
            s = sha3(block.timestamp, msg.sender) % 32
            continue 
}



}
