contract main {


// =======================  Init code  ======================


uint256 stor0;

function _fallback() payable {
    stor0 = block.number
    return code.data[23 len 1501]
}



// =====================  Runtime code  =====================


const sub_a294958b(?) = (block.number % 106)


uint256 lastBlock;
uint256 balance;
array of address stor2;
array of address stor3;
array of uint256 stor4;
mapping of uint256 stor5;
mapping of uint256 stor6;
array of uint256 stor244195351119558707450353757054056973961249211228784034861653245303651003344;
array of uint256 stor29102676481673041902632991033461445430619272659676223336789171408008386403021;

function tickets(uint256 arg1) payable {
    require arg1 < stor3.length
    return address(stor[code.data[1469 len 32] + arg1])
}

function lastBlock() payable {
    return lastBlock
}

function balance() payable {
    return balance
}

function _fallback() payable {
  stop
}

function sub_2168129d(?) payable {
    return sha3(arg1)
}

function payoutReady() payable {
    if block.number % 106 <= 76:
        return (block.number % 106 > 76)
    return (block.number - lastBlock > 68)
}

function buyTicket(uint256 arg1) payable {
    if block.number % 106 < 40:
        stor5[address(msg.sender)] = arg1
        stor6[address(msg.sender)] += msg.value
        balance += msg.value
        stor2.length++
        if not stor2.length <= stor2.length + 1:
            idx = stor2.length + 1
            while stor2.length > idx:
                uint256(stor2[idx]) = 0
                idx = idx + 1
                continue 
        require stor2.length - 1 < stor2.length
        stor4057[stor2.length] = msg.sender or Mask(96, 160, stor4057[stor2.length])
}

function random() payable {
    idx = 0
    s = 0
    while idx < stor4.length:
        mem[0] = 4
        idx = idx + 1
        s = s xor stor4[idx]
        continue 
    return uint16(s * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length % stor3.length)
}

function sub_7c1c1716(?) payable {
    if block.number % 106 < 76:
        if block.number % 106 > 46:
            if sha3(arg1) == stor5[address(msg.sender)]:
                stor4.length++
                if not stor4.length <= stor4.length + 1:
                    idx = stor4.length + 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd2
                    while stor4.length + 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1 > idx:
                        uint256(stor[idx]) = 0
                        idx = idx + 1
                        continue 
                require stor4.length - 1 < stor4.length
                stor8A35[stor4.length] = arg1
                idx = 0
                while uint32(idx) < stor6[address(msg.sender)] / 10^18:
                    stor3.length++
                    if not stor3.length <= stor3.length + 1:
                        s = stor3.length + code.data[1469 len 32] + 1
                        while code.data[1469 len 32] + stor3.length > s:
                            uint256(stor[s]) = 0
                            mem[0] = msg.sender
                            mem[32] = 6
                            s = s + 1
                            continue 
                    require stor3.length - 1 < stor3.length
                    uint256(stor[code.data[1469 len 32] + stor3.length - 1]) = msg.sender or Mask(96, 160, uint256(stor[code.data[1469 len 32] + stor3.length - 1]))
                    mem[0] = msg.sender
                    mem[32] = 6
                    idx = idx + 1
                    continue 
}

function payout() payable {
    if block.number % 106 <= 76:
        return 0
    if block.number - lastBlock <= 68:
        return 0
    idx = 0
    s = 0
    while idx < stor4.length:
        mem[0] = 4
        idx = idx + 1
        s = s xor stor4[idx]
        continue 
    require uint16(s * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length % stor3.length) < stor3.length
    call stor3[uint16(s * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length % stor3.length)] with:
       value balance - (25000 * block.gasprice) wei
         gas 0 wei
    lastBlock = block.number
    stor4.length = 0
    idx = 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1
    while stor4.length + 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1 > idx:
        uint256(stor[idx]) = 0
        idx = idx + 1
        continue 
    balance = 0
    idx = 0
    while idx < stor2.length:
        stor5[address(stor2[idx])] = 0
        mem[0] = address(stor2[idx])
        mem[32] = 6
        stor6[address(stor2[idx])] = 0
        idx = idx + 1
        continue 
    stor3.length = 0
    idx = code.data[1469 len 32]
    while code.data[1469 len 32] + stor3.length > idx:
        uint256(stor[idx]) = 0
        idx = idx + 1
        continue 
    return stor3[uint16(s * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length % stor3.length)]
}



}
