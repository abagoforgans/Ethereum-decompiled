contract main {


// =======================  Init code  ======================


uint256 stor0;
uint256 stor1;

function _fallback() payable {
    stor0 = block.number
    stor1 = msg.sender or Mask(96, 160, stor1)
    return code.data[41 len 1451]
}



// =====================  Runtime code  =====================


uint256 lastBlock;
address stor1;
uint256 balance;
array of address stor3;
array of uint256 secrets;
mapping of uint256 sub_6ac2da19;
mapping of uint256 balances;
array of uint256 stor244195351119558707450353757054056973961249211228784034861653245303651003344;

function balances(address arg1) payable {
    return balances[arg1]
}

function tickets(uint256 arg1) payable {
    require arg1 < stor3.length
    return address(stor[code.data[1419 len 32] + arg1])
}

function sub_6ac2da19(?) payable {
    return sub_6ac2da19[arg1]
}

function lastBlock() payable {
    return lastBlock
}

function balance() payable {
    return balance
}

function secrets(uint256 arg1) payable {
    require arg1 < secrets.length
    return secrets[arg1]
}

function die() payable {
    if stor1 != msg.sender:
    selfdestruct(stor1)
}

function _fallback() payable {
  stop
}

function sub_2168129d(?) payable {
    return sha3(arg1)
}

function payoutReady() payable {
    if block.number % 88 <= 68:
        return (block.number % 88 > 68)
    return (block.number - lastBlock > 68)
}

function buyTicket(uint256 arg1) payable {
    if block.number % 88 < 40:
        sub_6ac2da19[address(msg.sender)] = arg1
        balances[address(msg.sender)] += msg.value
        balance += msg.value
}

function sub_7c1c1716(?) payable {
    if block.number % 88 < 68:
        if block.number % 88 > 48:
            if sha3(arg1) == sub_6ac2da19[address(msg.sender)]:
                secrets.length++
                if not secrets.length <= secrets.length + 1:
                    idx = secrets.length + 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd2
                    while secrets.length + 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1 > idx:
                        uint256(stor[idx]) = 0
                        idx = idx + 1
                        continue 
                require secrets.length - 1 < secrets.length
                stor8A35[stor4.length] = arg1
                idx = 0
                while uint32(idx) < msg.value / 10^17:
                    stor3.length++
                    if not stor3.length <= stor3.length + 1:
                        s = stor3.length + code.data[1419 len 32] + 1
                        while code.data[1419 len 32] + stor3.length > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    require stor3.length - 1 < stor3.length
                    mem[0] = 3
                    uint256(stor[code.data[1419 len 32] + stor3.length - 1]) = msg.sender or Mask(96, 160, uint256(stor[code.data[1419 len 32] + stor3.length - 1]))
                    idx = idx + 1
                    continue 
}

function random() payable {
    idx = 0
    s = 0
    while idx < secrets.length:
        mem[0] = 4
        idx = idx + 1
        s = s xor secrets[idx]
        continue 
    return uint16(s * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length % stor3.length)
}

function payout() payable {
    if block.number % 88 <= 68:
        return 0
    if block.number - lastBlock <= 68:
        return 0
    idx = 0
    s = 0
    while idx < secrets.length:
        mem[0] = 4
        idx = idx + 1
        s = s xor secrets[idx]
        continue 
    require uint16(s * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length * secrets.length % stor3.length) < stor3.length
    call stor3[uint16(s * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length % stor3.length)] with:
       value balance - (25000 * block.gasprice) wei
         gas 0 wei
    lastBlock = block.number
    stor3.length = 0
    idx = code.data[1419 len 32]
    while code.data[1419 len 32] + stor3.length > idx:
        uint256(stor[idx]) = 0
        idx = idx + 1
        continue 
    secrets.length = 0
    idx = 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1
    while secrets.length + 0x8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd1 > idx:
        uint256(stor[idx]) = 0
        idx = idx + 1
        continue 
    balance = 0
    idx = 0
    while idx < stor3.length:
        sub_6ac2da19[address(stor[code.data[1419 len 32] + idx])] = 0
        mem[0] = address(stor[code.data[1419 len 32] + idx])
        mem[32] = 6
        balances[address(stor[code.data[1419 len 32] + idx])] = 0
        idx = idx + 1
        continue 
    return stor3[uint16(s * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length * stor4.length % stor3.length)]
}



}
