contract main {


// =======================  Init code  ======================


uint256 stor1;
uint256 stor3;

function _fallback() payable {
    stor1 = msg.sender or Mask(96, 160, stor1)
    stor3 = 0
    return code.data[41 len 719]
}



// =====================  Runtime code  =====================


address stor0;
uint256 stor0;
address stor1;
array of struct stor2;
uint256 stor3;

function kill() payable {
    if stor1 != msg.sender:
    selfdestruct(stor1)
}

function _fallback() payable {
  stop
}

function sub_42bbc2c5(?) payable {
    require msg.sender == stor1
    uint256(stor0) = arg1 or Mask(96, 160, uint256(stor0))
    stor3 = 1
}

function sub_c6b13081(?) payable {
    stor3 = 1
    mem[160] = uint256(stor2.field_0)
    idx = 160
    s = 0
    while stor2.length + 160 > idx + 32:
        mem[idx + 32] = stor2[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return Array(len=stor2.length, data=mem[160 len stor2.length])
}

function sub_5b6b6baf(?) payable {
    mem[128 len arg1.length] = arg1[all]
    require address(stor0) == msg.sender
    stor2.length = (2 * arg1.length) + 1
    s = 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace
    idx = 128
    while arg1.length + 128 > idx:
        stor[s] = mem[idx]
        s = s + 1
        idx = idx + 32
        continue 
    idx = (Mask(251, 0, arg1.length + 31) >> 5) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace
    while (stor2.length + 31 / 32) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace > idx:
        stor[idx] = 0
        idx = idx + 1
        continue 
    stor3 = 0
}



}
