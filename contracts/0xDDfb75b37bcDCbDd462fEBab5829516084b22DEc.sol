contract main {


// =======================  Init code  ======================


const _fallback = code.data[18 len 764]




// =====================  Runtime code  =====================


mapping of struct stor0;
array of uint8 stor1;

function _fallback() payable {
  stop
}

function sub_b4b94616(?) payable {
    idx = 1120
    s = 0
    while 2144 > idx + 32:
        mem[idx + 32] = stor1[-(0.03125 / s + 1) + s + (-1 * 0.03125 / s + 1 * s) + 1]
        idx = idx + 32
        s = -(s + 1 / 32) + s + (-1 * s + 1 / 32 * s) + 1
        continue 
    return stor0[address(arg1)].field_0, uint8(stor0[address(arg1)].field_256), mem[1152 len 992]
}

function sub_98974b03(?) payable {
    mem[96 len 1024] = call.data[4 len 1024]
    mem[1120] = block.timestamp
    stor0[address(msg.sender)].field_0 = block.timestamp
    s = 0
    idx = 96
    while 1120 > idx:
        stor0[address(msg.sender)].field_256 = mem[idx] * 256^s or !(255 * 256^s) and stor0[address(msg.sender)].field_256
        s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1
        idx = idx + 32
        continue 
    idx = 32
    s = sha3(address(msg.sender), 0) + 1
    while idx:
        stor[s] = !(255 * 256^idx) and stor[s]
        idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1
        s = (idx + 1 / 32) + s
        continue 
    idx = (-30 * None + 3 / 32) + (None * None + 3 / 32) + 1
    while 2 > idx:
        uint8(stor0[address(msg.sender)][idx].field_0) = 0
        idx = idx + 1
        continue 
}



}
