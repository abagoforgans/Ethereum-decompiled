contract main {




// =====================  Runtime code  =====================


const name = 'Six Degress Unlimited'

const symbol = ''


uint256 stor0;
uint256 stor1;
uint256 stor2;
array of uint256 stor3;
mapping of uint256 stor4;
uint8 activated_;
uint256 stor6;
uint256 stor7;
mapping of struct plyr_;
array of uint256 sub_8338d556;
mapping of struct sub_e5b3f6f2;
array of struct stor11;
mapping of uint256 sub_cc5c8117;
mapping of uint256 sub_d705f265;

function sub_8338d556(?) {
    require calldata.size - 4 >= 64
    require arg2 < sub_8338d556[arg1]
    return sub_8338d556[arg1][arg2]
}

function sub_cc5c8117(?) {
    require calldata.size - 4 >= 32
    return sub_cc5c8117[arg1]
}

function activated_() {
    return bool(activated_)
}

function sub_d705f265(?) {
    require calldata.size - 4 >= 32
    return sub_d705f265[arg1]
}

function plyr_(uint256 arg1) {
    require calldata.size - 4 >= 32
    return plyr_[arg1].field_0, 
           plyr_[arg1].field_256,
           uint8(plyr_[arg1].field_512),
           address(plyr_[arg1].field_512),
           plyr_[arg1].field_768
}

function sub_e5b3f6f2(?) {
    require calldata.size - 4 >= 32
    return sub_e5b3f6f2[arg1].field_0, sub_e5b3f6f2[arg1].field_256
}

function sub_89f5e47d(?) {
    return stor0, stor1, stor2
}

function _fallback() payable {
    if bool(activated_) != 1:
        revert with 0, 'sixdegrees is not ready yet'
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
}

function sub_da47f03d(?) {
    if bool(activated_) != 1:
        revert with 0, 'sixdegrees is not ready yet'
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    sub_d705f265[msg.sender] = 0
}

function sub_4063bb7a(?) {
    require calldata.size - 4 >= 32
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
    staticcall 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.isDev(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if bool(ext_call.return_data[0]) != 1:
        revert with 0, 32, 23, 0xfe6d73672073656e646572206973206e6f742061206465760000000000000000
    stor7 = arg1
}

function sub_0654d097(?) {
    require calldata.size - 4 >= 64
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
    staticcall 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.isDev(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if bool(ext_call.return_data[0]) != 1:
        revert with 0, 32, 23, 0xfe6d73672073656e646572206973206e6f742061206465760000000000000000
    sub_d705f265[address(arg1)] = arg2
}

function sub_b9bbc5db(?) {
    require calldata.size - 4 >= 64
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
    staticcall 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.isDev(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if bool(ext_call.return_data[0]) != 1:
        revert with 0, 32, 23, 0xfe6d73672073656e646572206973206e6f742061206465760000000000000000
    sub_cc5c8117[address(arg1)] = arg2
}

function activate() {
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
    staticcall 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.isDev(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if bool(ext_call.return_data[0]) != 1:
        revert with 0, 32, 23, 0xfe6d73672073656e646572206973206e6f742061206465760000000000000000
    if activated_:
        revert with 0, 'Six Degrees already activated'
    activated_ = 1
}

function pause() {
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
    staticcall 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.isDev(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if bool(ext_call.return_data[0]) != 1:
        revert with 0, 32, 23, 0xfe6d73672073656e646572206973206e6f742061206465760000000000000000
    if bool(activated_) != 1:
        revert with 0, 'Six Degrees is paused'
    activated_ = 0
}

function sub_a840f10b(?) {
    require calldata.size - 4 >= 32
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
    staticcall 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.isDev(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if bool(ext_call.return_data[0]) != 1:
        revert with 0, 32, 23, 0xfe6d73672073656e646572206973206e6f742061206465760000000000000000
    if arg1 > eth.balance(this.address):
        revert with 0, 'sorry out amount'
    if arg1 + stor2 < stor2:
        revert with 0, 'SafeMath add failed'
    stor2 += arg1
    call msg.sender with:
       value arg1 wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit WithDraw(arg1, block.timestamp, msg.sender);
}

function sub_92cf3791(?) {
    require calldata.size - 4 >= 32
    if bool(activated_) != 1:
        revert with 0, 'sixdegrees is not ready yet'
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    if arg1 != msg.sender:
        if not sub_d705f265[address(arg1)]:
            revert with 0, 'sorry pID is incorrect'
        if sub_d705f265[address(arg1)] != sub_cc5c8117[msg.sender]:
            revert with 0, 'sorry pID is incorrect'
    if sub_e5b3f6f2[address(arg1)].field_256 + sub_e5b3f6f2[address(arg1)].field_0 < sub_e5b3f6f2[address(arg1)].field_0:
        revert with 0, 'SafeMath add failed'
    if sub_e5b3f6f2[address(arg1)].field_256 + sub_e5b3f6f2[address(arg1)].field_0 > eth.balance(this.address):
        revert with 0, 'sorry amount error'
    if sub_e5b3f6f2[address(arg1)].field_256 + sub_e5b3f6f2[address(arg1)].field_0 < stor7:
        revert with 0, 'sorry amount error'
    if sub_e5b3f6f2[address(arg1)].field_256 + sub_e5b3f6f2[address(arg1)].field_0:
        sub_e5b3f6f2[address(arg1)].field_0 = 0
        sub_e5b3f6f2[address(arg1)].field_256 = 0
        if sub_e5b3f6f2[address(arg1)].field_256 + sub_e5b3f6f2[address(arg1)].field_0 + stor2 < stor2:
            revert with 0, 'SafeMath add failed'
        stor2 = sub_e5b3f6f2[address(arg1)].field_256 + sub_e5b3f6f2[address(arg1)].field_0 + stor2
        call arg1 with:
           value sub_e5b3f6f2[address(arg1)].field_256 + sub_e5b3f6f2[address(arg1)].field_0 wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        emit WithDraw(sub_e5b3f6f2[address(arg1)].field_256 + sub_e5b3f6f2[address(arg1)].field_0, block.timestamp, arg1);
}

function sub_ae4de348(?) payable {
    require calldata.size - 4 >= 96
    if bool(activated_) != 1:
        revert with 0, 'sixdegrees is not ready yet'
    if ext_code.size(msg.sender):
        revert with 0, 'sorry humans only'
    if msg.sender == arg1:
        sub_d705f265[address(arg1)] = 1
        stor6++
        mem[96] = 0
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        if not plyr_[arg2].field_256:
            if not stor3[arg3 << 248]:
                if 0 >= msg.value:
                    revert with 0, 'sorry ether or rID is incorrect'
                if msg.value != 0:
                    revert with 0, 'sorry ether or rID is incorrect'
                plyr_[stor6].field_0 = plyr_[arg2].field_256
                plyr_[stor6].field_256 = stor6
                uint8(plyr_[stor6].field_512) = 0
                address(plyr_[stor6].field_520) = arg1
                plyr_[stor6].field_768 % 1 = 0
                plyr_[stor6].field_768 = 0
                sub_8338d556[address(arg1)]++
                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                if stor0 < stor0:
                    revert with 0, 'SafeMath add failed'
            else:
                if 2 * stor3[arg3 << 248] / stor3[arg3 << 248] != 2:
                    revert with 0, 'SafeMath mul failed'
                if 0 >= msg.value:
                    revert with 0, 'sorry ether or rID is incorrect'
                if 2 * stor3[arg3 << 248] != msg.value:
                    revert with 0, 'sorry ether or rID is incorrect'
                plyr_[stor6].field_0 = plyr_[arg2].field_256
                plyr_[stor6].field_256 = stor6
                uint8(plyr_[stor6].field_512) = 0
                address(plyr_[stor6].field_520) = arg1
                plyr_[stor6].field_768 % 1 = 0
                plyr_[stor6].field_768 = 0
                sub_8338d556[address(arg1)]++
                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                if (2 * stor3[arg3 << 248]) + stor0 < stor0:
                    revert with 0, 'SafeMath add failed'
                stor0 += 2 * stor3[arg3 << 248]
            stor1++
            if not stor3[arg3 << 248] / 100:
                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                     gas gas_remaining wei
            else:
                if 23 * stor3[arg3 << 248] / 100 / stor3[arg3 << 248] / 100 != 23:
                    revert with 0, 'SafeMath mul failed'
                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                   value 23 * stor3[arg3 << 248] / 100 wei
                     gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            emit 0xb632245f: arg3 << 248, block.timestamp, stor6, arg1
        else:
            mem[256 len 192] = code.data[6945 len 192]
            mem[64] = 640
            mem[448] = plyr_[arg2].field_256
            mem[480] = stor11[stor8[arg2].field_256].field_0
            mem[512] = stor11[stor8[arg2].field_256].field_256
            mem[544] = stor11[stor8[arg2].field_256].field_512
            mem[576] = stor11[stor8[arg2].field_256].field_768
            mem[608] = stor11[stor8[arg2].field_256].field_1024
            mem[0] = plyr_[arg2].field_256
            mem[32] = 8
            if var44001 <= 6:
                s = var44001
                t = var44003
                while uint8(var51002) < uint8(-var51001 + 6):
                    require uint8(var53001) < 6
                    if not mem[(32 * var55001) + 448]:
                        if not var39001:
                            mem[0] = plyr_[arg2].field_256
                            mem[32] = 8
                            s = var39002
                            while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                    if uint8(s + 1) >= 5:
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    if mem[(32 * uint8(s + 1)) + 448]:
                                        require uint8(s + 1) < 6
                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                revert with 0, 'SafeMath add failed'
                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    _47557 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    mem[mem[64] + 32] = stor3[_47557]
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47557], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    _47847 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    mem[mem[64] + 32] = stor3[_47847]
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47847], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                else:
                                    if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                        if uint8(s + 1) >= 4:
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        if mem[(32 * uint8(s + 1)) + 448]:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                    revert with 0, 'SafeMath add failed'
                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _47843 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_47843]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47843], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _48155 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_48155]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_48155], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    else:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                            if uint8(s + 1) >= 3:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _48151 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_48151]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_48151], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _48548 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_48548]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_48548], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                if uint8(s + 1) >= 1:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48143 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48143]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48143], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48538 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48538]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48538], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            else:
                                                if uint8(s + 1) >= 2:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48544 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48544]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48544], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48913 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48913]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48913], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                s = s + 1
                                continue 
                            s = plyr_[plyr_[arg2].field_256].field_768
                            t = s + 1
                            continue 
                        require uint8(var59001) < 6
                        _55226 = mem[(32 * uint8(var59001)) + 448]
                        mem[0] = mem[(32 * uint8(var59001)) + 448]
                        mem[32] = 8
                        _55260 = sha3(mem[(32 * uint8(var59001)) + 448], 8)
                        s = uint8(var59001)
                        t = var59001
                        while stor3[_55260] + 1 >= stor3[_55260]:
                            plyr_[_55226].field_768 = stor3[_55260] + 1
                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55226].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55226].field_512)].field_0:
                                revert with 0, 'SafeMath add failed'
                            sub_e5b3f6f2[address(stor8[_55226].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                            if not stor4[stor8[_55226].field_768]:
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                u = t
                                while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                    if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                        if uint8(u + 1) < 5:
                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = uint8(u + 1)
                                            t = u + 1
                                            continue 
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                    else:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                            if uint8(u + 1) < 4:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                if uint8(u + 1) < 3:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                    if uint8(u + 1) < 1:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                else:
                                                    if uint8(u + 1) < 2:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    t = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[t] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        t = t + 1
                                                        idx = idx + 32
                                                        continue 
                                    idx = sha3(mem[0 len 64]) + 6
                                    while sha3(stor6, 11) + 6 > idx:
                                        stor[idx] = 0
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        idx = idx + 1
                                        continue 
                                    if 0 >= msg.value:
                                        revert with 0, 'sorry ether or rID is incorrect'
                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                        revert with 0, 'sorry ether or rID is incorrect'
                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                    plyr_[stor6].field_256 = stor6
                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                    address(plyr_[stor6].field_520) = arg1
                                    plyr_[stor6].field_768 = mem[224]
                                    sub_8338d556[address(arg1)]++
                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                        revert with 0, 'SafeMath add failed'
                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                    stor1++
                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                             gas gas_remaining wei
                                    else:
                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                            revert with 0, 'SafeMath mul failed'
                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                             gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                            else:
                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                    mem[0] = address(plyr_[_55226].field_520)
                                    if sub_e5b3f6f2[address(stor8[_55226].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55226].field_512)].field_256:
                                        revert with 0, 'SafeMath add failed'
                                    mem[32] = 8
                                    mem[mem[64]] = address(plyr_[_55226].field_520)
                                    mem[mem[64] + 32] = plyr_[_55226].field_768
                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                    mem[mem[64] + 96] = block.timestamp
                                    emit 0x72825d8b: address(plyr_[_55226].field_512), plyr_[_55226].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    u = t
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(u + 1) < 5:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(u + 1) < 4:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(u + 1) < 3:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(u + 1) < 1:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if uint8(u + 1) < 2:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    mem[0] = mem[(32 * u) + 448]
                                    mem[32] = 8
                                    u = plyr_[plyr_[arg2].field_256].field_768
                                    t = u + 1
                                    continue 
                                if stor4[stor8[_55226].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55226].field_768]:
                                    revert with 0, 'SafeMath mul failed'
                                mem[0] = address(plyr_[_55226].field_520)
                                if (stor4[stor8[_55226].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55226].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55226].field_512)].field_256:
                                    revert with 0, 'SafeMath add failed'
                                sub_e5b3f6f2[address(stor8[_55226].field_512)].field_256 += stor4[stor8[_55226].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                mem[32] = 8
                                mem[mem[64]] = address(plyr_[_55226].field_520)
                                mem[mem[64] + 32] = plyr_[_55226].field_768
                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                mem[mem[64] + 96] = block.timestamp
                                emit 0x72825d8b: address(plyr_[_55226].field_512), plyr_[_55226].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                u = t
                                while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                    if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                        if uint8(u + 1) < 5:
                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = uint8(u + 1)
                                            t = u + 1
                                            continue 
                                    else:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                            if uint8(u + 1) < 4:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                if uint8(u + 1) < 3:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                    if uint8(u + 1) < 1:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if uint8(u + 1) < 2:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                    mem[0] = stor6
                                    mem[32] = 11
                                    s = sha3(mem[0 len 64])
                                    idx = 448
                                    while 640 > idx:
                                        stor[s] = mem[idx]
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(mem[0 len 64]) + 6
                                    while sha3(stor6, 11) + 6 > idx:
                                        stor[idx] = 0
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        idx = idx + 1
                                        continue 
                                    if 0 >= msg.value:
                                        revert with 0, 'sorry ether or rID is incorrect'
                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                        revert with 0, 'sorry ether or rID is incorrect'
                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                    plyr_[stor6].field_256 = stor6
                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                    address(plyr_[stor6].field_520) = arg1
                                    plyr_[stor6].field_768 = mem[224]
                                    sub_8338d556[address(arg1)]++
                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                        revert with 0, 'SafeMath add failed'
                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                    stor1++
                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                             gas gas_remaining wei
                                    else:
                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                            revert with 0, 'SafeMath mul failed'
                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                             gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                            mem[0] = mem[(32 * s) + 448]
                            mem[32] = 8
                            s = plyr_[plyr_[arg2].field_256].field_768
                            t = u + 1
                            continue 
                    else:
                        require uint8(var57002) < 6
                        if not var61001:
                            mem[0] = plyr_[arg2].field_256
                            mem[32] = 8
                            t = var61002
                            while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                    if uint8(t + 1) >= 5:
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    if mem[(32 * uint8(t + 1)) + 448]:
                                        require uint8(t + 1) < 6
                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                            require uint8(t + 1) < 6
                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                revert with 0, 'SafeMath add failed'
                                            plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    _74001 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                    mem[mem[64] + 32] = stor3[_74001]
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: mem[mem[64]], stor3[_74001], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                    if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    _74212 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                    mem[mem[64] + 32] = stor3[_74212]
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: mem[mem[64]], stor3[_74212], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                else:
                                    if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                        if uint8(t + 1) >= 4:
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        if mem[(32 * uint8(t + 1)) + 448]:
                                            require uint8(t + 1) < 6
                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                require uint8(t + 1) < 6
                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                    revert with 0, 'SafeMath add failed'
                                                plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _74208 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_74208]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74208], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                        if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _74484 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_74484]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74484], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    else:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                            if uint8(t + 1) >= 3:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(t + 1)) + 448]:
                                                require uint8(t + 1) < 6
                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74480 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74480]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74480], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74954 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74954]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74954], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                if uint8(t + 1) >= 1:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(t + 1)) + 448]:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74472 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74472]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74472], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74944 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74944]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74944], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            else:
                                                if uint8(t + 1) >= 2:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(t + 1)) + 448]:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74950 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74950]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74950], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _75297 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_75297]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_75297], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                t = t + 1
                                continue 
                            s = plyr_[plyr_[arg2].field_256].field_768
                            t = t + 1
                            continue 
                        require uint8(var63001) < 6
                        _78970 = mem[(32 * uint8(var63001)) + 448]
                        mem[0] = mem[(32 * uint8(var63001)) + 448]
                        mem[32] = 8
                        _79029 = sha3(mem[(32 * uint8(var63001)) + 448], 8)
                        s = uint8(var63001)
                        t = var63001
                        while stor3[_79029] + 1 >= stor3[_79029]:
                            plyr_[_78970].field_768 = stor3[_79029] + 1
                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78970].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78970].field_512)].field_0:
                                revert with 0, 'SafeMath add failed'
                            sub_e5b3f6f2[address(stor8[_78970].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                            if not stor4[stor8[_78970].field_768]:
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                u = t
                                while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                    if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                        if uint8(u + 1) < 5:
                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = uint8(u + 1)
                                            t = u + 1
                                            continue 
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                    else:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                            if uint8(u + 1) < 4:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                if uint8(u + 1) < 3:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                    if uint8(u + 1) < 1:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                else:
                                                    if uint8(u + 1) < 2:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    t = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[t] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        t = t + 1
                                                        idx = idx + 32
                                                        continue 
                                    idx = sha3(mem[0 len 64]) + 6
                                    while sha3(stor6, 11) + 6 > idx:
                                        stor[idx] = 0
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        idx = idx + 1
                                        continue 
                                    if 0 >= msg.value:
                                        revert with 0, 'sorry ether or rID is incorrect'
                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                        revert with 0, 'sorry ether or rID is incorrect'
                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                    plyr_[stor6].field_256 = stor6
                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                    address(plyr_[stor6].field_520) = arg1
                                    plyr_[stor6].field_768 = mem[224]
                                    sub_8338d556[address(arg1)]++
                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                        revert with 0, 'SafeMath add failed'
                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                    stor1++
                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                             gas gas_remaining wei
                                    else:
                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                            revert with 0, 'SafeMath mul failed'
                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                             gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                            else:
                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                    mem[0] = address(plyr_[_78970].field_520)
                                    if sub_e5b3f6f2[address(stor8[_78970].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78970].field_512)].field_256:
                                        revert with 0, 'SafeMath add failed'
                                    mem[32] = 8
                                    mem[mem[64]] = address(plyr_[_78970].field_520)
                                    mem[mem[64] + 32] = plyr_[_78970].field_768
                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                    mem[mem[64] + 96] = block.timestamp
                                    emit 0x72825d8b: address(plyr_[_78970].field_512), plyr_[_78970].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    u = t
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(u + 1) < 5:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(u + 1) < 4:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(u + 1) < 3:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(u + 1) < 1:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if uint8(u + 1) < 2:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    mem[0] = mem[(32 * u) + 448]
                                    mem[32] = 8
                                    u = plyr_[plyr_[arg2].field_256].field_768
                                    t = u + 1
                                    continue 
                                if stor4[stor8[_78970].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78970].field_768]:
                                    revert with 0, 'SafeMath mul failed'
                                mem[0] = address(plyr_[_78970].field_520)
                                if (stor4[stor8[_78970].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78970].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78970].field_512)].field_256:
                                    revert with 0, 'SafeMath add failed'
                                sub_e5b3f6f2[address(stor8[_78970].field_512)].field_256 += stor4[stor8[_78970].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                mem[32] = 8
                                mem[mem[64]] = address(plyr_[_78970].field_520)
                                mem[mem[64] + 32] = plyr_[_78970].field_768
                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                mem[mem[64] + 96] = block.timestamp
                                emit 0x72825d8b: address(plyr_[_78970].field_512), plyr_[_78970].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                u = t
                                while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                    if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                        if uint8(u + 1) < 5:
                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = uint8(u + 1)
                                            t = u + 1
                                            continue 
                                    else:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                            if uint8(u + 1) < 4:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                if uint8(u + 1) < 3:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                    if uint8(u + 1) < 1:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if uint8(u + 1) < 2:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                    mem[0] = stor6
                                    mem[32] = 11
                                    s = sha3(mem[0 len 64])
                                    idx = 448
                                    while 640 > idx:
                                        stor[s] = mem[idx]
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = s + 1
                                        idx = idx + 32
                                        continue 
                                    idx = sha3(mem[0 len 64]) + 6
                                    while sha3(stor6, 11) + 6 > idx:
                                        stor[idx] = 0
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        idx = idx + 1
                                        continue 
                                    if 0 >= msg.value:
                                        revert with 0, 'sorry ether or rID is incorrect'
                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                        revert with 0, 'sorry ether or rID is incorrect'
                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                    plyr_[stor6].field_256 = stor6
                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                    address(plyr_[stor6].field_520) = arg1
                                    plyr_[stor6].field_768 = mem[224]
                                    sub_8338d556[address(arg1)]++
                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                        revert with 0, 'SafeMath add failed'
                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                    stor1++
                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                             gas gas_remaining wei
                                    else:
                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                            revert with 0, 'SafeMath mul failed'
                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                             gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                            mem[0] = mem[(32 * s) + 448]
                            mem[32] = 8
                            s = plyr_[plyr_[arg2].field_256].field_768
                            t = u + 1
                            continue 
                    revert with 0, 'SafeMath add failed'
                s = 0
                idx = 448
                while 640 > idx:
                    stor11[stor6][s].field_0 = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = 6
                while 6 > idx:
                    stor11[stor6][idx].field_0 = 0
                    idx = idx + 1
                    continue 
                if 0 >= msg.value:
                    revert with 0, 'sorry ether or rID is incorrect'
                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                    revert with 0, 'sorry ether or rID is incorrect'
                plyr_[stor6].field_0 = plyr_[arg2].field_256
                plyr_[stor6].field_256 = stor6
                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                address(plyr_[stor6].field_520) = arg1
                plyr_[stor6].field_768 = mem[224]
            else:
                if var47003 <= 42:
                    if uint8(var51002) < uint8(-var51001 + 6):
                        require uint8(var53001) < 6
                        if not mem[(32 * var55001) + 448]:
                            if not var39001:
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                s = var39002
                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                    if uint8(s + 1) >= 6:
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    if mem[(32 * uint8(s + 1)) + 448]:
                                        require uint8(s + 1) < 6
                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                revert with 0, 'SafeMath add failed'
                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    _47260 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    mem[mem[64] + 32] = stor3[_47260]
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47260], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    _47537 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    mem[mem[64] + 32] = stor3[_47537]
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47537], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = s + 1
                                    continue 
                                var47003 = plyr_[plyr_[arg2].field_256].field_768
                                var47005 = s + 1
                                continue 
                            require uint8(var59001) < 6
                            _55225 = mem[(32 * uint8(var59001)) + 448]
                            mem[0] = mem[(32 * uint8(var59001)) + 448]
                            mem[32] = 8
                            _55254 = sha3(mem[(32 * uint8(var59001)) + 448], 8)
                            s = uint8(var59001)
                            t = var59001
                            while stor3[_55254] + 1 >= stor3[_55254]:
                                plyr_[_55225].field_768 = stor3[_55254] + 1
                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55225].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55225].field_512)].field_0:
                                    revert with 0, 'SafeMath add failed'
                                sub_e5b3f6f2[address(stor8[_55225].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                if not stor4[stor8[_55225].field_768]:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    u = t
                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                        if uint8(u + 1) < 6:
                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = uint8(u + 1)
                                            t = u + 1
                                            continue 
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    mem[0] = mem[(32 * s) + 448]
                                else:
                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                        mem[0] = address(plyr_[_55225].field_520)
                                        if sub_e5b3f6f2[address(stor8[_55225].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55225].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_55225].field_520)
                                        mem[mem[64] + 32] = plyr_[_55225].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_55225].field_512), plyr_[_55225].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(u + 1) < 6:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * u) + 448]
                                    else:
                                        if stor4[stor8[_55225].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55225].field_768]:
                                            revert with 0, 'SafeMath mul failed'
                                        mem[0] = address(plyr_[_55225].field_520)
                                        if (stor4[stor8[_55225].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55225].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55225].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_55225].field_512)].field_256 += stor4[stor8[_55225].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_55225].field_520)
                                        mem[mem[64] + 32] = plyr_[_55225].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_55225].field_512), plyr_[_55225].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(u + 1) < 6:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * s) + 448]
                                mem[32] = 8
                                var47003 = plyr_[plyr_[arg2].field_256].field_768
                                var47005 = u + 1
                                continue 
                        else:
                            require uint8(var57002) < 6
                            if not var61001:
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                s = var61002
                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                    if uint8(s + 1) >= 6:
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    if mem[(32 * uint8(s + 1)) + 448]:
                                        require uint8(s + 1) < 6
                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                revert with 0, 'SafeMath add failed'
                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    _73763 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    mem[mem[64] + 32] = stor3[_73763]
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: mem[mem[64]], stor3[_73763], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    _73982 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                    mem[mem[64] + 32] = stor3[_73982]
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: mem[mem[64]], stor3[_73982], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = s + 1
                                    continue 
                                var47003 = plyr_[plyr_[arg2].field_256].field_768
                                var47005 = s + 1
                                continue 
                            require uint8(var63001) < 6
                            _78969 = mem[(32 * uint8(var63001)) + 448]
                            mem[0] = mem[(32 * uint8(var63001)) + 448]
                            mem[32] = 8
                            _79008 = sha3(mem[(32 * uint8(var63001)) + 448], 8)
                            s = uint8(var63001)
                            t = var63001
                            while stor3[_79008] + 1 >= stor3[_79008]:
                                plyr_[_78969].field_768 = stor3[_79008] + 1
                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78969].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78969].field_512)].field_0:
                                    revert with 0, 'SafeMath add failed'
                                sub_e5b3f6f2[address(stor8[_78969].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                if not stor4[stor8[_78969].field_768]:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    u = t
                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                        if uint8(u + 1) < 6:
                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = u + 1
                                                continue 
                                            require uint8(u + 1) < 6
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = uint8(u + 1)
                                            t = u + 1
                                            continue 
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    mem[0] = mem[(32 * s) + 448]
                                else:
                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                        mem[0] = address(plyr_[_78969].field_520)
                                        if sub_e5b3f6f2[address(stor8[_78969].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78969].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_78969].field_520)
                                        mem[mem[64] + 32] = plyr_[_78969].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_78969].field_512), plyr_[_78969].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(u + 1) < 6:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * u) + 448]
                                    else:
                                        if stor4[stor8[_78969].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78969].field_768]:
                                            revert with 0, 'SafeMath mul failed'
                                        mem[0] = address(plyr_[_78969].field_520)
                                        if (stor4[stor8[_78969].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78969].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78969].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_78969].field_512)].field_256 += stor4[stor8[_78969].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_78969].field_520)
                                        mem[mem[64] + 32] = plyr_[_78969].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_78969].field_512), plyr_[_78969].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(u + 1) < 6:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * s) + 448]
                                mem[32] = 8
                                var47003 = plyr_[plyr_[arg2].field_256].field_768
                                var47005 = u + 1
                                continue 
                        revert with 0, 'SafeMath add failed'
                else:
                    if var47003 <= 258:
                        if uint8(var52002) < uint8(-var52001 + 6):
                            require uint8(var54001) < 6
                            if not mem[(32 * var56001) + 448]:
                                if not var40001:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = var40002
                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                        if uint8(s + 1) >= 6:
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        if mem[(32 * uint8(s + 1)) + 448]:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                    revert with 0, 'SafeMath add failed'
                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _47250 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_47250]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47250], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _47529 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_47529]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47529], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = s + 1
                                        continue 
                                    var47003 = plyr_[plyr_[arg2].field_256].field_768
                                    var47005 = s + 1
                                    continue 
                                require uint8(var60001) < 6
                                _55224 = mem[(32 * uint8(var60001)) + 448]
                                mem[0] = mem[(32 * uint8(var60001)) + 448]
                                mem[32] = 8
                                _55252 = sha3(mem[(32 * uint8(var60001)) + 448], 8)
                                s = uint8(var60001)
                                t = var60001
                                while stor3[_55252] + 1 >= stor3[_55252]:
                                    plyr_[_55224].field_768 = stor3[_55252] + 1
                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55224].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55224].field_512)].field_0:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_55224].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                    if not stor4[stor8[_55224].field_768]:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(u + 1) < 6:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * s) + 448]
                                    else:
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                            mem[0] = address(plyr_[_55224].field_520)
                                            if sub_e5b3f6f2[address(stor8[_55224].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55224].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_55224].field_520)
                                            mem[mem[64] + 32] = plyr_[_55224].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_55224].field_512), plyr_[_55224].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * u) + 448]
                                        else:
                                            if stor4[stor8[_55224].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55224].field_768]:
                                                revert with 0, 'SafeMath mul failed'
                                            mem[0] = address(plyr_[_55224].field_520)
                                            if (stor4[stor8[_55224].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55224].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55224].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_55224].field_512)].field_256 += stor4[stor8[_55224].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_55224].field_520)
                                            mem[mem[64] + 32] = plyr_[_55224].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_55224].field_512), plyr_[_55224].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                    mem[32] = 8
                                    var47003 = plyr_[plyr_[arg2].field_256].field_768
                                    var47005 = u + 1
                                    continue 
                            else:
                                require uint8(var58002) < 6
                                if not var62001:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = var62002
                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                        if uint8(s + 1) >= 6:
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        if mem[(32 * uint8(s + 1)) + 448]:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                    revert with 0, 'SafeMath add failed'
                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _73755 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_73755]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_73755], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _73975 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_73975]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_73975], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = s + 1
                                        continue 
                                    var47003 = plyr_[plyr_[arg2].field_256].field_768
                                    var47005 = s + 1
                                    continue 
                                require uint8(var64001) < 6
                                _78968 = mem[(32 * uint8(var64001)) + 448]
                                mem[0] = mem[(32 * uint8(var64001)) + 448]
                                mem[32] = 8
                                _79003 = sha3(mem[(32 * uint8(var64001)) + 448], 8)
                                s = uint8(var64001)
                                t = var64001
                                while stor3[_79003] + 1 >= stor3[_79003]:
                                    plyr_[_78968].field_768 = stor3[_79003] + 1
                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78968].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78968].field_512)].field_0:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_78968].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                    if not stor4[stor8[_78968].field_768]:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(u + 1) < 6:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * s) + 448]
                                    else:
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                            mem[0] = address(plyr_[_78968].field_520)
                                            if sub_e5b3f6f2[address(stor8[_78968].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78968].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_78968].field_520)
                                            mem[mem[64] + 32] = plyr_[_78968].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_78968].field_512), plyr_[_78968].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * u) + 448]
                                        else:
                                            if stor4[stor8[_78968].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78968].field_768]:
                                                revert with 0, 'SafeMath mul failed'
                                            mem[0] = address(plyr_[_78968].field_520)
                                            if (stor4[stor8[_78968].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78968].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78968].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_78968].field_512)].field_256 += stor4[stor8[_78968].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_78968].field_520)
                                            mem[mem[64] + 32] = plyr_[_78968].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_78968].field_512), plyr_[_78968].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                    mem[32] = 8
                                    var47003 = plyr_[plyr_[arg2].field_256].field_768
                                    var47005 = u + 1
                                    continue 
                            revert with 0, 'SafeMath add failed'
                    else:
                        if var47003 <= 1554:
                            if uint8(var53002) < uint8(-var53001 + 6):
                                require uint8(var55001) < 6
                                if not mem[(32 * var57001) + 448]:
                                    if not var41001:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = var41002
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(s + 1) >= 6:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47240 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47240]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47240], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47521 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47521]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47521], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            continue 
                                        var47003 = plyr_[plyr_[arg2].field_256].field_768
                                        var47005 = s + 1
                                        continue 
                                    require uint8(var61001) < 6
                                    _55223 = mem[(32 * uint8(var61001)) + 448]
                                    mem[0] = mem[(32 * uint8(var61001)) + 448]
                                    mem[32] = 8
                                    _55250 = sha3(mem[(32 * uint8(var61001)) + 448], 8)
                                    s = uint8(var61001)
                                    t = var61001
                                    while stor3[_55250] + 1 >= stor3[_55250]:
                                        plyr_[_55223].field_768 = stor3[_55250] + 1
                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55223].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55223].field_512)].field_0:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_55223].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                        if not stor4[stor8[_55223].field_768]:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                        else:
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                mem[0] = address(plyr_[_55223].field_520)
                                                if sub_e5b3f6f2[address(stor8[_55223].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55223].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_55223].field_520)
                                                mem[mem[64] + 32] = plyr_[_55223].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_55223].field_512), plyr_[_55223].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * u) + 448]
                                            else:
                                                if stor4[stor8[_55223].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55223].field_768]:
                                                    revert with 0, 'SafeMath mul failed'
                                                mem[0] = address(plyr_[_55223].field_520)
                                                if (stor4[stor8[_55223].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55223].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55223].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_55223].field_512)].field_256 += stor4[stor8[_55223].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_55223].field_520)
                                                mem[mem[64] + 32] = plyr_[_55223].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_55223].field_512), plyr_[_55223].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                        mem[32] = 8
                                        var47003 = plyr_[plyr_[arg2].field_256].field_768
                                        var47005 = u + 1
                                        continue 
                                else:
                                    require uint8(var59002) < 6
                                    if not var63001:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = var63002
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(s + 1) >= 6:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _73747 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_73747]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_73747], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _73968 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_73968]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_73968], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            continue 
                                        var47003 = plyr_[plyr_[arg2].field_256].field_768
                                        var47005 = s + 1
                                        continue 
                                    require uint8(var65001) < 6
                                    _78967 = mem[(32 * uint8(var65001)) + 448]
                                    mem[0] = mem[(32 * uint8(var65001)) + 448]
                                    mem[32] = 8
                                    _78998 = sha3(mem[(32 * uint8(var65001)) + 448], 8)
                                    s = uint8(var65001)
                                    t = var65001
                                    while stor3[_78998] + 1 >= stor3[_78998]:
                                        plyr_[_78967].field_768 = stor3[_78998] + 1
                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78967].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78967].field_512)].field_0:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_78967].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                        if not stor4[stor8[_78967].field_768]:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                        else:
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                mem[0] = address(plyr_[_78967].field_520)
                                                if sub_e5b3f6f2[address(stor8[_78967].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78967].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_78967].field_520)
                                                mem[mem[64] + 32] = plyr_[_78967].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_78967].field_512), plyr_[_78967].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * u) + 448]
                                            else:
                                                if stor4[stor8[_78967].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78967].field_768]:
                                                    revert with 0, 'SafeMath mul failed'
                                                mem[0] = address(plyr_[_78967].field_520)
                                                if (stor4[stor8[_78967].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78967].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78967].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_78967].field_512)].field_256 += stor4[stor8[_78967].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_78967].field_520)
                                                mem[mem[64] + 32] = plyr_[_78967].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_78967].field_512), plyr_[_78967].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                        mem[32] = 8
                                        var47003 = plyr_[plyr_[arg2].field_256].field_768
                                        var47005 = u + 1
                                        continue 
                                revert with 0, 'SafeMath add failed'
                        else:
                            if var47003 > 9330:
                                if uint8(var52002) < uint8(-var52001 + 6):
                                    require uint8(var54001) < 6
                                    if not mem[(32 * var56001) + 448]:
                                        if not var40001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var40002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _34432 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_34432]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_34432], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _34642 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_34642]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_34642], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var47003 = plyr_[plyr_[arg2].field_256].field_768
                                            var47005 = s + 1
                                            continue 
                                        require uint8(var60001) < 6
                                        _42506 = mem[(32 * uint8(var60001)) + 448]
                                        mem[0] = mem[(32 * uint8(var60001)) + 448]
                                        mem[32] = 8
                                        _42551 = sha3(mem[(32 * uint8(var60001)) + 448], 8)
                                        s = uint8(var60001)
                                        t = var60001
                                        while stor3[_42551] + 1 >= stor3[_42551]:
                                            plyr_[_42506].field_768 = stor3[_42551] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_42506].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_42506].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_42506].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_42506].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_42506].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_42506].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_42506].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_42506].field_520)
                                                    mem[mem[64] + 32] = plyr_[_42506].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_42506].field_512), plyr_[_42506].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_42506].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_42506].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_42506].field_520)
                                                    if (stor4[stor8[_42506].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_42506].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_42506].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_42506].field_512)].field_256 += stor4[stor8[_42506].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_42506].field_520)
                                                    mem[mem[64] + 32] = plyr_[_42506].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_42506].field_512), plyr_[_42506].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var47003 = plyr_[plyr_[arg2].field_256].field_768
                                            var47005 = u + 1
                                            continue 
                                    else:
                                        require uint8(var58002) < 6
                                        if not var62001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var62002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _60224 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_60224]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_60224], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _60434 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_60434]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_60434], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var47003 = plyr_[plyr_[arg2].field_256].field_768
                                            var47005 = s + 1
                                            continue 
                                        require uint8(var64001) < 6
                                        _67598 = mem[(32 * uint8(var64001)) + 448]
                                        mem[0] = mem[(32 * uint8(var64001)) + 448]
                                        mem[32] = 8
                                        _67606 = sha3(mem[(32 * uint8(var64001)) + 448], 8)
                                        s = uint8(var64001)
                                        t = var64001
                                        while stor3[_67606] + 1 >= stor3[_67606]:
                                            plyr_[_67598].field_768 = stor3[_67606] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_67598].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_67598].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_67598].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_67598].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_67598].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_67598].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_67598].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_67598].field_520)
                                                    mem[mem[64] + 32] = plyr_[_67598].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_67598].field_512), plyr_[_67598].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_67598].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_67598].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_67598].field_520)
                                                    if (stor4[stor8[_67598].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_67598].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_67598].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_67598].field_512)].field_256 += stor4[stor8[_67598].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_67598].field_520)
                                                    mem[mem[64] + 32] = plyr_[_67598].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_67598].field_512), plyr_[_67598].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var47003 = plyr_[plyr_[arg2].field_256].field_768
                                            var47005 = u + 1
                                            continue 
                                    revert with 0, 'SafeMath add failed'
                            else:
                                if uint8(var54002) < uint8(-var54001 + 6):
                                    require uint8(var56001) < 6
                                    if not mem[(32 * var58001) + 448]:
                                        if not var42001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var42002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47230 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47230]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47230], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47513 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47513]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47513], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var47003 = plyr_[plyr_[arg2].field_256].field_768
                                            var47005 = s + 1
                                            continue 
                                        require uint8(var62001) < 6
                                        _55222 = mem[(32 * uint8(var62001)) + 448]
                                        mem[0] = mem[(32 * uint8(var62001)) + 448]
                                        mem[32] = 8
                                        _55248 = sha3(mem[(32 * uint8(var62001)) + 448], 8)
                                        s = uint8(var62001)
                                        t = var62001
                                        while stor3[_55248] + 1 >= stor3[_55248]:
                                            plyr_[_55222].field_768 = stor3[_55248] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55222].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55222].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_55222].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_55222].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_55222].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_55222].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55222].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_55222].field_520)
                                                    mem[mem[64] + 32] = plyr_[_55222].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_55222].field_512), plyr_[_55222].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_55222].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55222].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_55222].field_520)
                                                    if (stor4[stor8[_55222].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55222].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55222].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_55222].field_512)].field_256 += stor4[stor8[_55222].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_55222].field_520)
                                                    mem[mem[64] + 32] = plyr_[_55222].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_55222].field_512), plyr_[_55222].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var47003 = plyr_[plyr_[arg2].field_256].field_768
                                            var47005 = u + 1
                                            continue 
                                    else:
                                        require uint8(var60002) < 6
                                        if not var64001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var64002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _73739 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_73739]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_73739], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _73961 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_73961]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_73961], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var47003 = plyr_[plyr_[arg2].field_256].field_768
                                            var47005 = s + 1
                                            continue 
                                        require uint8(var66001) < 6
                                        _78966 = mem[(32 * uint8(var66001)) + 448]
                                        mem[0] = mem[(32 * uint8(var66001)) + 448]
                                        mem[32] = 8
                                        _78993 = sha3(mem[(32 * uint8(var66001)) + 448], 8)
                                        s = uint8(var66001)
                                        t = var66001
                                        while stor3[_78993] + 1 >= stor3[_78993]:
                                            plyr_[_78966].field_768 = stor3[_78993] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78966].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78966].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_78966].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_78966].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_78966].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_78966].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78966].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_78966].field_520)
                                                    mem[mem[64] + 32] = plyr_[_78966].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_78966].field_512), plyr_[_78966].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_78966].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78966].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_78966].field_520)
                                                    if (stor4[stor8[_78966].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78966].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78966].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_78966].field_512)].field_256 += stor4[stor8[_78966].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_78966].field_520)
                                                    mem[mem[64] + 32] = plyr_[_78966].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_78966].field_512), plyr_[_78966].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var47003 = plyr_[plyr_[arg2].field_256].field_768
                                            var47005 = u + 1
                                            continue 
                                    revert with 0, 'SafeMath add failed'
                s = 0
                idx = 448
                while 640 > idx:
                    stor11[stor6][s].field_0 = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = 6
                while 6 > idx:
                    stor11[stor6][idx].field_0 = 0
                    idx = idx + 1
                    continue 
                if 0 >= msg.value:
                    revert with 0, 'sorry ether or rID is incorrect'
                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                    revert with 0, 'sorry ether or rID is incorrect'
                plyr_[stor6].field_0 = plyr_[arg2].field_256
                plyr_[stor6].field_256 = stor6
                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                address(plyr_[stor6].field_520) = arg1
                plyr_[stor6].field_768 = 0
            sub_8338d556[address(arg1)]++
            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                revert with 0, 'SafeMath add failed'
            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
            stor1++
            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                     gas gas_remaining wei
            else:
                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                    revert with 0, 'SafeMath mul failed'
                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                     gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
    else:
        if sub_d705f265[address(arg1)]:
            stor6++
            mem[96] = 0
            mem[128] = 0
            mem[160] = 0
            mem[192] = 0
            mem[224] = 0
            if not plyr_[arg2].field_256:
                if not stor3[arg3 << 248]:
                    if 0 >= msg.value:
                        revert with 0, 'sorry ether or rID is incorrect'
                    if msg.value != 0:
                        revert with 0, 'sorry ether or rID is incorrect'
                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                    plyr_[stor6].field_256 = stor6
                    uint8(plyr_[stor6].field_512) = 0
                    address(plyr_[stor6].field_520) = arg1
                    plyr_[stor6].field_768 % 1 = 0
                    plyr_[stor6].field_768 = 0
                    sub_8338d556[address(arg1)]++
                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                    if stor0 < stor0:
                        revert with 0, 'SafeMath add failed'
                else:
                    if 2 * stor3[arg3 << 248] / stor3[arg3 << 248] != 2:
                        revert with 0, 'SafeMath mul failed'
                    if 0 >= msg.value:
                        revert with 0, 'sorry ether or rID is incorrect'
                    if 2 * stor3[arg3 << 248] != msg.value:
                        revert with 0, 'sorry ether or rID is incorrect'
                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                    plyr_[stor6].field_256 = stor6
                    uint8(plyr_[stor6].field_512) = 0
                    address(plyr_[stor6].field_520) = arg1
                    plyr_[stor6].field_768 % 1 = 0
                    plyr_[stor6].field_768 = 0
                    sub_8338d556[address(arg1)]++
                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                    if (2 * stor3[arg3 << 248]) + stor0 < stor0:
                        revert with 0, 'SafeMath add failed'
                    stor0 += 2 * stor3[arg3 << 248]
                stor1++
                if not stor3[arg3 << 248] / 100:
                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                         gas gas_remaining wei
                else:
                    if 23 * stor3[arg3 << 248] / 100 / stor3[arg3 << 248] / 100 != 23:
                        revert with 0, 'SafeMath mul failed'
                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                       value 23 * stor3[arg3 << 248] / 100 wei
                         gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                emit 0xb632245f: arg3 << 248, block.timestamp, stor6, arg1
            else:
                mem[256 len 192] = code.data[6945 len 192]
                mem[64] = 640
                mem[448] = plyr_[arg2].field_256
                mem[480] = stor11[stor8[arg2].field_256].field_0
                mem[512] = stor11[stor8[arg2].field_256].field_256
                mem[544] = stor11[stor8[arg2].field_256].field_512
                mem[576] = stor11[stor8[arg2].field_256].field_768
                mem[608] = stor11[stor8[arg2].field_256].field_1024
                mem[0] = plyr_[arg2].field_256
                mem[32] = 8
                if var46001 <= 6:
                    s = var46001
                    t = var46003
                    while uint8(var53002) < uint8(-var53001 + 6):
                        require uint8(var55001) < 6
                        if not mem[(32 * var57001) + 448]:
                            if not var41001:
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                s = var41002
                                while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                    if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                        if uint8(s + 1) >= 5:
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        if mem[(32 * uint8(s + 1)) + 448]:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                    revert with 0, 'SafeMath add failed'
                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _47631 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_47631]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47631], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _47915 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_47915]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47915], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    else:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                            if uint8(s + 1) >= 4:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47911 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47911]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47911], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _48263 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_48263]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_48263], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                if uint8(s + 1) >= 3:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48259 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48259]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48259], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48632 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48632]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48632], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                    if uint8(s + 1) >= 1:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _48251 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_48251]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_48251], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _48622 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_48622]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_48622], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if uint8(s + 1) >= 2:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _48628 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_48628]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_48628], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _49028 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_49028]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_49028], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = s + 1
                                    continue 
                                s = plyr_[plyr_[arg2].field_256].field_768
                                t = s + 1
                                continue 
                            require uint8(var61001) < 6
                            _55231 = mem[(32 * uint8(var61001)) + 448]
                            mem[0] = mem[(32 * uint8(var61001)) + 448]
                            mem[32] = 8
                            _55279 = sha3(mem[(32 * uint8(var61001)) + 448], 8)
                            s = uint8(var61001)
                            t = var61001
                            while stor3[_55279] + 1 >= stor3[_55279]:
                                plyr_[_55231].field_768 = stor3[_55279] + 1
                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55231].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55231].field_512)].field_0:
                                    revert with 0, 'SafeMath add failed'
                                sub_e5b3f6f2[address(stor8[_55231].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                if not stor4[stor8[_55231].field_768]:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    u = t
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(u + 1) < 5:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(u + 1) < 4:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(u + 1) < 3:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(u + 1) < 1:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                    else:
                                                        if uint8(u + 1) < 2:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        t = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[t] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            t = t + 1
                                                            idx = idx + 32
                                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                else:
                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                        mem[0] = address(plyr_[_55231].field_520)
                                        if sub_e5b3f6f2[address(stor8[_55231].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55231].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_55231].field_520)
                                        mem[mem[64] + 32] = plyr_[_55231].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_55231].field_512), plyr_[_55231].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * u) + 448]
                                        mem[32] = 8
                                        u = plyr_[plyr_[arg2].field_256].field_768
                                        t = u + 1
                                        continue 
                                    if stor4[stor8[_55231].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55231].field_768]:
                                        revert with 0, 'SafeMath mul failed'
                                    mem[0] = address(plyr_[_55231].field_520)
                                    if (stor4[stor8[_55231].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55231].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55231].field_512)].field_256:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_55231].field_512)].field_256 += stor4[stor8[_55231].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                    mem[32] = 8
                                    mem[mem[64]] = address(plyr_[_55231].field_520)
                                    mem[mem[64] + 32] = plyr_[_55231].field_768
                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                    mem[mem[64] + 96] = block.timestamp
                                    emit 0x72825d8b: address(plyr_[_55231].field_512), plyr_[_55231].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    u = t
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(u + 1) < 5:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(u + 1) < 4:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(u + 1) < 3:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(u + 1) < 1:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if uint8(u + 1) < 2:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                mem[0] = mem[(32 * s) + 448]
                                mem[32] = 8
                                s = plyr_[plyr_[arg2].field_256].field_768
                                t = u + 1
                                continue 
                        else:
                            require uint8(var59002) < 6
                            if not var63001:
                                mem[0] = plyr_[arg2].field_256
                                mem[32] = 8
                                t = var63002
                                while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                    if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                        if uint8(t + 1) >= 5:
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        if mem[(32 * uint8(t + 1)) + 448]:
                                            require uint8(t + 1) < 6
                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                require uint8(t + 1) < 6
                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                    revert with 0, 'SafeMath add failed'
                                                plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _74056 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_74056]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74056], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                        if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _74259 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_74259]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74259], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    else:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                            if uint8(t + 1) >= 4:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(t + 1)) + 448]:
                                                require uint8(t + 1) < 6
                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74255 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74255]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74255], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74617 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74617]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74617], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                if uint8(t + 1) >= 3:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(t + 1)) + 448]:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74613 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74613]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74613], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _75039 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_75039]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_75039], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                    if uint8(t + 1) >= 1:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(t + 1)) + 448]:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                            require uint8(t + 1) < 6
                                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _74605 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_74605]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_74605], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _75029 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_75029]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_75029], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if uint8(t + 1) >= 2:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(t + 1)) + 448]:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                            require uint8(t + 1) < 6
                                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _75035 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_75035]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_75035], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _75385 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_75385]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_75385], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    t = t + 1
                                    continue 
                                s = plyr_[plyr_[arg2].field_256].field_768
                                t = t + 1
                                continue 
                            require uint8(var65001) < 6
                            _78975 = mem[(32 * uint8(var65001)) + 448]
                            mem[0] = mem[(32 * uint8(var65001)) + 448]
                            mem[32] = 8
                            _79073 = sha3(mem[(32 * uint8(var65001)) + 448], 8)
                            s = uint8(var65001)
                            t = var65001
                            while stor3[_79073] + 1 >= stor3[_79073]:
                                plyr_[_78975].field_768 = stor3[_79073] + 1
                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78975].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78975].field_512)].field_0:
                                    revert with 0, 'SafeMath add failed'
                                sub_e5b3f6f2[address(stor8[_78975].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                if not stor4[stor8[_78975].field_768]:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    u = t
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(u + 1) < 5:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(u + 1) < 4:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(u + 1) < 3:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(u + 1) < 1:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                    else:
                                                        if uint8(u + 1) < 2:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        t = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[t] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            t = t + 1
                                                            idx = idx + 32
                                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                else:
                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                        mem[0] = address(plyr_[_78975].field_520)
                                        if sub_e5b3f6f2[address(stor8[_78975].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78975].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_78975].field_520)
                                        mem[mem[64] + 32] = plyr_[_78975].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_78975].field_512), plyr_[_78975].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * u) + 448]
                                        mem[32] = 8
                                        u = plyr_[plyr_[arg2].field_256].field_768
                                        t = u + 1
                                        continue 
                                    if stor4[stor8[_78975].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78975].field_768]:
                                        revert with 0, 'SafeMath mul failed'
                                    mem[0] = address(plyr_[_78975].field_520)
                                    if (stor4[stor8[_78975].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78975].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78975].field_512)].field_256:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_78975].field_512)].field_256 += stor4[stor8[_78975].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                    mem[32] = 8
                                    mem[mem[64]] = address(plyr_[_78975].field_520)
                                    mem[mem[64] + 32] = plyr_[_78975].field_768
                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                    mem[mem[64] + 96] = block.timestamp
                                    emit 0x72825d8b: address(plyr_[_78975].field_512), plyr_[_78975].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    u = t
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(u + 1) < 5:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(u + 1) < 4:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(u + 1) < 3:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(u + 1) < 1:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if uint8(u + 1) < 2:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                        mem[0] = stor6
                                        mem[32] = 11
                                        s = sha3(mem[0 len 64])
                                        idx = 448
                                        while 640 > idx:
                                            stor[s] = mem[idx]
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            idx = idx + 32
                                            continue 
                                        idx = sha3(mem[0 len 64]) + 6
                                        while sha3(stor6, 11) + 6 > idx:
                                            stor[idx] = 0
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            idx = idx + 1
                                            continue 
                                        if 0 >= msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                            revert with 0, 'sorry ether or rID is incorrect'
                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                        plyr_[stor6].field_256 = stor6
                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        address(plyr_[stor6].field_520) = arg1
                                        plyr_[stor6].field_768 = mem[224]
                                        sub_8338d556[address(arg1)]++
                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                            revert with 0, 'SafeMath add failed'
                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        stor1++
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                 gas gas_remaining wei
                                        else:
                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                revert with 0, 'SafeMath mul failed'
                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                 gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                mem[0] = mem[(32 * s) + 448]
                                mem[32] = 8
                                s = plyr_[plyr_[arg2].field_256].field_768
                                t = u + 1
                                continue 
                        revert with 0, 'SafeMath add failed'
                    s = 0
                    idx = 448
                    while 640 > idx:
                        stor11[stor6][s].field_0 = mem[idx]
                        s = s + 1
                        idx = idx + 32
                        continue 
                    idx = 6
                    while 6 > idx:
                        stor11[stor6][idx].field_0 = 0
                        idx = idx + 1
                        continue 
                    if 0 >= msg.value:
                        revert with 0, 'sorry ether or rID is incorrect'
                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                        revert with 0, 'sorry ether or rID is incorrect'
                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                    plyr_[stor6].field_256 = stor6
                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                    address(plyr_[stor6].field_520) = arg1
                    plyr_[stor6].field_768 = mem[224]
                else:
                    if var49003 <= 42:
                        if uint8(var53002) < uint8(-var53001 + 6):
                            require uint8(var55001) < 6
                            if not mem[(32 * var57001) + 448]:
                                if not var41001:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = var41002
                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                        if uint8(s + 1) >= 6:
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        if mem[(32 * uint8(s + 1)) + 448]:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                    revert with 0, 'SafeMath add failed'
                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _47330 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_47330]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47330], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _47611 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_47611]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47611], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = s + 1
                                        continue 
                                    var49003 = plyr_[plyr_[arg2].field_256].field_768
                                    var49005 = s + 1
                                    continue 
                                require uint8(var61001) < 6
                                _55230 = mem[(32 * uint8(var61001)) + 448]
                                mem[0] = mem[(32 * uint8(var61001)) + 448]
                                mem[32] = 8
                                _55273 = sha3(mem[(32 * uint8(var61001)) + 448], 8)
                                s = uint8(var61001)
                                t = var61001
                                while stor3[_55273] + 1 >= stor3[_55273]:
                                    plyr_[_55230].field_768 = stor3[_55273] + 1
                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55230].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55230].field_512)].field_0:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_55230].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                    if not stor4[stor8[_55230].field_768]:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(u + 1) < 6:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * s) + 448]
                                    else:
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                            mem[0] = address(plyr_[_55230].field_520)
                                            if sub_e5b3f6f2[address(stor8[_55230].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55230].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_55230].field_520)
                                            mem[mem[64] + 32] = plyr_[_55230].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_55230].field_512), plyr_[_55230].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * u) + 448]
                                        else:
                                            if stor4[stor8[_55230].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55230].field_768]:
                                                revert with 0, 'SafeMath mul failed'
                                            mem[0] = address(plyr_[_55230].field_520)
                                            if (stor4[stor8[_55230].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55230].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55230].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_55230].field_512)].field_256 += stor4[stor8[_55230].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_55230].field_520)
                                            mem[mem[64] + 32] = plyr_[_55230].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_55230].field_512), plyr_[_55230].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                    mem[32] = 8
                                    var49003 = plyr_[plyr_[arg2].field_256].field_768
                                    var49005 = u + 1
                                    continue 
                            else:
                                require uint8(var59002) < 6
                                if not var63001:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = var63002
                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                        if uint8(s + 1) >= 6:
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        if mem[(32 * uint8(s + 1)) + 448]:
                                            require uint8(s + 1) < 6
                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                    revert with 0, 'SafeMath add failed'
                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _73819 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_73819]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_73819], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        _74037 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                        mem[mem[64] + 32] = stor3[_74037]
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74037], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = s + 1
                                        continue 
                                    var49003 = plyr_[plyr_[arg2].field_256].field_768
                                    var49005 = s + 1
                                    continue 
                                require uint8(var65001) < 6
                                _78974 = mem[(32 * uint8(var65001)) + 448]
                                mem[0] = mem[(32 * uint8(var65001)) + 448]
                                mem[32] = 8
                                _79052 = sha3(mem[(32 * uint8(var65001)) + 448], 8)
                                s = uint8(var65001)
                                t = var65001
                                while stor3[_79052] + 1 >= stor3[_79052]:
                                    plyr_[_78974].field_768 = stor3[_79052] + 1
                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78974].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78974].field_512)].field_0:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_78974].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                    if not stor4[stor8[_78974].field_768]:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(u + 1) < 6:
                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = u + 1
                                                    continue 
                                                require uint8(u + 1) < 6
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = uint8(u + 1)
                                                t = u + 1
                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                        mem[0] = mem[(32 * s) + 448]
                                    else:
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                            mem[0] = address(plyr_[_78974].field_520)
                                            if sub_e5b3f6f2[address(stor8[_78974].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78974].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_78974].field_520)
                                            mem[mem[64] + 32] = plyr_[_78974].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_78974].field_512), plyr_[_78974].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * u) + 448]
                                        else:
                                            if stor4[stor8[_78974].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78974].field_768]:
                                                revert with 0, 'SafeMath mul failed'
                                            mem[0] = address(plyr_[_78974].field_520)
                                            if (stor4[stor8[_78974].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78974].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78974].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_78974].field_512)].field_256 += stor4[stor8[_78974].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_78974].field_520)
                                            mem[mem[64] + 32] = plyr_[_78974].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_78974].field_512), plyr_[_78974].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                    mem[32] = 8
                                    var49003 = plyr_[plyr_[arg2].field_256].field_768
                                    var49005 = u + 1
                                    continue 
                            revert with 0, 'SafeMath add failed'
                    else:
                        if var49003 <= 258:
                            if uint8(var54002) < uint8(-var54001 + 6):
                                require uint8(var56001) < 6
                                if not mem[(32 * var58001) + 448]:
                                    if not var42001:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = var42002
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(s + 1) >= 6:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47320 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47320]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47320], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47603 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47603]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47603], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            continue 
                                        var49003 = plyr_[plyr_[arg2].field_256].field_768
                                        var49005 = s + 1
                                        continue 
                                    require uint8(var62001) < 6
                                    _55229 = mem[(32 * uint8(var62001)) + 448]
                                    mem[0] = mem[(32 * uint8(var62001)) + 448]
                                    mem[32] = 8
                                    _55271 = sha3(mem[(32 * uint8(var62001)) + 448], 8)
                                    s = uint8(var62001)
                                    t = var62001
                                    while stor3[_55271] + 1 >= stor3[_55271]:
                                        plyr_[_55229].field_768 = stor3[_55271] + 1
                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55229].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55229].field_512)].field_0:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_55229].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                        if not stor4[stor8[_55229].field_768]:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                        else:
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                mem[0] = address(plyr_[_55229].field_520)
                                                if sub_e5b3f6f2[address(stor8[_55229].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55229].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_55229].field_520)
                                                mem[mem[64] + 32] = plyr_[_55229].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_55229].field_512), plyr_[_55229].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * u) + 448]
                                            else:
                                                if stor4[stor8[_55229].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55229].field_768]:
                                                    revert with 0, 'SafeMath mul failed'
                                                mem[0] = address(plyr_[_55229].field_520)
                                                if (stor4[stor8[_55229].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55229].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55229].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_55229].field_512)].field_256 += stor4[stor8[_55229].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_55229].field_520)
                                                mem[mem[64] + 32] = plyr_[_55229].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_55229].field_512), plyr_[_55229].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                        mem[32] = 8
                                        var49003 = plyr_[plyr_[arg2].field_256].field_768
                                        var49005 = u + 1
                                        continue 
                                else:
                                    require uint8(var60002) < 6
                                    if not var64001:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = var64002
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(s + 1) >= 6:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _73811 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_73811]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_73811], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74030 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74030]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74030], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            continue 
                                        var49003 = plyr_[plyr_[arg2].field_256].field_768
                                        var49005 = s + 1
                                        continue 
                                    require uint8(var66001) < 6
                                    _78973 = mem[(32 * uint8(var66001)) + 448]
                                    mem[0] = mem[(32 * uint8(var66001)) + 448]
                                    mem[32] = 8
                                    _79047 = sha3(mem[(32 * uint8(var66001)) + 448], 8)
                                    s = uint8(var66001)
                                    t = var66001
                                    while stor3[_79047] + 1 >= stor3[_79047]:
                                        plyr_[_78973].field_768 = stor3[_79047] + 1
                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78973].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78973].field_512)].field_0:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_78973].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                        if not stor4[stor8[_78973].field_768]:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                        else:
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                mem[0] = address(plyr_[_78973].field_520)
                                                if sub_e5b3f6f2[address(stor8[_78973].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78973].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_78973].field_520)
                                                mem[mem[64] + 32] = plyr_[_78973].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_78973].field_512), plyr_[_78973].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * u) + 448]
                                            else:
                                                if stor4[stor8[_78973].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78973].field_768]:
                                                    revert with 0, 'SafeMath mul failed'
                                                mem[0] = address(plyr_[_78973].field_520)
                                                if (stor4[stor8[_78973].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78973].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78973].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_78973].field_512)].field_256 += stor4[stor8[_78973].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_78973].field_520)
                                                mem[mem[64] + 32] = plyr_[_78973].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_78973].field_512), plyr_[_78973].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                        mem[32] = 8
                                        var49003 = plyr_[plyr_[arg2].field_256].field_768
                                        var49005 = u + 1
                                        continue 
                                revert with 0, 'SafeMath add failed'
                        else:
                            if var49003 <= 1554:
                                if uint8(var55002) < uint8(-var55001 + 6):
                                    require uint8(var57001) < 6
                                    if not mem[(32 * var59001) + 448]:
                                        if not var43001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var43002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47310 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47310]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47310], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47595 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47595]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47595], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var49003 = plyr_[plyr_[arg2].field_256].field_768
                                            var49005 = s + 1
                                            continue 
                                        require uint8(var63001) < 6
                                        _55228 = mem[(32 * uint8(var63001)) + 448]
                                        mem[0] = mem[(32 * uint8(var63001)) + 448]
                                        mem[32] = 8
                                        _55269 = sha3(mem[(32 * uint8(var63001)) + 448], 8)
                                        s = uint8(var63001)
                                        t = var63001
                                        while stor3[_55269] + 1 >= stor3[_55269]:
                                            plyr_[_55228].field_768 = stor3[_55269] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55228].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55228].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_55228].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_55228].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_55228].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_55228].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55228].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_55228].field_520)
                                                    mem[mem[64] + 32] = plyr_[_55228].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_55228].field_512), plyr_[_55228].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_55228].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55228].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_55228].field_520)
                                                    if (stor4[stor8[_55228].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55228].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55228].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_55228].field_512)].field_256 += stor4[stor8[_55228].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_55228].field_520)
                                                    mem[mem[64] + 32] = plyr_[_55228].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_55228].field_512), plyr_[_55228].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var49003 = plyr_[plyr_[arg2].field_256].field_768
                                            var49005 = u + 1
                                            continue 
                                    else:
                                        require uint8(var61002) < 6
                                        if not var65001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var65002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _73803 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_73803]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_73803], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74023 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74023]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74023], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var49003 = plyr_[plyr_[arg2].field_256].field_768
                                            var49005 = s + 1
                                            continue 
                                        require uint8(var67001) < 6
                                        _78972 = mem[(32 * uint8(var67001)) + 448]
                                        mem[0] = mem[(32 * uint8(var67001)) + 448]
                                        mem[32] = 8
                                        _79042 = sha3(mem[(32 * uint8(var67001)) + 448], 8)
                                        s = uint8(var67001)
                                        t = var67001
                                        while stor3[_79042] + 1 >= stor3[_79042]:
                                            plyr_[_78972].field_768 = stor3[_79042] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78972].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78972].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_78972].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_78972].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_78972].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_78972].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78972].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_78972].field_520)
                                                    mem[mem[64] + 32] = plyr_[_78972].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_78972].field_512), plyr_[_78972].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_78972].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78972].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_78972].field_520)
                                                    if (stor4[stor8[_78972].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78972].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78972].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_78972].field_512)].field_256 += stor4[stor8[_78972].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_78972].field_520)
                                                    mem[mem[64] + 32] = plyr_[_78972].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_78972].field_512), plyr_[_78972].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var49003 = plyr_[plyr_[arg2].field_256].field_768
                                            var49005 = u + 1
                                            continue 
                                    revert with 0, 'SafeMath add failed'
                            else:
                                if var49003 > 9330:
                                    if uint8(var54002) < uint8(-var54001 + 6):
                                        require uint8(var56001) < 6
                                        if not mem[(32 * var58001) + 448]:
                                            if not var42001:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = var42002
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(s + 1) >= 6:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _34485 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_34485]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_34485], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _34714 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_34714]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_34714], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    continue 
                                                var49003 = plyr_[plyr_[arg2].field_256].field_768
                                                var49005 = s + 1
                                                continue 
                                            require uint8(var62001) < 6
                                            _42517 = mem[(32 * uint8(var62001)) + 448]
                                            mem[0] = mem[(32 * uint8(var62001)) + 448]
                                            mem[32] = 8
                                            _42563 = sha3(mem[(32 * uint8(var62001)) + 448], 8)
                                            s = uint8(var62001)
                                            t = var62001
                                            while stor3[_42563] + 1 >= stor3[_42563]:
                                                plyr_[_42517].field_768 = stor3[_42563] + 1
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_42517].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_42517].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_42517].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if not stor4[stor8[_42517].field_768]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                                else:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[_42517].field_520)
                                                        if sub_e5b3f6f2[address(stor8[_42517].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_42517].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_42517].field_520)
                                                        mem[mem[64] + 32] = plyr_[_42517].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_42517].field_512), plyr_[_42517].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * u) + 448]
                                                    else:
                                                        if stor4[stor8[_42517].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_42517].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[_42517].field_520)
                                                        if (stor4[stor8[_42517].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_42517].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_42517].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[_42517].field_512)].field_256 += stor4[stor8[_42517].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_42517].field_520)
                                                        mem[mem[64] + 32] = plyr_[_42517].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_42517].field_512), plyr_[_42517].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                mem[32] = 8
                                                var49003 = plyr_[plyr_[arg2].field_256].field_768
                                                var49005 = u + 1
                                                continue 
                                        else:
                                            require uint8(var60002) < 6
                                            if not var64001:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = var64002
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(s + 1) >= 6:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _60277 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_60277]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_60277], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _60512 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_60512]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_60512], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    continue 
                                                var49003 = plyr_[plyr_[arg2].field_256].field_768
                                                var49005 = s + 1
                                                continue 
                                            require uint8(var66001) < 6
                                            _67599 = mem[(32 * uint8(var66001)) + 448]
                                            mem[0] = mem[(32 * uint8(var66001)) + 448]
                                            mem[32] = 8
                                            _67636 = sha3(mem[(32 * uint8(var66001)) + 448], 8)
                                            s = uint8(var66001)
                                            t = var66001
                                            while stor3[_67636] + 1 >= stor3[_67636]:
                                                plyr_[_67599].field_768 = stor3[_67636] + 1
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_67599].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_67599].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_67599].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if not stor4[stor8[_67599].field_768]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                                else:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[_67599].field_520)
                                                        if sub_e5b3f6f2[address(stor8[_67599].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_67599].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_67599].field_520)
                                                        mem[mem[64] + 32] = plyr_[_67599].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_67599].field_512), plyr_[_67599].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * u) + 448]
                                                    else:
                                                        if stor4[stor8[_67599].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_67599].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[_67599].field_520)
                                                        if (stor4[stor8[_67599].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_67599].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_67599].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[_67599].field_512)].field_256 += stor4[stor8[_67599].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_67599].field_520)
                                                        mem[mem[64] + 32] = plyr_[_67599].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_67599].field_512), plyr_[_67599].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                mem[32] = 8
                                                var49003 = plyr_[plyr_[arg2].field_256].field_768
                                                var49005 = u + 1
                                                continue 
                                        revert with 0, 'SafeMath add failed'
                                else:
                                    if uint8(var56002) < uint8(-var56001 + 6):
                                        require uint8(var58001) < 6
                                        if not mem[(32 * var60001) + 448]:
                                            if not var44001:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = var44002
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(s + 1) >= 6:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _47300 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_47300]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47300], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _47587 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_47587]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47587], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    continue 
                                                var49003 = plyr_[plyr_[arg2].field_256].field_768
                                                var49005 = s + 1
                                                continue 
                                            require uint8(var64001) < 6
                                            _55227 = mem[(32 * uint8(var64001)) + 448]
                                            mem[0] = mem[(32 * uint8(var64001)) + 448]
                                            mem[32] = 8
                                            _55267 = sha3(mem[(32 * uint8(var64001)) + 448], 8)
                                            s = uint8(var64001)
                                            t = var64001
                                            while stor3[_55267] + 1 >= stor3[_55267]:
                                                plyr_[_55227].field_768 = stor3[_55267] + 1
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55227].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55227].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_55227].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if not stor4[stor8[_55227].field_768]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                                else:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[_55227].field_520)
                                                        if sub_e5b3f6f2[address(stor8[_55227].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55227].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_55227].field_520)
                                                        mem[mem[64] + 32] = plyr_[_55227].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_55227].field_512), plyr_[_55227].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * u) + 448]
                                                    else:
                                                        if stor4[stor8[_55227].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55227].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[_55227].field_520)
                                                        if (stor4[stor8[_55227].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55227].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55227].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[_55227].field_512)].field_256 += stor4[stor8[_55227].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_55227].field_520)
                                                        mem[mem[64] + 32] = plyr_[_55227].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_55227].field_512), plyr_[_55227].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                mem[32] = 8
                                                var49003 = plyr_[plyr_[arg2].field_256].field_768
                                                var49005 = u + 1
                                                continue 
                                        else:
                                            require uint8(var62002) < 6
                                            if not var66001:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = var66002
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(s + 1) >= 6:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _73795 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_73795]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_73795], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _74016 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_74016]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_74016], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    continue 
                                                var49003 = plyr_[plyr_[arg2].field_256].field_768
                                                var49005 = s + 1
                                                continue 
                                            require uint8(var68001) < 6
                                            _78971 = mem[(32 * uint8(var68001)) + 448]
                                            mem[0] = mem[(32 * uint8(var68001)) + 448]
                                            mem[32] = 8
                                            _79037 = sha3(mem[(32 * uint8(var68001)) + 448], 8)
                                            s = uint8(var68001)
                                            t = var68001
                                            while stor3[_79037] + 1 >= stor3[_79037]:
                                                plyr_[_78971].field_768 = stor3[_79037] + 1
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78971].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78971].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_78971].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if not stor4[stor8[_78971].field_768]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                                else:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[_78971].field_520)
                                                        if sub_e5b3f6f2[address(stor8[_78971].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78971].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_78971].field_520)
                                                        mem[mem[64] + 32] = plyr_[_78971].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_78971].field_512), plyr_[_78971].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * u) + 448]
                                                    else:
                                                        if stor4[stor8[_78971].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78971].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[_78971].field_520)
                                                        if (stor4[stor8[_78971].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78971].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78971].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[_78971].field_512)].field_256 += stor4[stor8[_78971].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_78971].field_520)
                                                        mem[mem[64] + 32] = plyr_[_78971].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_78971].field_512), plyr_[_78971].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                mem[32] = 8
                                                var49003 = plyr_[plyr_[arg2].field_256].field_768
                                                var49005 = u + 1
                                                continue 
                                        revert with 0, 'SafeMath add failed'
                    s = 0
                    idx = 448
                    while 640 > idx:
                        stor11[stor6][s].field_0 = mem[idx]
                        s = s + 1
                        idx = idx + 32
                        continue 
                    idx = 6
                    while 6 > idx:
                        stor11[stor6][idx].field_0 = 0
                        idx = idx + 1
                        continue 
                    if 0 >= msg.value:
                        revert with 0, 'sorry ether or rID is incorrect'
                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                        revert with 0, 'sorry ether or rID is incorrect'
                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                    plyr_[stor6].field_256 = stor6
                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                    address(plyr_[stor6].field_520) = arg1
                    plyr_[stor6].field_768 = 0
                sub_8338d556[address(arg1)]++
                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                    revert with 0, 'SafeMath add failed'
                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                stor1++
                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                         gas gas_remaining wei
                else:
                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                        revert with 0, 'SafeMath mul failed'
                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                         gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
        else:
            if not sub_cc5c8117[msg.sender]:
                stor6++
                mem[96] = 0
                mem[128] = 0
                mem[160] = 0
                mem[192] = 0
                mem[224] = 0
                if not plyr_[arg2].field_256:
                    if not stor3[arg3 << 248]:
                        if 0 >= msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        if msg.value != 0:
                            revert with 0, 'sorry ether or rID is incorrect'
                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                        plyr_[stor6].field_256 = stor6
                        uint8(plyr_[stor6].field_512) = 0
                        address(plyr_[stor6].field_520) = arg1
                        plyr_[stor6].field_768 % 1 = 0
                        plyr_[stor6].field_768 = 0
                        sub_8338d556[address(arg1)]++
                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                        if stor0 < stor0:
                            revert with 0, 'SafeMath add failed'
                    else:
                        if 2 * stor3[arg3 << 248] / stor3[arg3 << 248] != 2:
                            revert with 0, 'SafeMath mul failed'
                        if 0 >= msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        if 2 * stor3[arg3 << 248] != msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                        plyr_[stor6].field_256 = stor6
                        uint8(plyr_[stor6].field_512) = 0
                        address(plyr_[stor6].field_520) = arg1
                        plyr_[stor6].field_768 % 1 = 0
                        plyr_[stor6].field_768 = 0
                        sub_8338d556[address(arg1)]++
                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                        if (2 * stor3[arg3 << 248]) + stor0 < stor0:
                            revert with 0, 'SafeMath add failed'
                        stor0 += 2 * stor3[arg3 << 248]
                    stor1++
                    if not stor3[arg3 << 248] / 100:
                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                             gas gas_remaining wei
                    else:
                        if 23 * stor3[arg3 << 248] / 100 / stor3[arg3 << 248] / 100 != 23:
                            revert with 0, 'SafeMath mul failed'
                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                           value 23 * stor3[arg3 << 248] / 100 wei
                             gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit 0xb632245f: arg3 << 248, block.timestamp, stor6, arg1
                else:
                    mem[256 len 192] = code.data[6945 len 192]
                    mem[64] = 640
                    mem[448] = plyr_[arg2].field_256
                    mem[480] = stor11[stor8[arg2].field_256].field_0
                    mem[512] = stor11[stor8[arg2].field_256].field_256
                    mem[544] = stor11[stor8[arg2].field_256].field_512
                    mem[576] = stor11[stor8[arg2].field_256].field_768
                    mem[608] = stor11[stor8[arg2].field_256].field_1024
                    mem[0] = plyr_[arg2].field_256
                    mem[32] = 8
                    if var47001 <= 6:
                        s = var47001
                        t = var47003
                        while uint8(var54002) < uint8(-var54001 + 6):
                            require uint8(var56001) < 6
                            if not mem[(32 * var58001) + 448]:
                                if not var42001:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = var42002
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(s + 1) >= 5:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47705 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47705]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47705], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47983 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47983]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47983], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(s + 1) >= 4:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47979 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47979]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47979], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48371 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48371]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48371], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(s + 1) >= 3:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _48367 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_48367]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_48367], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _48716 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_48716]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_48716], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(s + 1) >= 1:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _48359 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_48359]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_48359], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _48706 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_48706]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_48706], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if uint8(s + 1) >= 2:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _48712 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_48712]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_48712], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _49143 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_49143]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_49143], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = s + 1
                                        continue 
                                    s = plyr_[plyr_[arg2].field_256].field_768
                                    t = s + 1
                                    continue 
                                require uint8(var62001) < 6
                                _55236 = mem[(32 * uint8(var62001)) + 448]
                                mem[0] = mem[(32 * uint8(var62001)) + 448]
                                mem[32] = 8
                                _55298 = sha3(mem[(32 * uint8(var62001)) + 448], 8)
                                s = uint8(var62001)
                                t = var62001
                                while stor3[_55298] + 1 >= stor3[_55298]:
                                    plyr_[_55236].field_768 = stor3[_55298] + 1
                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55236].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55236].field_512)].field_0:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_55236].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                    if not stor4[stor8[_55236].field_768]:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            t = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[t] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                t = t + 1
                                                                idx = idx + 32
                                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    else:
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                            mem[0] = address(plyr_[_55236].field_520)
                                            if sub_e5b3f6f2[address(stor8[_55236].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55236].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_55236].field_520)
                                            mem[mem[64] + 32] = plyr_[_55236].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_55236].field_512), plyr_[_55236].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                    if uint8(u + 1) < 5:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                        if uint8(u + 1) < 4:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                            if uint8(u + 1) < 3:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                                if uint8(u + 1) < 1:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                            else:
                                                                if uint8(u + 1) < 2:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * u) + 448]
                                            mem[32] = 8
                                            u = plyr_[plyr_[arg2].field_256].field_768
                                            t = u + 1
                                            continue 
                                        if stor4[stor8[_55236].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55236].field_768]:
                                            revert with 0, 'SafeMath mul failed'
                                        mem[0] = address(plyr_[_55236].field_520)
                                        if (stor4[stor8[_55236].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55236].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55236].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_55236].field_512)].field_256 += stor4[stor8[_55236].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_55236].field_520)
                                        mem[mem[64] + 32] = plyr_[_55236].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_55236].field_512), plyr_[_55236].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    mem[0] = mem[(32 * s) + 448]
                                    mem[32] = 8
                                    s = plyr_[plyr_[arg2].field_256].field_768
                                    t = u + 1
                                    continue 
                            else:
                                require uint8(var60002) < 6
                                if not var64001:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    t = var64002
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(t + 1) >= 5:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(t + 1)) + 448]:
                                                require uint8(t + 1) < 6
                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74111 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74111]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74111], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74306 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74306]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74306], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(t + 1) >= 4:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(t + 1)) + 448]:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74302 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74302]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74302], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74750 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74750]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74750], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(t + 1) >= 3:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(t + 1)) + 448]:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                            require uint8(t + 1) < 6
                                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _74746 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_74746]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_74746], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _75124 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_75124]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_75124], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(t + 1) >= 1:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(t + 1)) + 448]:
                                                            require uint8(t + 1) < 6
                                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                                require uint8(t + 1) < 6
                                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _74738 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_74738]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74738], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _75114 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_75114]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_75114], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if uint8(t + 1) >= 2:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(t + 1)) + 448]:
                                                            require uint8(t + 1) < 6
                                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                                require uint8(t + 1) < 6
                                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _75120 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_75120]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_75120], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _75473 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_75473]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_75473], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        t = t + 1
                                        continue 
                                    s = plyr_[plyr_[arg2].field_256].field_768
                                    t = t + 1
                                    continue 
                                require uint8(var66001) < 6
                                _78980 = mem[(32 * uint8(var66001)) + 448]
                                mem[0] = mem[(32 * uint8(var66001)) + 448]
                                mem[32] = 8
                                _79117 = sha3(mem[(32 * uint8(var66001)) + 448], 8)
                                s = uint8(var66001)
                                t = var66001
                                while stor3[_79117] + 1 >= stor3[_79117]:
                                    plyr_[_78980].field_768 = stor3[_79117] + 1
                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78980].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78980].field_512)].field_0:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_78980].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                    if not stor4[stor8[_78980].field_768]:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            t = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[t] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                t = t + 1
                                                                idx = idx + 32
                                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    else:
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                            mem[0] = address(plyr_[_78980].field_520)
                                            if sub_e5b3f6f2[address(stor8[_78980].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78980].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_78980].field_520)
                                            mem[mem[64] + 32] = plyr_[_78980].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_78980].field_512), plyr_[_78980].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                    if uint8(u + 1) < 5:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                        if uint8(u + 1) < 4:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                            if uint8(u + 1) < 3:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                                if uint8(u + 1) < 1:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                            else:
                                                                if uint8(u + 1) < 2:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * u) + 448]
                                            mem[32] = 8
                                            u = plyr_[plyr_[arg2].field_256].field_768
                                            t = u + 1
                                            continue 
                                        if stor4[stor8[_78980].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78980].field_768]:
                                            revert with 0, 'SafeMath mul failed'
                                        mem[0] = address(plyr_[_78980].field_520)
                                        if (stor4[stor8[_78980].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78980].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78980].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_78980].field_512)].field_256 += stor4[stor8[_78980].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_78980].field_520)
                                        mem[mem[64] + 32] = plyr_[_78980].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_78980].field_512), plyr_[_78980].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    mem[0] = mem[(32 * s) + 448]
                                    mem[32] = 8
                                    s = plyr_[plyr_[arg2].field_256].field_768
                                    t = u + 1
                                    continue 
                            revert with 0, 'SafeMath add failed'
                        s = 0
                        idx = 448
                        while 640 > idx:
                            stor11[stor6][s].field_0 = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = 6
                        while 6 > idx:
                            stor11[stor6][idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        if 0 >= msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                        plyr_[stor6].field_256 = stor6
                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                        address(plyr_[stor6].field_520) = arg1
                        plyr_[stor6].field_768 = mem[224]
                    else:
                        if var50003 <= 42:
                            if uint8(var54002) < uint8(-var54001 + 6):
                                require uint8(var56001) < 6
                                if not mem[(32 * var58001) + 448]:
                                    if not var42001:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = var42002
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(s + 1) >= 6:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47400 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47400]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47400], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47685 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47685]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47685], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            continue 
                                        var50003 = plyr_[plyr_[arg2].field_256].field_768
                                        var50005 = s + 1
                                        continue 
                                    require uint8(var62001) < 6
                                    _55235 = mem[(32 * uint8(var62001)) + 448]
                                    mem[0] = mem[(32 * uint8(var62001)) + 448]
                                    mem[32] = 8
                                    _55292 = sha3(mem[(32 * uint8(var62001)) + 448], 8)
                                    s = uint8(var62001)
                                    t = var62001
                                    while stor3[_55292] + 1 >= stor3[_55292]:
                                        plyr_[_55235].field_768 = stor3[_55292] + 1
                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55235].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55235].field_512)].field_0:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_55235].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                        if not stor4[stor8[_55235].field_768]:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                        else:
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                mem[0] = address(plyr_[_55235].field_520)
                                                if sub_e5b3f6f2[address(stor8[_55235].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55235].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_55235].field_520)
                                                mem[mem[64] + 32] = plyr_[_55235].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_55235].field_512), plyr_[_55235].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * u) + 448]
                                            else:
                                                if stor4[stor8[_55235].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55235].field_768]:
                                                    revert with 0, 'SafeMath mul failed'
                                                mem[0] = address(plyr_[_55235].field_520)
                                                if (stor4[stor8[_55235].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55235].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55235].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_55235].field_512)].field_256 += stor4[stor8[_55235].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_55235].field_520)
                                                mem[mem[64] + 32] = plyr_[_55235].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_55235].field_512), plyr_[_55235].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                        mem[32] = 8
                                        var50003 = plyr_[plyr_[arg2].field_256].field_768
                                        var50005 = u + 1
                                        continue 
                                else:
                                    require uint8(var60002) < 6
                                    if not var64001:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = var64002
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(s + 1) >= 6:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _73875 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_73875]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_73875], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74092 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74092]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74092], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            continue 
                                        var50003 = plyr_[plyr_[arg2].field_256].field_768
                                        var50005 = s + 1
                                        continue 
                                    require uint8(var66001) < 6
                                    _78979 = mem[(32 * uint8(var66001)) + 448]
                                    mem[0] = mem[(32 * uint8(var66001)) + 448]
                                    mem[32] = 8
                                    _79096 = sha3(mem[(32 * uint8(var66001)) + 448], 8)
                                    s = uint8(var66001)
                                    t = var66001
                                    while stor3[_79096] + 1 >= stor3[_79096]:
                                        plyr_[_78979].field_768 = stor3[_79096] + 1
                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78979].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78979].field_512)].field_0:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_78979].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                        if not stor4[stor8[_78979].field_768]:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                        else:
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                mem[0] = address(plyr_[_78979].field_520)
                                                if sub_e5b3f6f2[address(stor8[_78979].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78979].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_78979].field_520)
                                                mem[mem[64] + 32] = plyr_[_78979].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_78979].field_512), plyr_[_78979].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * u) + 448]
                                            else:
                                                if stor4[stor8[_78979].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78979].field_768]:
                                                    revert with 0, 'SafeMath mul failed'
                                                mem[0] = address(plyr_[_78979].field_520)
                                                if (stor4[stor8[_78979].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78979].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78979].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_78979].field_512)].field_256 += stor4[stor8[_78979].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_78979].field_520)
                                                mem[mem[64] + 32] = plyr_[_78979].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_78979].field_512), plyr_[_78979].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                        mem[32] = 8
                                        var50003 = plyr_[plyr_[arg2].field_256].field_768
                                        var50005 = u + 1
                                        continue 
                                revert with 0, 'SafeMath add failed'
                        else:
                            if var50003 <= 258:
                                if uint8(var55002) < uint8(-var55001 + 6):
                                    require uint8(var57001) < 6
                                    if not mem[(32 * var59001) + 448]:
                                        if not var43001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var43002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47390 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47390]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47390], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47677 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47677]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47677], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var50003 = plyr_[plyr_[arg2].field_256].field_768
                                            var50005 = s + 1
                                            continue 
                                        require uint8(var63001) < 6
                                        _55234 = mem[(32 * uint8(var63001)) + 448]
                                        mem[0] = mem[(32 * uint8(var63001)) + 448]
                                        mem[32] = 8
                                        _55290 = sha3(mem[(32 * uint8(var63001)) + 448], 8)
                                        s = uint8(var63001)
                                        t = var63001
                                        while stor3[_55290] + 1 >= stor3[_55290]:
                                            plyr_[_55234].field_768 = stor3[_55290] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55234].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55234].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_55234].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_55234].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_55234].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_55234].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55234].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_55234].field_520)
                                                    mem[mem[64] + 32] = plyr_[_55234].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_55234].field_512), plyr_[_55234].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_55234].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55234].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_55234].field_520)
                                                    if (stor4[stor8[_55234].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55234].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55234].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_55234].field_512)].field_256 += stor4[stor8[_55234].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_55234].field_520)
                                                    mem[mem[64] + 32] = plyr_[_55234].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_55234].field_512), plyr_[_55234].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var50003 = plyr_[plyr_[arg2].field_256].field_768
                                            var50005 = u + 1
                                            continue 
                                    else:
                                        require uint8(var61002) < 6
                                        if not var65001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var65002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _73867 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_73867]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_73867], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74085 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74085]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74085], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var50003 = plyr_[plyr_[arg2].field_256].field_768
                                            var50005 = s + 1
                                            continue 
                                        require uint8(var67001) < 6
                                        _78978 = mem[(32 * uint8(var67001)) + 448]
                                        mem[0] = mem[(32 * uint8(var67001)) + 448]
                                        mem[32] = 8
                                        _79091 = sha3(mem[(32 * uint8(var67001)) + 448], 8)
                                        s = uint8(var67001)
                                        t = var67001
                                        while stor3[_79091] + 1 >= stor3[_79091]:
                                            plyr_[_78978].field_768 = stor3[_79091] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78978].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78978].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_78978].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_78978].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_78978].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_78978].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78978].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_78978].field_520)
                                                    mem[mem[64] + 32] = plyr_[_78978].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_78978].field_512), plyr_[_78978].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_78978].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78978].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_78978].field_520)
                                                    if (stor4[stor8[_78978].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78978].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78978].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_78978].field_512)].field_256 += stor4[stor8[_78978].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_78978].field_520)
                                                    mem[mem[64] + 32] = plyr_[_78978].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_78978].field_512), plyr_[_78978].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var50003 = plyr_[plyr_[arg2].field_256].field_768
                                            var50005 = u + 1
                                            continue 
                                    revert with 0, 'SafeMath add failed'
                            else:
                                if var50003 <= 1554:
                                    if uint8(var56002) < uint8(-var56001 + 6):
                                        require uint8(var58001) < 6
                                        if not mem[(32 * var60001) + 448]:
                                            if not var44001:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = var44002
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(s + 1) >= 6:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _47380 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_47380]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47380], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _47669 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_47669]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47669], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    continue 
                                                var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                var50005 = s + 1
                                                continue 
                                            require uint8(var64001) < 6
                                            _55233 = mem[(32 * uint8(var64001)) + 448]
                                            mem[0] = mem[(32 * uint8(var64001)) + 448]
                                            mem[32] = 8
                                            _55288 = sha3(mem[(32 * uint8(var64001)) + 448], 8)
                                            s = uint8(var64001)
                                            t = var64001
                                            while stor3[_55288] + 1 >= stor3[_55288]:
                                                plyr_[_55233].field_768 = stor3[_55288] + 1
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55233].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55233].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_55233].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if not stor4[stor8[_55233].field_768]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                                else:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[_55233].field_520)
                                                        if sub_e5b3f6f2[address(stor8[_55233].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55233].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_55233].field_520)
                                                        mem[mem[64] + 32] = plyr_[_55233].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_55233].field_512), plyr_[_55233].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * u) + 448]
                                                    else:
                                                        if stor4[stor8[_55233].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55233].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[_55233].field_520)
                                                        if (stor4[stor8[_55233].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55233].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55233].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[_55233].field_512)].field_256 += stor4[stor8[_55233].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_55233].field_520)
                                                        mem[mem[64] + 32] = plyr_[_55233].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_55233].field_512), plyr_[_55233].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                mem[32] = 8
                                                var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                var50005 = u + 1
                                                continue 
                                        else:
                                            require uint8(var62002) < 6
                                            if not var66001:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = var66002
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(s + 1) >= 6:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _73859 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_73859]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_73859], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _74078 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_74078]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_74078], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    continue 
                                                var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                var50005 = s + 1
                                                continue 
                                            require uint8(var68001) < 6
                                            _78977 = mem[(32 * uint8(var68001)) + 448]
                                            mem[0] = mem[(32 * uint8(var68001)) + 448]
                                            mem[32] = 8
                                            _79086 = sha3(mem[(32 * uint8(var68001)) + 448], 8)
                                            s = uint8(var68001)
                                            t = var68001
                                            while stor3[_79086] + 1 >= stor3[_79086]:
                                                plyr_[_78977].field_768 = stor3[_79086] + 1
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78977].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78977].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_78977].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if not stor4[stor8[_78977].field_768]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                                else:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[_78977].field_520)
                                                        if sub_e5b3f6f2[address(stor8[_78977].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78977].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_78977].field_520)
                                                        mem[mem[64] + 32] = plyr_[_78977].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_78977].field_512), plyr_[_78977].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * u) + 448]
                                                    else:
                                                        if stor4[stor8[_78977].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78977].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[_78977].field_520)
                                                        if (stor4[stor8[_78977].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78977].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78977].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[_78977].field_512)].field_256 += stor4[stor8[_78977].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_78977].field_520)
                                                        mem[mem[64] + 32] = plyr_[_78977].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_78977].field_512), plyr_[_78977].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                mem[32] = 8
                                                var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                var50005 = u + 1
                                                continue 
                                        revert with 0, 'SafeMath add failed'
                                else:
                                    if var50003 > 9330:
                                        if uint8(var55002) < uint8(-var55001 + 6):
                                            require uint8(var57001) < 6
                                            if not mem[(32 * var59001) + 448]:
                                                if not var43001:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = var43002
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(s + 1) >= 6:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _34538 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_34538]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_34538], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _34786 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_34786]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_34786], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        continue 
                                                    var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var50005 = s + 1
                                                    continue 
                                                require uint8(var63001) < 6
                                                _42528 = mem[(32 * uint8(var63001)) + 448]
                                                mem[0] = mem[(32 * uint8(var63001)) + 448]
                                                mem[32] = 8
                                                _42575 = sha3(mem[(32 * uint8(var63001)) + 448], 8)
                                                s = uint8(var63001)
                                                t = var63001
                                                while stor3[_42575] + 1 >= stor3[_42575]:
                                                    plyr_[_42528].field_768 = stor3[_42575] + 1
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_42528].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_42528].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_42528].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if not stor4[stor8[_42528].field_768]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                    else:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[_42528].field_520)
                                                            if sub_e5b3f6f2[address(stor8[_42528].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_42528].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_42528].field_520)
                                                            mem[mem[64] + 32] = plyr_[_42528].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_42528].field_512), plyr_[_42528].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * u) + 448]
                                                        else:
                                                            if stor4[stor8[_42528].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_42528].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[_42528].field_520)
                                                            if (stor4[stor8[_42528].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_42528].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_42528].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[_42528].field_512)].field_256 += stor4[stor8[_42528].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_42528].field_520)
                                                            mem[mem[64] + 32] = plyr_[_42528].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_42528].field_512), plyr_[_42528].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * s) + 448]
                                                    mem[32] = 8
                                                    var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var50005 = u + 1
                                                    continue 
                                            else:
                                                require uint8(var61002) < 6
                                                if not var65001:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = var65002
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(s + 1) >= 6:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _60330 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_60330]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_60330], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _60590 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_60590]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_60590], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        continue 
                                                    var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var50005 = s + 1
                                                    continue 
                                                require uint8(var67001) < 6
                                                _67600 = mem[(32 * uint8(var67001)) + 448]
                                                mem[0] = mem[(32 * uint8(var67001)) + 448]
                                                mem[32] = 8
                                                _67666 = sha3(mem[(32 * uint8(var67001)) + 448], 8)
                                                s = uint8(var67001)
                                                t = var67001
                                                while stor3[_67666] + 1 >= stor3[_67666]:
                                                    plyr_[_67600].field_768 = stor3[_67666] + 1
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_67600].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_67600].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_67600].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if not stor4[stor8[_67600].field_768]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                    else:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[_67600].field_520)
                                                            if sub_e5b3f6f2[address(stor8[_67600].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_67600].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_67600].field_520)
                                                            mem[mem[64] + 32] = plyr_[_67600].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_67600].field_512), plyr_[_67600].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * u) + 448]
                                                        else:
                                                            if stor4[stor8[_67600].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_67600].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[_67600].field_520)
                                                            if (stor4[stor8[_67600].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_67600].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_67600].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[_67600].field_512)].field_256 += stor4[stor8[_67600].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_67600].field_520)
                                                            mem[mem[64] + 32] = plyr_[_67600].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_67600].field_512), plyr_[_67600].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * s) + 448]
                                                    mem[32] = 8
                                                    var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var50005 = u + 1
                                                    continue 
                                            revert with 0, 'SafeMath add failed'
                                    else:
                                        if uint8(var57002) < uint8(-var57001 + 6):
                                            require uint8(var59001) < 6
                                            if not mem[(32 * var61001) + 448]:
                                                if not var45001:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = var45002
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(s + 1) >= 6:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _47370 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_47370]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47370], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _47661 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_47661]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47661], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        continue 
                                                    var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var50005 = s + 1
                                                    continue 
                                                require uint8(var65001) < 6
                                                _55232 = mem[(32 * uint8(var65001)) + 448]
                                                mem[0] = mem[(32 * uint8(var65001)) + 448]
                                                mem[32] = 8
                                                _55286 = sha3(mem[(32 * uint8(var65001)) + 448], 8)
                                                s = uint8(var65001)
                                                t = var65001
                                                while stor3[_55286] + 1 >= stor3[_55286]:
                                                    plyr_[_55232].field_768 = stor3[_55286] + 1
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55232].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55232].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_55232].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if not stor4[stor8[_55232].field_768]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                    else:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[_55232].field_520)
                                                            if sub_e5b3f6f2[address(stor8[_55232].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55232].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_55232].field_520)
                                                            mem[mem[64] + 32] = plyr_[_55232].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_55232].field_512), plyr_[_55232].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * u) + 448]
                                                        else:
                                                            if stor4[stor8[_55232].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55232].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[_55232].field_520)
                                                            if (stor4[stor8[_55232].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55232].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55232].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[_55232].field_512)].field_256 += stor4[stor8[_55232].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_55232].field_520)
                                                            mem[mem[64] + 32] = plyr_[_55232].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_55232].field_512), plyr_[_55232].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * s) + 448]
                                                    mem[32] = 8
                                                    var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var50005 = u + 1
                                                    continue 
                                            else:
                                                require uint8(var63002) < 6
                                                if not var67001:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = var67002
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(s + 1) >= 6:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _73851 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_73851]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_73851], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _74071 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_74071]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74071], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        continue 
                                                    var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var50005 = s + 1
                                                    continue 
                                                require uint8(var69001) < 6
                                                _78976 = mem[(32 * uint8(var69001)) + 448]
                                                mem[0] = mem[(32 * uint8(var69001)) + 448]
                                                mem[32] = 8
                                                _79081 = sha3(mem[(32 * uint8(var69001)) + 448], 8)
                                                s = uint8(var69001)
                                                t = var69001
                                                while stor3[_79081] + 1 >= stor3[_79081]:
                                                    plyr_[_78976].field_768 = stor3[_79081] + 1
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78976].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78976].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_78976].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if not stor4[stor8[_78976].field_768]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                    else:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[_78976].field_520)
                                                            if sub_e5b3f6f2[address(stor8[_78976].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78976].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_78976].field_520)
                                                            mem[mem[64] + 32] = plyr_[_78976].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_78976].field_512), plyr_[_78976].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * u) + 448]
                                                        else:
                                                            if stor4[stor8[_78976].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78976].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[_78976].field_520)
                                                            if (stor4[stor8[_78976].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78976].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78976].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[_78976].field_512)].field_256 += stor4[stor8[_78976].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_78976].field_520)
                                                            mem[mem[64] + 32] = plyr_[_78976].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_78976].field_512), plyr_[_78976].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * s) + 448]
                                                    mem[32] = 8
                                                    var50003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var50005 = u + 1
                                                    continue 
                                            revert with 0, 'SafeMath add failed'
                        s = 0
                        idx = 448
                        while 640 > idx:
                            stor11[stor6][s].field_0 = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = 6
                        while 6 > idx:
                            stor11[stor6][idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        if 0 >= msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                        plyr_[stor6].field_256 = stor6
                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                        address(plyr_[stor6].field_520) = arg1
                        plyr_[stor6].field_768 = 0
                    sub_8338d556[address(arg1)]++
                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                        revert with 0, 'SafeMath add failed'
                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                    stor1++
                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                             gas gas_remaining wei
                    else:
                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                            revert with 0, 'SafeMath mul failed'
                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                             gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
            else:
                sub_d705f265[address(arg1)] = sub_cc5c8117[msg.sender]
                stor6++
                mem[96] = 0
                mem[128] = 0
                mem[160] = 0
                mem[192] = 0
                mem[224] = 0
                if not plyr_[arg2].field_256:
                    if not stor3[arg3 << 248]:
                        if 0 >= msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        if msg.value != 0:
                            revert with 0, 'sorry ether or rID is incorrect'
                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                        plyr_[stor6].field_256 = stor6
                        uint8(plyr_[stor6].field_512) = 0
                        address(plyr_[stor6].field_520) = arg1
                        plyr_[stor6].field_768 % 1 = 0
                        plyr_[stor6].field_768 = 0
                        sub_8338d556[address(arg1)]++
                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                        if stor0 < stor0:
                            revert with 0, 'SafeMath add failed'
                    else:
                        if 2 * stor3[arg3 << 248] / stor3[arg3 << 248] != 2:
                            revert with 0, 'SafeMath mul failed'
                        if 0 >= msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        if 2 * stor3[arg3 << 248] != msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                        plyr_[stor6].field_256 = stor6
                        uint8(plyr_[stor6].field_512) = 0
                        address(plyr_[stor6].field_520) = arg1
                        plyr_[stor6].field_768 % 1 = 0
                        plyr_[stor6].field_768 = 0
                        sub_8338d556[address(arg1)]++
                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                        if (2 * stor3[arg3 << 248]) + stor0 < stor0:
                            revert with 0, 'SafeMath add failed'
                        stor0 += 2 * stor3[arg3 << 248]
                    stor1++
                    if not stor3[arg3 << 248] / 100:
                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                             gas gas_remaining wei
                    else:
                        if 23 * stor3[arg3 << 248] / 100 / stor3[arg3 << 248] / 100 != 23:
                            revert with 0, 'SafeMath mul failed'
                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                           value 23 * stor3[arg3 << 248] / 100 wei
                             gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit 0xb632245f: arg3 << 248, block.timestamp, stor6, arg1
                else:
                    mem[256 len 192] = code.data[6945 len 192]
                    mem[64] = 640
                    mem[448] = plyr_[arg2].field_256
                    mem[480] = stor11[stor8[arg2].field_256].field_0
                    mem[512] = stor11[stor8[arg2].field_256].field_256
                    mem[544] = stor11[stor8[arg2].field_256].field_512
                    mem[576] = stor11[stor8[arg2].field_256].field_768
                    mem[608] = stor11[stor8[arg2].field_256].field_1024
                    mem[0] = plyr_[arg2].field_256
                    mem[32] = 8
                    if var48001 <= 6:
                        s = var48001
                        t = var48003
                        while uint8(var55002) < uint8(-var55001 + 6):
                            require uint8(var57001) < 6
                            if not mem[(32 * var59001) + 448]:
                                if not var43001:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    s = var43002
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(s + 1) >= 5:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47779 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47779]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47779], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _48051 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_48051]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_48051], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(s + 1) >= 4:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48047 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48047]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48047], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _48479 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_48479]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_48479], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(s + 1) >= 3:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _48475 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_48475]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_48475], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _48800 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_48800]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_48800], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(s + 1) >= 1:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _48467 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_48467]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_48467], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _48790 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_48790]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_48790], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if uint8(s + 1) >= 2:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _48796 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_48796]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_48796], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _49258 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_49258]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_49258], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = s + 1
                                        continue 
                                    s = plyr_[plyr_[arg2].field_256].field_768
                                    t = s + 1
                                    continue 
                                require uint8(var63001) < 6
                                _55241 = mem[(32 * uint8(var63001)) + 448]
                                mem[0] = mem[(32 * uint8(var63001)) + 448]
                                mem[32] = 8
                                _55317 = sha3(mem[(32 * uint8(var63001)) + 448], 8)
                                s = uint8(var63001)
                                t = var63001
                                while stor3[_55317] + 1 >= stor3[_55317]:
                                    plyr_[_55241].field_768 = stor3[_55317] + 1
                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55241].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55241].field_512)].field_0:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_55241].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                    if not stor4[stor8[_55241].field_768]:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            t = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[t] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                t = t + 1
                                                                idx = idx + 32
                                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    else:
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                            mem[0] = address(plyr_[_55241].field_520)
                                            if sub_e5b3f6f2[address(stor8[_55241].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55241].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_55241].field_520)
                                            mem[mem[64] + 32] = plyr_[_55241].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_55241].field_512), plyr_[_55241].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                    if uint8(u + 1) < 5:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                        if uint8(u + 1) < 4:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                            if uint8(u + 1) < 3:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                                if uint8(u + 1) < 1:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                            else:
                                                                if uint8(u + 1) < 2:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * u) + 448]
                                            mem[32] = 8
                                            u = plyr_[plyr_[arg2].field_256].field_768
                                            t = u + 1
                                            continue 
                                        if stor4[stor8[_55241].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55241].field_768]:
                                            revert with 0, 'SafeMath mul failed'
                                        mem[0] = address(plyr_[_55241].field_520)
                                        if (stor4[stor8[_55241].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55241].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55241].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_55241].field_512)].field_256 += stor4[stor8[_55241].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_55241].field_520)
                                        mem[mem[64] + 32] = plyr_[_55241].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_55241].field_512), plyr_[_55241].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    mem[0] = mem[(32 * s) + 448]
                                    mem[32] = 8
                                    s = plyr_[plyr_[arg2].field_256].field_768
                                    t = u + 1
                                    continue 
                            else:
                                require uint8(var61002) < 6
                                if not var65001:
                                    mem[0] = plyr_[arg2].field_256
                                    mem[32] = 8
                                    t = var65002
                                    while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                        if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                            if uint8(t + 1) >= 5:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(t + 1)) + 448]:
                                                require uint8(t + 1) < 6
                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74166 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74166]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74166], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74353 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74353]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74353], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        else:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                if uint8(t + 1) >= 4:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(t + 1)) + 448]:
                                                    require uint8(t + 1) < 6
                                                    if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74349 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74349]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74349], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74883 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74883]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74883], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                    if uint8(t + 1) >= 3:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(t + 1)) + 448]:
                                                        require uint8(t + 1) < 6
                                                        if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                            require uint8(t + 1) < 6
                                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _74879 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_74879]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_74879], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _75209 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_75209]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_75209], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                        if uint8(t + 1) >= 1:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(t + 1)) + 448]:
                                                            require uint8(t + 1) < 6
                                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                                require uint8(t + 1) < 6
                                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _74871 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_74871]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74871], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _75199 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_75199]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_75199], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    else:
                                                        if uint8(t + 1) >= 2:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(t + 1)) + 448]:
                                                            require uint8(t + 1) < 6
                                                            if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 < 55986:
                                                                require uint8(t + 1) < 6
                                                                if plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(t + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _75205 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_75205]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_75205], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _75561 = sha3(mem[(32 * uint8(t + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(t + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(t + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(t + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_75561]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_75561], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        t = t + 1
                                        continue 
                                    s = plyr_[plyr_[arg2].field_256].field_768
                                    t = t + 1
                                    continue 
                                require uint8(var67001) < 6
                                _78985 = mem[(32 * uint8(var67001)) + 448]
                                mem[0] = mem[(32 * uint8(var67001)) + 448]
                                mem[32] = 8
                                _79161 = sha3(mem[(32 * uint8(var67001)) + 448], 8)
                                s = uint8(var67001)
                                t = var67001
                                while stor3[_79161] + 1 >= stor3[_79161]:
                                    plyr_[_78985].field_768 = stor3[_79161] + 1
                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78985].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78985].field_512)].field_0:
                                        revert with 0, 'SafeMath add failed'
                                    sub_e5b3f6f2[address(stor8[_78985].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                    if not stor4[stor8[_78985].field_768]:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            t = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[t] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                t = t + 1
                                                                idx = idx + 32
                                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    else:
                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                            mem[0] = address(plyr_[_78985].field_520)
                                            if sub_e5b3f6f2[address(stor8[_78985].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78985].field_512)].field_256:
                                                revert with 0, 'SafeMath add failed'
                                            mem[32] = 8
                                            mem[mem[64]] = address(plyr_[_78985].field_520)
                                            mem[mem[64] + 32] = plyr_[_78985].field_768
                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            mem[mem[64] + 96] = block.timestamp
                                            emit 0x72825d8b: address(plyr_[_78985].field_512), plyr_[_78985].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                    if uint8(u + 1) < 5:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                        if uint8(u + 1) < 4:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                            if uint8(u + 1) < 3:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                                if uint8(u + 1) < 1:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                            else:
                                                                if uint8(u + 1) < 2:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * u) + 448]
                                            mem[32] = 8
                                            u = plyr_[plyr_[arg2].field_256].field_768
                                            t = u + 1
                                            continue 
                                        if stor4[stor8[_78985].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78985].field_768]:
                                            revert with 0, 'SafeMath mul failed'
                                        mem[0] = address(plyr_[_78985].field_520)
                                        if (stor4[stor8[_78985].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78985].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78985].field_512)].field_256:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_78985].field_512)].field_256 += stor4[stor8[_78985].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                        mem[32] = 8
                                        mem[mem[64]] = address(plyr_[_78985].field_520)
                                        mem[mem[64] + 32] = plyr_[_78985].field_768
                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                        mem[mem[64] + 96] = block.timestamp
                                        emit 0x72825d8b: address(plyr_[_78985].field_512), plyr_[_78985].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        u = t
                                        while plyr_[plyr_[arg2].field_256].field_768 > 6:
                                            if plyr_[plyr_[arg2].field_256].field_768 <= 42:
                                                if uint8(u + 1) < 5:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                            else:
                                                if plyr_[plyr_[arg2].field_256].field_768 <= 258:
                                                    if uint8(u + 1) < 4:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                else:
                                                    if plyr_[plyr_[arg2].field_256].field_768 <= 1554:
                                                        if uint8(u + 1) < 3:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                    else:
                                                        if plyr_[plyr_[arg2].field_256].field_768 > 9330:
                                                            if uint8(u + 1) < 1:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                        else:
                                                            if uint8(u + 1) < 2:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                            mem[0] = stor6
                                            mem[32] = 11
                                            s = sha3(mem[0 len 64])
                                            idx = 448
                                            while 640 > idx:
                                                stor[s] = mem[idx]
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                idx = idx + 32
                                                continue 
                                            idx = sha3(mem[0 len 64]) + 6
                                            while sha3(stor6, 11) + 6 > idx:
                                                stor[idx] = 0
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                idx = idx + 1
                                                continue 
                                            if 0 >= msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                revert with 0, 'sorry ether or rID is incorrect'
                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                            plyr_[stor6].field_256 = stor6
                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                            address(plyr_[stor6].field_520) = arg1
                                            plyr_[stor6].field_768 = mem[224]
                                            sub_8338d556[address(arg1)]++
                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                revert with 0, 'SafeMath add failed'
                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                            stor1++
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                     gas gas_remaining wei
                                            else:
                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                    revert with 0, 'SafeMath mul failed'
                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                     gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                    mem[0] = mem[(32 * s) + 448]
                                    mem[32] = 8
                                    s = plyr_[plyr_[arg2].field_256].field_768
                                    t = u + 1
                                    continue 
                            revert with 0, 'SafeMath add failed'
                        s = 0
                        idx = 448
                        while 640 > idx:
                            stor11[stor6][s].field_0 = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = 6
                        while 6 > idx:
                            stor11[stor6][idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        if 0 >= msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                        plyr_[stor6].field_256 = stor6
                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                        address(plyr_[stor6].field_520) = arg1
                        plyr_[stor6].field_768 = mem[224]
                    else:
                        if var51003 <= 42:
                            if uint8(var55002) < uint8(-var55001 + 6):
                                require uint8(var57001) < 6
                                if not mem[(32 * var59001) + 448]:
                                    if not var43001:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = var43002
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(s + 1) >= 6:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47470 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47470]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47470], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _47759 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_47759]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_47759], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            continue 
                                        var51003 = plyr_[plyr_[arg2].field_256].field_768
                                        var51005 = s + 1
                                        continue 
                                    require uint8(var63001) < 6
                                    _55240 = mem[(32 * uint8(var63001)) + 448]
                                    mem[0] = mem[(32 * uint8(var63001)) + 448]
                                    mem[32] = 8
                                    _55311 = sha3(mem[(32 * uint8(var63001)) + 448], 8)
                                    s = uint8(var63001)
                                    t = var63001
                                    while stor3[_55311] + 1 >= stor3[_55311]:
                                        plyr_[_55240].field_768 = stor3[_55311] + 1
                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55240].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55240].field_512)].field_0:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_55240].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                        if not stor4[stor8[_55240].field_768]:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                        else:
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                mem[0] = address(plyr_[_55240].field_520)
                                                if sub_e5b3f6f2[address(stor8[_55240].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55240].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_55240].field_520)
                                                mem[mem[64] + 32] = plyr_[_55240].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_55240].field_512), plyr_[_55240].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * u) + 448]
                                            else:
                                                if stor4[stor8[_55240].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55240].field_768]:
                                                    revert with 0, 'SafeMath mul failed'
                                                mem[0] = address(plyr_[_55240].field_520)
                                                if (stor4[stor8[_55240].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55240].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55240].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_55240].field_512)].field_256 += stor4[stor8[_55240].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_55240].field_520)
                                                mem[mem[64] + 32] = plyr_[_55240].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_55240].field_512), plyr_[_55240].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                        mem[32] = 8
                                        var51003 = plyr_[plyr_[arg2].field_256].field_768
                                        var51005 = u + 1
                                        continue 
                                else:
                                    require uint8(var61002) < 6
                                    if not var65001:
                                        mem[0] = plyr_[arg2].field_256
                                        mem[32] = 8
                                        s = var65002
                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                            if uint8(s + 1) >= 6:
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            if mem[(32 * uint8(s + 1)) + 448]:
                                                require uint8(s + 1) < 6
                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                        revert with 0, 'SafeMath add failed'
                                                    plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _73931 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_73931]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_73931], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        else:
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            _74147 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                            mem[mem[64] + 32] = stor3[_74147]
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: mem[mem[64]], stor3[_74147], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = s + 1
                                            continue 
                                        var51003 = plyr_[plyr_[arg2].field_256].field_768
                                        var51005 = s + 1
                                        continue 
                                    require uint8(var67001) < 6
                                    _78984 = mem[(32 * uint8(var67001)) + 448]
                                    mem[0] = mem[(32 * uint8(var67001)) + 448]
                                    mem[32] = 8
                                    _79140 = sha3(mem[(32 * uint8(var67001)) + 448], 8)
                                    s = uint8(var67001)
                                    t = var67001
                                    while stor3[_79140] + 1 >= stor3[_79140]:
                                        plyr_[_78984].field_768 = stor3[_79140] + 1
                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78984].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78984].field_512)].field_0:
                                            revert with 0, 'SafeMath add failed'
                                        sub_e5b3f6f2[address(stor8[_78984].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                        if not stor4[stor8[_78984].field_768]:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            u = t
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(u + 1) < 6:
                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = u + 1
                                                        continue 
                                                    require uint8(u + 1) < 6
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = uint8(u + 1)
                                                    t = u + 1
                                                    continue 
                                                mem[0] = stor6
                                                mem[32] = 11
                                                s = sha3(mem[0 len 64])
                                                idx = 448
                                                while 640 > idx:
                                                    stor[s] = mem[idx]
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    idx = idx + 32
                                                    continue 
                                                idx = sha3(mem[0 len 64]) + 6
                                                while sha3(stor6, 11) + 6 > idx:
                                                    stor[idx] = 0
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    idx = idx + 1
                                                    continue 
                                                if 0 >= msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                plyr_[stor6].field_256 = stor6
                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                address(plyr_[stor6].field_520) = arg1
                                                plyr_[stor6].field_768 = mem[224]
                                                sub_8338d556[address(arg1)]++
                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                    revert with 0, 'SafeMath add failed'
                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                stor1++
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                         gas gas_remaining wei
                                                else:
                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                        revert with 0, 'SafeMath mul failed'
                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                         gas gas_remaining wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                            mem[0] = mem[(32 * s) + 448]
                                        else:
                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                mem[0] = address(plyr_[_78984].field_520)
                                                if sub_e5b3f6f2[address(stor8[_78984].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78984].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_78984].field_520)
                                                mem[mem[64] + 32] = plyr_[_78984].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_78984].field_512), plyr_[_78984].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * u) + 448]
                                            else:
                                                if stor4[stor8[_78984].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78984].field_768]:
                                                    revert with 0, 'SafeMath mul failed'
                                                mem[0] = address(plyr_[_78984].field_520)
                                                if (stor4[stor8[_78984].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78984].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78984].field_512)].field_256:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_78984].field_512)].field_256 += stor4[stor8[_78984].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                mem[32] = 8
                                                mem[mem[64]] = address(plyr_[_78984].field_520)
                                                mem[mem[64] + 32] = plyr_[_78984].field_768
                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                mem[mem[64] + 96] = block.timestamp
                                                emit 0x72825d8b: address(plyr_[_78984].field_512), plyr_[_78984].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                        mem[32] = 8
                                        var51003 = plyr_[plyr_[arg2].field_256].field_768
                                        var51005 = u + 1
                                        continue 
                                revert with 0, 'SafeMath add failed'
                        else:
                            if var51003 <= 258:
                                if uint8(var56002) < uint8(-var56001 + 6):
                                    require uint8(var58001) < 6
                                    if not mem[(32 * var60001) + 448]:
                                        if not var44001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var44002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47460 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47460]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47460], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _47751 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_47751]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_47751], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var51003 = plyr_[plyr_[arg2].field_256].field_768
                                            var51005 = s + 1
                                            continue 
                                        require uint8(var64001) < 6
                                        _55239 = mem[(32 * uint8(var64001)) + 448]
                                        mem[0] = mem[(32 * uint8(var64001)) + 448]
                                        mem[32] = 8
                                        _55309 = sha3(mem[(32 * uint8(var64001)) + 448], 8)
                                        s = uint8(var64001)
                                        t = var64001
                                        while stor3[_55309] + 1 >= stor3[_55309]:
                                            plyr_[_55239].field_768 = stor3[_55309] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55239].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55239].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_55239].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_55239].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_55239].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_55239].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55239].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_55239].field_520)
                                                    mem[mem[64] + 32] = plyr_[_55239].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_55239].field_512), plyr_[_55239].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_55239].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55239].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_55239].field_520)
                                                    if (stor4[stor8[_55239].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55239].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55239].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_55239].field_512)].field_256 += stor4[stor8[_55239].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_55239].field_520)
                                                    mem[mem[64] + 32] = plyr_[_55239].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_55239].field_512), plyr_[_55239].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var51003 = plyr_[plyr_[arg2].field_256].field_768
                                            var51005 = u + 1
                                            continue 
                                    else:
                                        require uint8(var62002) < 6
                                        if not var66001:
                                            mem[0] = plyr_[arg2].field_256
                                            mem[32] = 8
                                            s = var66002
                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                if uint8(s + 1) >= 6:
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                if mem[(32 * uint8(s + 1)) + 448]:
                                                    require uint8(s + 1) < 6
                                                    if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                            revert with 0, 'SafeMath add failed'
                                                        plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                        if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _73923 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_73923]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_73923], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            else:
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                    revert with 0, 'SafeMath add failed'
                                                                _74140 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                mem[32] = 8
                                                                mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                mem[mem[64] + 32] = stor3[_74140]
                                                                mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                mem[mem[64] + 96] = block.timestamp
                                                                emit 0x72825d8b: mem[mem[64]], stor3[_74140], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = s + 1
                                                continue 
                                            var51003 = plyr_[plyr_[arg2].field_256].field_768
                                            var51005 = s + 1
                                            continue 
                                        require uint8(var68001) < 6
                                        _78983 = mem[(32 * uint8(var68001)) + 448]
                                        mem[0] = mem[(32 * uint8(var68001)) + 448]
                                        mem[32] = 8
                                        _79135 = sha3(mem[(32 * uint8(var68001)) + 448], 8)
                                        s = uint8(var68001)
                                        t = var68001
                                        while stor3[_79135] + 1 >= stor3[_79135]:
                                            plyr_[_78983].field_768 = stor3[_79135] + 1
                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78983].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78983].field_512)].field_0:
                                                revert with 0, 'SafeMath add failed'
                                            sub_e5b3f6f2[address(stor8[_78983].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                            if not stor4[stor8[_78983].field_768]:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                u = t
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(u + 1) < 6:
                                                        if not mem[(32 * uint8(u + 1)) + 448]:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = u + 1
                                                            continue 
                                                        require uint8(u + 1) < 6
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = uint8(u + 1)
                                                        t = u + 1
                                                        continue 
                                                    mem[0] = stor6
                                                    mem[32] = 11
                                                    s = sha3(mem[0 len 64])
                                                    idx = 448
                                                    while 640 > idx:
                                                        stor[s] = mem[idx]
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        idx = idx + 32
                                                        continue 
                                                    idx = sha3(mem[0 len 64]) + 6
                                                    while sha3(stor6, 11) + 6 > idx:
                                                        stor[idx] = 0
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        idx = idx + 1
                                                        continue 
                                                    if 0 >= msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                        revert with 0, 'sorry ether or rID is incorrect'
                                                    plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                    plyr_[stor6].field_256 = stor6
                                                    uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    address(plyr_[stor6].field_520) = arg1
                                                    plyr_[stor6].field_768 = mem[224]
                                                    sub_8338d556[address(arg1)]++
                                                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                        revert with 0, 'SafeMath add failed'
                                                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    stor1++
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                             gas gas_remaining wei
                                                    else:
                                                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                            revert with 0, 'SafeMath mul failed'
                                                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                             gas gas_remaining wei
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                mem[0] = mem[(32 * s) + 448]
                                            else:
                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                    mem[0] = address(plyr_[_78983].field_520)
                                                    if sub_e5b3f6f2[address(stor8[_78983].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78983].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_78983].field_520)
                                                    mem[mem[64] + 32] = plyr_[_78983].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_78983].field_512), plyr_[_78983].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * u) + 448]
                                                else:
                                                    if stor4[stor8[_78983].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78983].field_768]:
                                                        revert with 0, 'SafeMath mul failed'
                                                    mem[0] = address(plyr_[_78983].field_520)
                                                    if (stor4[stor8[_78983].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78983].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78983].field_512)].field_256:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_78983].field_512)].field_256 += stor4[stor8[_78983].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                    mem[32] = 8
                                                    mem[mem[64]] = address(plyr_[_78983].field_520)
                                                    mem[mem[64] + 32] = plyr_[_78983].field_768
                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                    mem[mem[64] + 96] = block.timestamp
                                                    emit 0x72825d8b: address(plyr_[_78983].field_512), plyr_[_78983].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                            mem[32] = 8
                                            var51003 = plyr_[plyr_[arg2].field_256].field_768
                                            var51005 = u + 1
                                            continue 
                                    revert with 0, 'SafeMath add failed'
                            else:
                                if var51003 <= 1554:
                                    if uint8(var57002) < uint8(-var57001 + 6):
                                        require uint8(var59001) < 6
                                        if not mem[(32 * var61001) + 448]:
                                            if not var45001:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = var45002
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(s + 1) >= 6:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _47450 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_47450]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47450], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _47743 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_47743]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_47743], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    continue 
                                                var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                var51005 = s + 1
                                                continue 
                                            require uint8(var65001) < 6
                                            _55238 = mem[(32 * uint8(var65001)) + 448]
                                            mem[0] = mem[(32 * uint8(var65001)) + 448]
                                            mem[32] = 8
                                            _55307 = sha3(mem[(32 * uint8(var65001)) + 448], 8)
                                            s = uint8(var65001)
                                            t = var65001
                                            while stor3[_55307] + 1 >= stor3[_55307]:
                                                plyr_[_55238].field_768 = stor3[_55307] + 1
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55238].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55238].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_55238].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if not stor4[stor8[_55238].field_768]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                                else:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[_55238].field_520)
                                                        if sub_e5b3f6f2[address(stor8[_55238].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55238].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_55238].field_520)
                                                        mem[mem[64] + 32] = plyr_[_55238].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_55238].field_512), plyr_[_55238].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * u) + 448]
                                                    else:
                                                        if stor4[stor8[_55238].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55238].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[_55238].field_520)
                                                        if (stor4[stor8[_55238].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55238].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55238].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[_55238].field_512)].field_256 += stor4[stor8[_55238].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_55238].field_520)
                                                        mem[mem[64] + 32] = plyr_[_55238].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_55238].field_512), plyr_[_55238].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                mem[32] = 8
                                                var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                var51005 = u + 1
                                                continue 
                                        else:
                                            require uint8(var63002) < 6
                                            if not var67001:
                                                mem[0] = plyr_[arg2].field_256
                                                mem[32] = 8
                                                s = var67002
                                                while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                    if uint8(s + 1) >= 6:
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    if mem[(32 * uint8(s + 1)) + 448]:
                                                        require uint8(s + 1) < 6
                                                        if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                revert with 0, 'SafeMath add failed'
                                                            plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                            if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                            if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _73915 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_73915]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_73915], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                else:
                                                                    if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                        revert with 0, 'SafeMath add failed'
                                                                    _74133 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                    sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                    mem[32] = 8
                                                                    mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                    mem[mem[64] + 32] = stor3[_74133]
                                                                    mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                    mem[mem[64] + 96] = block.timestamp
                                                                    emit 0x72825d8b: mem[mem[64]], stor3[_74133], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = s + 1
                                                    continue 
                                                var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                var51005 = s + 1
                                                continue 
                                            require uint8(var69001) < 6
                                            _78982 = mem[(32 * uint8(var69001)) + 448]
                                            mem[0] = mem[(32 * uint8(var69001)) + 448]
                                            mem[32] = 8
                                            _79130 = sha3(mem[(32 * uint8(var69001)) + 448], 8)
                                            s = uint8(var69001)
                                            t = var69001
                                            while stor3[_79130] + 1 >= stor3[_79130]:
                                                plyr_[_78982].field_768 = stor3[_79130] + 1
                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78982].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78982].field_512)].field_0:
                                                    revert with 0, 'SafeMath add failed'
                                                sub_e5b3f6f2[address(stor8[_78982].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                if not stor4[stor8[_78982].field_768]:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    u = t
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(u + 1) < 6:
                                                            if not mem[(32 * uint8(u + 1)) + 448]:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = u + 1
                                                                continue 
                                                            require uint8(u + 1) < 6
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = uint8(u + 1)
                                                            t = u + 1
                                                            continue 
                                                        mem[0] = stor6
                                                        mem[32] = 11
                                                        s = sha3(mem[0 len 64])
                                                        idx = 448
                                                        while 640 > idx:
                                                            stor[s] = mem[idx]
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            s = s + 1
                                                            idx = idx + 32
                                                            continue 
                                                        idx = sha3(mem[0 len 64]) + 6
                                                        while sha3(stor6, 11) + 6 > idx:
                                                            stor[idx] = 0
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            idx = idx + 1
                                                            continue 
                                                        if 0 >= msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                            revert with 0, 'sorry ether or rID is incorrect'
                                                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                        plyr_[stor6].field_256 = stor6
                                                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        address(plyr_[stor6].field_520) = arg1
                                                        plyr_[stor6].field_768 = mem[224]
                                                        sub_8338d556[address(arg1)]++
                                                        sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                            revert with 0, 'SafeMath add failed'
                                                        stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        stor1++
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                 gas gas_remaining wei
                                                        else:
                                                            if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                revert with 0, 'SafeMath mul failed'
                                                            require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                            call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                               value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                 gas gas_remaining wei
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                    mem[0] = mem[(32 * s) + 448]
                                                else:
                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                        mem[0] = address(plyr_[_78982].field_520)
                                                        if sub_e5b3f6f2[address(stor8[_78982].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78982].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_78982].field_520)
                                                        mem[mem[64] + 32] = plyr_[_78982].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_78982].field_512), plyr_[_78982].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                u = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * u) + 448]
                                                    else:
                                                        if stor4[stor8[_78982].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78982].field_768]:
                                                            revert with 0, 'SafeMath mul failed'
                                                        mem[0] = address(plyr_[_78982].field_520)
                                                        if (stor4[stor8[_78982].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78982].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78982].field_512)].field_256:
                                                            revert with 0, 'SafeMath add failed'
                                                        sub_e5b3f6f2[address(stor8[_78982].field_512)].field_256 += stor4[stor8[_78982].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                        mem[32] = 8
                                                        mem[mem[64]] = address(plyr_[_78982].field_520)
                                                        mem[mem[64] + 32] = plyr_[_78982].field_768
                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                        mem[mem[64] + 96] = block.timestamp
                                                        emit 0x72825d8b: address(plyr_[_78982].field_512), plyr_[_78982].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                mem[32] = 8
                                                var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                var51005 = u + 1
                                                continue 
                                        revert with 0, 'SafeMath add failed'
                                else:
                                    if var51003 > 9330:
                                        if uint8(var56002) < uint8(-var56001 + 6):
                                            require uint8(var58001) < 6
                                            if not mem[(32 * var60001) + 448]:
                                                if not var44001:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = var44002
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(s + 1) >= 6:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _34591 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_34591]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_34591], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _34858 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_34858]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_34858], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        continue 
                                                    var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var51005 = s + 1
                                                    continue 
                                                require uint8(var64001) < 6
                                                _42539 = mem[(32 * uint8(var64001)) + 448]
                                                mem[0] = mem[(32 * uint8(var64001)) + 448]
                                                mem[32] = 8
                                                _42587 = sha3(mem[(32 * uint8(var64001)) + 448], 8)
                                                s = uint8(var64001)
                                                t = var64001
                                                while stor3[_42587] + 1 >= stor3[_42587]:
                                                    plyr_[_42539].field_768 = stor3[_42587] + 1
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_42539].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_42539].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_42539].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if not stor4[stor8[_42539].field_768]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                    else:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[_42539].field_520)
                                                            if sub_e5b3f6f2[address(stor8[_42539].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_42539].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_42539].field_520)
                                                            mem[mem[64] + 32] = plyr_[_42539].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_42539].field_512), plyr_[_42539].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * u) + 448]
                                                        else:
                                                            if stor4[stor8[_42539].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_42539].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[_42539].field_520)
                                                            if (stor4[stor8[_42539].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_42539].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_42539].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[_42539].field_512)].field_256 += stor4[stor8[_42539].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_42539].field_520)
                                                            mem[mem[64] + 32] = plyr_[_42539].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_42539].field_512), plyr_[_42539].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * s) + 448]
                                                    mem[32] = 8
                                                    var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var51005 = u + 1
                                                    continue 
                                            else:
                                                require uint8(var62002) < 6
                                                if not var66001:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = var66002
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(s + 1) >= 6:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _60383 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_60383]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_60383], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _60668 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_60668]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_60668], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        continue 
                                                    var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var51005 = s + 1
                                                    continue 
                                                require uint8(var68001) < 6
                                                _67601 = mem[(32 * uint8(var68001)) + 448]
                                                mem[0] = mem[(32 * uint8(var68001)) + 448]
                                                mem[32] = 8
                                                _67696 = sha3(mem[(32 * uint8(var68001)) + 448], 8)
                                                s = uint8(var68001)
                                                t = var68001
                                                while stor3[_67696] + 1 >= stor3[_67696]:
                                                    plyr_[_67601].field_768 = stor3[_67696] + 1
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_67601].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_67601].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_67601].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if not stor4[stor8[_67601].field_768]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                    else:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[_67601].field_520)
                                                            if sub_e5b3f6f2[address(stor8[_67601].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_67601].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_67601].field_520)
                                                            mem[mem[64] + 32] = plyr_[_67601].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_67601].field_512), plyr_[_67601].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * u) + 448]
                                                        else:
                                                            if stor4[stor8[_67601].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_67601].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[_67601].field_520)
                                                            if (stor4[stor8[_67601].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_67601].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_67601].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[_67601].field_512)].field_256 += stor4[stor8[_67601].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_67601].field_520)
                                                            mem[mem[64] + 32] = plyr_[_67601].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_67601].field_512), plyr_[_67601].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * s) + 448]
                                                    mem[32] = 8
                                                    var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var51005 = u + 1
                                                    continue 
                                            revert with 0, 'SafeMath add failed'
                                    else:
                                        if uint8(var58002) < uint8(-var58001 + 6):
                                            require uint8(var60001) < 6
                                            if not mem[(32 * var62001) + 448]:
                                                if not var46001:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = var46002
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(s + 1) >= 6:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _47440 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_47440]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47440], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _47735 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_47735]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_47735], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        continue 
                                                    var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var51005 = s + 1
                                                    continue 
                                                require uint8(var66001) < 6
                                                _55237 = mem[(32 * uint8(var66001)) + 448]
                                                mem[0] = mem[(32 * uint8(var66001)) + 448]
                                                mem[32] = 8
                                                _55305 = sha3(mem[(32 * uint8(var66001)) + 448], 8)
                                                s = uint8(var66001)
                                                t = var66001
                                                while stor3[_55305] + 1 >= stor3[_55305]:
                                                    plyr_[_55237].field_768 = stor3[_55305] + 1
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_55237].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_55237].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_55237].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if not stor4[stor8[_55237].field_768]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                    else:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[_55237].field_520)
                                                            if sub_e5b3f6f2[address(stor8[_55237].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55237].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_55237].field_520)
                                                            mem[mem[64] + 32] = plyr_[_55237].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_55237].field_512), plyr_[_55237].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * u) + 448]
                                                        else:
                                                            if stor4[stor8[_55237].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_55237].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[_55237].field_520)
                                                            if (stor4[stor8[_55237].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_55237].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_55237].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[_55237].field_512)].field_256 += stor4[stor8[_55237].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_55237].field_520)
                                                            mem[mem[64] + 32] = plyr_[_55237].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_55237].field_512), plyr_[_55237].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * s) + 448]
                                                    mem[32] = 8
                                                    var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var51005 = u + 1
                                                    continue 
                                            else:
                                                require uint8(var64002) < 6
                                                if not var68001:
                                                    mem[0] = plyr_[arg2].field_256
                                                    mem[32] = 8
                                                    s = var68002
                                                    while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                        if uint8(s + 1) >= 6:
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        if mem[(32 * uint8(s + 1)) + 448]:
                                                            require uint8(s + 1) < 6
                                                            if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 < 55986:
                                                                require uint8(s + 1) < 6
                                                                if plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768 + 1 < plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768:
                                                                    revert with 0, 'SafeMath add failed'
                                                                plyr_[mem[(32 * uint8(s + 1)) + 448]].field_768++
                                                                if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                                if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _73907 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_73907]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_73907], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                                    else:
                                                                        if stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768]:
                                                                            revert with 0, 'SafeMath mul failed'
                                                                        mem[0] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        if (stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 < sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256:
                                                                            revert with 0, 'SafeMath add failed'
                                                                        _74126 = sha3(mem[(32 * uint8(s + 1)) + 448], 8)
                                                                        sub_e5b3f6f2[address(stor8[mem[(32 * uint8(s + 1)) + 448]].field_512)].field_256 += stor4[stor8[mem[(32 * uint8(s + 1)) + 448]].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                        mem[32] = 8
                                                                        mem[mem[64]] = address(plyr_[mem[(32 * uint8(s + 1)) + 448]].field_520)
                                                                        mem[mem[64] + 32] = stor3[_74126]
                                                                        mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                        mem[mem[64] + 96] = block.timestamp
                                                                        emit 0x72825d8b: mem[mem[64]], stor3[_74126], uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        s = s + 1
                                                        continue 
                                                    var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var51005 = s + 1
                                                    continue 
                                                require uint8(var70001) < 6
                                                _78981 = mem[(32 * uint8(var70001)) + 448]
                                                mem[0] = mem[(32 * uint8(var70001)) + 448]
                                                mem[32] = 8
                                                _79125 = sha3(mem[(32 * uint8(var70001)) + 448], 8)
                                                s = uint8(var70001)
                                                t = var70001
                                                while stor3[_79125] + 1 >= stor3[_79125]:
                                                    plyr_[_78981].field_768 = stor3[_79125] + 1
                                                    if (stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13) + sub_e5b3f6f2[address(stor8[_78981].field_512)].field_0 < sub_e5b3f6f2[address(stor8[_78981].field_512)].field_0:
                                                        revert with 0, 'SafeMath add failed'
                                                    sub_e5b3f6f2[address(stor8[_78981].field_512)].field_0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 13
                                                    if not stor4[stor8[_78981].field_768]:
                                                        mem[0] = plyr_[arg2].field_256
                                                        mem[32] = 8
                                                        u = t
                                                        while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                            if uint8(u + 1) < 6:
                                                                if not mem[(32 * uint8(u + 1)) + 448]:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = u + 1
                                                                    continue 
                                                                require uint8(u + 1) < 6
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = uint8(u + 1)
                                                                t = u + 1
                                                                continue 
                                                            mem[0] = stor6
                                                            mem[32] = 11
                                                            s = sha3(mem[0 len 64])
                                                            idx = 448
                                                            while 640 > idx:
                                                                stor[s] = mem[idx]
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                s = s + 1
                                                                idx = idx + 32
                                                                continue 
                                                            idx = sha3(mem[0 len 64]) + 6
                                                            while sha3(stor6, 11) + 6 > idx:
                                                                stor[idx] = 0
                                                                mem[0] = plyr_[arg2].field_256
                                                                mem[32] = 8
                                                                idx = idx + 1
                                                                continue 
                                                            if 0 >= msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                revert with 0, 'sorry ether or rID is incorrect'
                                                            plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                            plyr_[stor6].field_256 = stor6
                                                            uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            address(plyr_[stor6].field_520) = arg1
                                                            plyr_[stor6].field_768 = mem[224]
                                                            sub_8338d556[address(arg1)]++
                                                            sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                            if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                revert with 0, 'SafeMath add failed'
                                                            stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            stor1++
                                                            if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                     gas gas_remaining wei
                                                            else:
                                                                if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                    revert with 0, 'SafeMath mul failed'
                                                                require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                   value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                     gas gas_remaining wei
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                        mem[0] = mem[(32 * s) + 448]
                                                    else:
                                                        if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)]:
                                                            mem[0] = address(plyr_[_78981].field_520)
                                                            if sub_e5b3f6f2[address(stor8[_78981].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78981].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_78981].field_520)
                                                            mem[mem[64] + 32] = plyr_[_78981].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_78981].field_512), plyr_[_78981].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    u = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * u) + 448]
                                                        else:
                                                            if stor4[stor8[_78981].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != stor4[stor8[_78981].field_768]:
                                                                revert with 0, 'SafeMath mul failed'
                                                            mem[0] = address(plyr_[_78981].field_520)
                                                            if (stor4[stor8[_78981].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]) + sub_e5b3f6f2[address(stor8[_78981].field_512)].field_256 < sub_e5b3f6f2[address(stor8[_78981].field_512)].field_256:
                                                                revert with 0, 'SafeMath add failed'
                                                            sub_e5b3f6f2[address(stor8[_78981].field_512)].field_256 += stor4[stor8[_78981].field_768] * stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                            mem[32] = 8
                                                            mem[mem[64]] = address(plyr_[_78981].field_520)
                                                            mem[mem[64] + 32] = plyr_[_78981].field_768
                                                            mem[mem[64] + 64] = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                            mem[mem[64] + 96] = block.timestamp
                                                            emit 0x72825d8b: address(plyr_[_78981].field_512), plyr_[_78981].field_768, uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp
                                                            mem[0] = plyr_[arg2].field_256
                                                            mem[32] = 8
                                                            u = t
                                                            while plyr_[plyr_[arg2].field_256].field_768 <= 6:
                                                                if uint8(u + 1) < 6:
                                                                    if not mem[(32 * uint8(u + 1)) + 448]:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    if plyr_[mem[(32 * uint8(u + 1)) + 448]].field_768 >= 55986:
                                                                        mem[0] = plyr_[arg2].field_256
                                                                        mem[32] = 8
                                                                        u = u + 1
                                                                        continue 
                                                                    require uint8(u + 1) < 6
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = uint8(u + 1)
                                                                    t = u + 1
                                                                    continue 
                                                                mem[0] = stor6
                                                                mem[32] = 11
                                                                s = sha3(mem[0 len 64])
                                                                idx = 448
                                                                while 640 > idx:
                                                                    stor[s] = mem[idx]
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    s = s + 1
                                                                    idx = idx + 32
                                                                    continue 
                                                                idx = sha3(mem[0 len 64]) + 6
                                                                while sha3(stor6, 11) + 6 > idx:
                                                                    stor[idx] = 0
                                                                    mem[0] = plyr_[arg2].field_256
                                                                    mem[32] = 8
                                                                    idx = idx + 1
                                                                    continue 
                                                                if 0 >= msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                                                                    revert with 0, 'sorry ether or rID is incorrect'
                                                                plyr_[stor6].field_0 = plyr_[arg2].field_256
                                                                plyr_[stor6].field_256 = stor6
                                                                uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                                                                address(plyr_[stor6].field_520) = arg1
                                                                plyr_[stor6].field_768 = mem[224]
                                                                sub_8338d556[address(arg1)]++
                                                                sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                                                                if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                                                                    revert with 0, 'SafeMath add failed'
                                                                stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                                                                stor1++
                                                                if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                         gas gas_remaining wei
                                                                else:
                                                                    if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                                                                        revert with 0, 'SafeMath mul failed'
                                                                    require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                                                                    call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                                                                       value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                                                                         gas gas_remaining wei
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
                                                            mem[0] = mem[(32 * s) + 448]
                                                    mem[32] = 8
                                                    var51003 = plyr_[plyr_[arg2].field_256].field_768
                                                    var51005 = u + 1
                                                    continue 
                                            revert with 0, 'SafeMath add failed'
                        s = 0
                        idx = 448
                        while 640 > idx:
                            stor11[stor6][s].field_0 = mem[idx]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = 6
                        while 6 > idx:
                            stor11[stor6][idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        if 0 >= msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] != msg.value:
                            revert with 0, 'sorry ether or rID is incorrect'
                        plyr_[stor6].field_0 = plyr_[arg2].field_256
                        plyr_[stor6].field_256 = stor6
                        uint8(plyr_[stor6].field_512) = uint8(plyr_[plyr_[arg2].field_256].field_512)
                        address(plyr_[stor6].field_520) = arg1
                        plyr_[stor6].field_768 = 0
                    sub_8338d556[address(arg1)]++
                    sub_8338d556[address(arg1)][sub_8338d556[address(arg1)]] = stor6
                    if stor3[uint8(stor8[stor8[arg2].field_256].field_512)] + stor0 < stor0:
                        revert with 0, 'SafeMath add failed'
                    stor0 += stor3[uint8(stor8[stor8[arg2].field_256].field_512)]
                    stor1++
                    if not stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100:
                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                             gas gas_remaining wei
                    else:
                        if 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 / stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 != 23:
                            revert with 0, 'SafeMath mul failed'
                        require ext_code.size(0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1)
                        call 0x85360ca1a03e8b8b968877dfd2a39b88479d7bc1.0xd0e30db0 with:
                           value 23 * stor3[uint8(stor8[stor8[arg2].field_256].field_512)] / 100 wei
                             gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit 0xb632245f: uint8(plyr_[plyr_[arg2].field_256].field_512), block.timestamp, stor6, arg1
}



}
