contract main {




// =====================  Runtime code  =====================


address stor0;
address stor1;
uint256 stor1;
array of struct sub_f8d37189;

function sub_f8d37189(?) {
    return sub_f8d37189[address(msg.sender)].field_0
}

function _fallback() payable {
    revert
}

function sub_c4f04036(?) {
    require calldata.size - 4 >= 32
    require arg1 < sub_f8d37189[address(msg.sender)].field_0
    require arg1 < sub_f8d37189[address(msg.sender)].field_0
    require arg1 < sub_f8d37189[address(msg.sender)].field_0
    require arg1 < sub_f8d37189[address(msg.sender)].field_0
    require arg1 < sub_f8d37189[address(msg.sender)].field_0
    mem[32] = 2
    require arg1 < sub_f8d37189[address(msg.sender)].field_0
    mem[96] = stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length
    mem[128] = stor[sha3((6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1)].field_0
    idx = 128
    s = 0
    while stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + 96 > idx:
        mem[idx + 32] = stor[s + sha3((6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[64] = ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 160
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + 128] = stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length
    mem[0] = (6 * arg1) + sha3(sha3(address(msg.sender), 2)) + 2
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + 160] = stor[sha3((6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2)].field_0
    idx = ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + 160
    s = 0
    while ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length + 128 > idx:
        mem[idx + 32] = stor[s + sha3((6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 160] = sub_f8d37189[address(msg.sender)][arg1].field_0
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 256] = sub_f8d37189[address(msg.sender)][arg1].field_768
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 288] = sub_f8d37189[address(msg.sender)][arg1].field_1024
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 320] = sub_f8d37189[address(msg.sender)][arg1].field_1280
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 192] = 192
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 352] = stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 384 len ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length)] = mem[128 len ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length)]
    mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 224] = stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + 224
    mem[stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 384] = stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length
    mem[stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 416 len ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length)] = mem[ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + 160 len ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length)]
    if not stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length % 32:
        return sub_f8d37189[address(msg.sender)][arg1].field_0, 
               Array(len=stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length, data=mem[128 len ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length)], mem[(2 * ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length)) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 384 len stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length + stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + -ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + 32]),
               stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + 224,
               sub_f8d37189[address(msg.sender)][arg1].field_768,
               sub_f8d37189[address(msg.sender)][arg1].field_1024,
               sub_f8d37189[address(msg.sender)][arg1].field_1280
    mem[floor32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 416] = mem[floor32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + -stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length % 32 + 448 len stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length % 32]
    return sub_f8d37189[address(msg.sender)][arg1].field_0, 
           Array(len=stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length, data=mem[128 len ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length)], mem[(2 * ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length)) + ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + 384 len floor32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2].length) + stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + -ceil32(stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length) + 64]),
           stor[(6 * arg1) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1].length + 224,
           sub_f8d37189[address(msg.sender)][arg1].field_768,
           sub_f8d37189[address(msg.sender)][arg1].field_1024,
           sub_f8d37189[address(msg.sender)][arg1].field_1280
}

function deployToken(string arg1, string arg2, uint8 arg3, uint256 arg4) {
    require calldata.size - 4 >= 128
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + arg1.length + 36 <= calldata.size
    mem[96] = arg1.length
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + arg2.length + 36 <= calldata.size
    mem[64] = ceil32(arg1.length) + ceil32(arg2.length) + 160
    mem[ceil32(arg1.length) + 128] = arg2.length
    mem[ceil32(arg1.length) + 160 len arg2.length] = arg2[all]
    mem[ceil32(arg1.length) + arg2.length + 160] = 0
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 160 len 8255] = code.data[3990 len 8255]
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 8479] = arg3
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 8511] = arg4
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 8543] = msg.sender
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 8415] = 160
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 8575] = arg1.length
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 8607 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    if not arg1.length % 32:
        mem[ceil32(arg1.length) + ceil32(arg2.length) + 8447] = arg1.length + 192
        mem[arg1.length + ceil32(arg1.length) + ceil32(arg2.length) + 8607] = Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]
        mem[arg1.length + ceil32(arg1.length) + ceil32(arg2.length) + 8639 len ceil32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)])] = mem[ceil32(arg1.length) + 160 len ceil32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)])]
        if not Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32:
            create contract with 0 wei
                            code: mem[ceil32(arg1.length) + ceil32(arg2.length) + 160 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] + arg1.length + 8479]
        else:
            mem[floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + arg1.length + ceil32(arg1.length) + ceil32(arg2.length) + 8639] = mem[floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + arg1.length + ceil32(arg1.length) + ceil32(arg2.length) + -(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32) + 8671 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32]
            create contract with 0 wei
                            code: mem[ceil32(arg1.length) + ceil32(arg2.length) + 160 len floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + arg1.length + 8511]
    else:
        mem[floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + 8607] = mem[floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + -(arg1.length % 32) + 8639 len arg1.length % 32]
        mem[ceil32(arg1.length) + ceil32(arg2.length) + 8447] = floor32(arg1.length) + 224
        mem[floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + 8639] = Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]
        mem[floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + 8671 len ceil32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)])] = mem[ceil32(arg1.length) + 160 len ceil32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)])]
        if not Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32:
            create contract with 0 wei
                            code: mem[ceil32(arg1.length) + ceil32(arg2.length) + 160 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] + floor32(arg1.length) + 8511]
        else:
            mem[floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + 8671] = mem[floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + -(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32) + 8703 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32]
            create contract with 0 wei
                            code: mem[ceil32(arg1.length) + ceil32(arg2.length) + 160 len floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + floor32(arg1.length) + 8543]
    if not create.new_address:
        revert with ext_call.return_data[0 len return_data.size]
    stor0 = address(create.new_address)
    mem[64] = ceil32(arg1.length) + ceil32(arg2.length) + 352
    require ext_code.size(stor0)
    staticcall stor0.addressThis() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 160] = address(stor1)
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 192] = 96
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 224] = ceil32(arg1.length) + 128
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 256] = arg3
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 288] = arg4
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 320] = block.timestamp
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 352] = 0x983b2d5600000000000000000000000000000000000000000000000000000000
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 356] = msg.sender
    require ext_code.size(stor0)
    call stor0.addMinter(address arg1) with:
         gas gas_remaining wei
        args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[32] = 2
    sub_f8d37189[address(msg.sender)].field_0++
    sub_f8d37189[address(msg.sender)][sub_f8d37189[address(msg.sender)].field_0].field_0 = address(stor1)
    stor[sha3((6 * sub_f8d37189[address(msg.sender)].field_0) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 1)][].field_0 = Array(len=arg1.length, data=arg1[all])
    mem[0] = (6 * sub_f8d37189[address(msg.sender)].field_0) + sha3(sha3(address(msg.sender), 2)) + 2
    stor[sha3((6 * sub_f8d37189[address(msg.sender)].field_0) + ('map', ('mask_shl', 160, 0, 0, 'msg.sender'), ('name', 'sub_f8d37189', 2)) + 2)][].field_0 = Array(len=Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)], data=mem[ceil32(arg1.length) + 160 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]])
    sub_f8d37189[address(msg.sender)][sub_f8d37189[address(msg.sender)].field_0].field_768 = arg3
    sub_f8d37189[address(msg.sender)][sub_f8d37189[address(msg.sender)].field_0].field_1024 = arg4
    sub_f8d37189[address(msg.sender)][sub_f8d37189[address(msg.sender)].field_0].field_1280 = block.timestamp
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 352] = address(stor1)
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 384] = msg.sender
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 480] = arg3
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 512] = arg4
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 544] = block.timestamp
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 416] = 224
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 576] = arg1.length
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 608 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    if not arg1.length % 32:
        mem[ceil32(arg1.length) + ceil32(arg2.length) + 448] = arg1.length + 256
        mem[arg1.length + ceil32(arg1.length) + ceil32(arg2.length) + 608] = Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]
        mem[arg1.length + ceil32(arg1.length) + ceil32(arg2.length) + 640 len ceil32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)])] = mem[ceil32(arg1.length) + 160 len ceil32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)])]
        if not Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32:
            emit 0xef0b54fb: mem[ceil32(arg1.length) + ceil32(arg2.length) + 352 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] + arg1.length + 288]
        else:
            mem[floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + arg1.length + ceil32(arg1.length) + ceil32(arg2.length) + 640] = mem[floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + arg1.length + ceil32(arg1.length) + ceil32(arg2.length) + -(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32) + 672 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32]
            emit 0xef0b54fb: mem[ceil32(arg1.length) + ceil32(arg2.length) + 352 len floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + arg1.length + 320]
    else:
        mem[floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + 608] = mem[floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + -(arg1.length % 32) + 640 len arg1.length % 32]
        mem[ceil32(arg1.length) + ceil32(arg2.length) + 448] = floor32(arg1.length) + 288
        mem[floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + 640] = Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]
        mem[floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + 672 len ceil32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)])] = mem[ceil32(arg1.length) + 160 len ceil32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)])]
        if not Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32:
            emit 0xef0b54fb: mem[ceil32(arg1.length) + ceil32(arg2.length) + 352 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] + floor32(arg1.length) + 320]
        else:
            mem[floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + 672] = mem[floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + floor32(arg1.length) + ceil32(arg1.length) + ceil32(arg2.length) + -(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32) + 704 len Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)] % 32]
            emit 0xef0b54fb: mem[ceil32(arg1.length) + ceil32(arg2.length) + 352 len floor32(Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 0), mem[arg1.length + 160 len -arg1.length + ceil32(arg1.length)]) + floor32(arg1.length) + 352]
}



}
