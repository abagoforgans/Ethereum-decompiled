contract main {


// =======================  Init code  ======================


uint256 stor1;

function _fallback() payable {
    stor1 = 0
    return code.data[26 len 1326]
}



// =====================  Runtime code  =====================


array of address stor0;
uint256 sub_5e02eb7d;
array of struct stor18569430475105882587588266137607568536673111973893317399460219858819262702948;
array of uint256 stor18569430475105882587588266137607568536673111973893317399460219858819262702949;

function sub_5e02eb7d(?) payable {
    return sub_5e02eb7d
}

function changeName(string arg1) payable {
  stop
}

function test() payable {
    call msg.sender with:
       value eth.balance(this.address) wei
         gas 0 wei
}

function sqrt(uint256 arg1) payable {
    if arg1 > stor0.length:
        return 0
    require arg1 < stor0.length
    return stor290D[arg1]
}

function sub_f26f09aa(?) payable {
    require arg1 < stor0.length
    mem[224] = uint256(stor[sha3((3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564)])
    idx = 224
    s = 0
    while stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length + 224 > idx + 32:
        mem[idx + 32] = uint256(stor[s + sha3((3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564) + 1])
        idx = idx + 32
        s = s + 1
        continue 
    return address(stor0[arg1]), 
           Array(len=stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length, data=mem[224 len stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length + (floor32(stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length - 1) + -stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length + 32 % 32)]),
           stor290D[arg1]
}

function Enter() payable {
    if 10^15 == msg.value:
        stor0.length++
        if not stor0.length <= stor0.length + 1:
            mem[0] = 0
            idx = (3 * stor0.length) + 3
            while sha3(0) + (3 * stor0.length) > idx + sha3(mem[0]):
                address(stor[idx + sha3(mem[0])]) = 0
                uint256(stor[idx + sha3(mem[0]) + 1]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 1].length:
                    mem[0] = idx + sha3(mem[0]) + 1
                    s = sha3(idx + sha3(mem[0]) + 1)
                    while sha3(idx + sha3(mem[0]) + 1) + (stor[idx + sha3(mem[0]) + 1].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 2]) = 0
                idx = idx + 1
                continue 
        require stor0.length < stor0.length
        uint256(stor0[stor0.length]) = msg.sender or Mask(96, 160, uint256(stor0[stor0.length]))
        bool(stor290D[stor0.length].field_0) = 0
        uint255(stor290D[stor0.length].field_1) = 10
        Mask(248, 0, stor290D[stor0.length].field_8) = 'Calculated' / 256
        idx = 0
        while stor[(3 * stor0.length) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length + 31 / 32 > idx:
            uint256(stor[idx + sha3((3 * stor0.length) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564)]) = 0
            idx = idx + 1
            continue 
        s = sub_5e02eb7d + 1 / 2
        t = sub_5e02eb7d
        while s < t:
            s = s + (sub_5e02eb7d / s) / 2
            t = s
            continue 
        require stor0.length < stor0.length
        stor290D[stor0.length] = t
        sub_5e02eb7d += 10^18
}

function _fallback() payable {
    if 10^15 == msg.value:
        stor0.length++
        if not stor0.length <= stor0.length + 1:
            mem[0] = 0
            idx = (3 * stor0.length) + 3
            while sha3(0) + (3 * stor0.length) > idx + sha3(mem[0]):
                address(stor[idx + sha3(mem[0])]) = 0
                uint256(stor[idx + sha3(mem[0]) + 1]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 1].length:
                    mem[0] = idx + sha3(mem[0]) + 1
                    s = sha3(idx + sha3(mem[0]) + 1)
                    while sha3(idx + sha3(mem[0]) + 1) + (stor[idx + sha3(mem[0]) + 1].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 2]) = 0
                idx = idx + 1
                continue 
        require stor0.length < stor0.length
        uint256(stor0[stor0.length]) = msg.sender or Mask(96, 160, uint256(stor0[stor0.length]))
        bool(stor290D[stor0.length].field_0) = 0
        uint255(stor290D[stor0.length].field_1) = 10
        Mask(248, 0, stor290D[stor0.length].field_8) = 'Calculated' / 256
        idx = 0
        while stor[(3 * stor0.length) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length + 31 / 32 > idx:
            uint256(stor[idx + sha3((3 * stor0.length) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564)]) = 0
            idx = idx + 1
            continue 
        s = sub_5e02eb7d + 1 / 2
        t = sub_5e02eb7d
        while s < t:
            s = s + (sub_5e02eb7d / s) / 2
            t = s
            continue 
        require stor0.length < stor0.length
        stor290D[stor0.length] = t
        sub_5e02eb7d += 10^18
}



}
