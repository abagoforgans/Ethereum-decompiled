contract main {


// =======================  Init code  ======================


address stor0;
array of struct stor2;
bool stor10; offset 256
uint8 stor10;
uint16 stor10; offset 168
uint128 stor10; offset 168
uint256 stor10; offset 8
uint256 stor11;
uint8 stor12;
uint8 stor12; offset 8
uint256 stor13;
bool stor14; offset 256
uint8 stor14;
uint8 stor14; offset 8
uint8 stor14; offset 16
uint8 stor14; offset 24
uint16 stor14; offset 32
uint256 stor15;
uint8 stor16;
uint8 stor16; offset 8
uint256 stor17;
uint256 stor18;
uint256 stor19;
uint256 stor20;

function _fallback() payable {
    if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:
        stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed
        stor20 = 700000
        Mask(248, 0, stor10.field_8) = Mask(248, 0, msg.sender)
        uint16(stor10.field_168) = 333
        Mask(88, 0, stor10.field_168) = 0
        stor10.field_256 % 1 = 0
        stor11 = 10^17
        uint8(stor12.field_0) = 100
        uint8(stor12.field_8) = 0
        stor13 = 10^15
        uint8(stor10.field_0) = 0
        uint8(stor14.field_0) = 20
        uint8(stor14.field_8) = 0
        uint8(stor14.field_16) = 30
        uint8(stor14.field_24) = 0
        uint16(stor14.field_32) = 500
        stor14.field_256 % 1 = 0
        stor14.field_256 % 1 = 0
        stor15 = 10^18
        stor17 = 0
        stor18 = 0
        stor19 = 0
        uint8(stor16.field_0) = 10
        uint8(stor16.field_8) = 0
        stor2.length++
        if not stor2.length <= stor2.length + 1:
            idx = 2 * stor2.length + 1
            while 2 * stor2.length > idx:
                stor2[idx].field_0 = 0
                stor2[idx].field_256 = 0
                idx = idx + 2
                continue 
    else:
        if ext_code.size(0x9efbea6358bed926b293d2ce63a730d6d98d43dd) > 0:
            stor0 = 0x9efbea6358bed926b293d2ce63a730d6d98d43dd
            stor20 = 700000
            Mask(248, 0, stor10.field_8) = Mask(248, 0, msg.sender)
            uint16(stor10.field_168) = 333
            Mask(88, 0, stor10.field_168) = 0
            stor10.field_256 % 1 = 0
            stor11 = 10^17
            uint8(stor12.field_0) = 100
            uint8(stor12.field_8) = 0
            stor13 = 10^15
            uint8(stor10.field_0) = 0
            uint8(stor14.field_0) = 20
            uint8(stor14.field_8) = 0
            uint8(stor14.field_16) = 30
            uint8(stor14.field_24) = 0
            uint16(stor14.field_32) = 500
            stor14.field_256 % 1 = 0
            stor14.field_256 % 1 = 0
            stor15 = 10^18
            stor17 = 0
            stor18 = 0
            stor19 = 0
            uint8(stor16.field_0) = 10
            uint8(stor16.field_8) = 0
            stor2.length++
            if not stor2.length <= stor2.length + 1:
                idx = 2 * stor2.length + 1
                while 2 * stor2.length > idx:
                    stor2[idx].field_0 = 0
                    stor2[idx].field_256 = 0
                    idx = idx + 2
                    continue 
        else:
            if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:
                stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf
                stor20 = 700000
                Mask(248, 0, stor10.field_8) = Mask(248, 0, msg.sender)
                uint16(stor10.field_168) = 333
                Mask(88, 0, stor10.field_168) = 0
                stor10.field_256 % 1 = 0
                stor11 = 10^17
                uint8(stor12.field_0) = 100
                uint8(stor12.field_8) = 0
                stor13 = 10^15
                uint8(stor10.field_0) = 0
                uint8(stor14.field_0) = 20
                uint8(stor14.field_8) = 0
                uint8(stor14.field_16) = 30
                uint8(stor14.field_24) = 0
                uint16(stor14.field_32) = 500
                stor14.field_256 % 1 = 0
                stor14.field_256 % 1 = 0
                stor15 = 10^18
                stor17 = 0
                stor18 = 0
                stor19 = 0
                uint8(stor16.field_0) = 10
                uint8(stor16.field_8) = 0
                stor2.length++
                if not stor2.length <= stor2.length + 1:
                    idx = 2 * stor2.length + 1
                    while 2 * stor2.length > idx:
                        stor2[idx].field_0 = 0
                        stor2[idx].field_256 = 0
                        idx = idx + 2
                        continue 
            else:
                if ext_code.size(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60) > 0:
                    stor0 = 0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60
                stor20 = 700000
                Mask(248, 0, stor10.field_8) = Mask(248, 0, msg.sender)
                uint16(stor10.field_168) = 333
                Mask(88, 0, stor10.field_168) = 0
                stor10.field_256 % 1 = 0
                stor11 = 10^17
                uint8(stor12.field_0) = 100
                uint8(stor12.field_8) = 0
                stor13 = 10^15
                uint8(stor10.field_0) = 0
                uint8(stor14.field_0) = 20
                uint8(stor14.field_8) = 0
                uint8(stor14.field_16) = 30
                uint8(stor14.field_24) = 0
                uint16(stor14.field_32) = 500
                stor14.field_256 % 1 = 0
                stor14.field_256 % 1 = 0
                stor15 = 10^18
                stor17 = 0
                stor18 = 0
                stor19 = 0
                uint8(stor16.field_0) = 10
                uint8(stor16.field_8) = 0
                stor2.length++
                if not stor2.length <= stor2.length + 1:
                    idx = 2 * stor2.length + 1
                    while 2 * stor2.length > idx:
                        stor2[idx].field_0 = 0
                        stor2[idx].field_256 = 0
                        idx = idx + 2
                        continue 
    stor2[stor2.length].field_0 = 0
    stor2[stor2.length].field_256 = block.timestamp
    emit 0xd1036861: block.timestamp, stor2.length - 1
    emit 0xcac18c3f: 0, stor2.length - 1
    return code.data[849 len 16535]
}



// =====================  Runtime code  =====================


#
#  - sub_0a1ad345(?)
#  - getNumbersFromString(string arg1, string arg2, uint16 arg3)
#  - __callback(bytes32 arg1, string arg2)
#  - sub_75ab18f0(?)
#  - sub_78fcc02a(?)
#  - sub_ace1e134(?)
#
address stor0;
array of struct sub_fc0e01c7;
array of struct stor3;
mapping of struct players;
array of address stor5;
mapping of struct sponsors;
array of address sub_7368403d;
array of struct stor8;
array of struct sub_7dbc84e2;
uint8 state;
uint16 stor10;
uint16 sub_279b81b7; offset 168
uint128 stor10; offset 168
address developerAddress; offset 8
uint256 stor10; offset 8
uint256 sub_7ccbe9f1;
uint16 sub_7233e791;
uint256 stor12;
uint256 sub_a0d9afc5;
uint16 sub_7f1ed54f;
uint16 sub_91908600; offset 16
uint16 sub_9b2fdb27; offset 32
uint256 stor14; offset 48
uint256 stor14; offset 32
uint256 sub_c49080b2;
uint16 sub_0c95124b;
uint256 stor16;
uint256 sub_44e79c11;
uint256 sub_a0cec6a9;
uint256 sub_81eb346a;
uint256 oraclizeGasLimit;
array of address sub_8f88236c;
array of uint256 stor29102676481673041902632991033461445430619272659676223336789171408008386403023;
array of uint256 stor87903029871075914254377627908054574944891091886930582284385770809450030037084;
array of uint256 stor87903029871075914254377627908054574944891091886930582284385770809450030037085;
array of uint256 stor87903029871075914254377627908054574944891091886930582284385770809450030037086;
array of uint256 stor87903029871075914254377627908054574944891091886930582284385770809450030037087;
array of uint256 stor87903029871075914254377627908054574944891091886930582284385770809450030037088;
array of uint256 stor87903029871075914254377627908054574944891091886930582284385770809450030037089;
array of uint256 stor87903029871075914254377627908054574944891091886930582284385770809450030037090;
array of uint256 stor87903029871075914254377627908054574944891091886930582284385770809450030037091;
array of uint256 stor110349606679412691172957834289542550319383271247755660854362242977991410020069;
array of uint256 stor110349606679412691172957834289542550319383271247755660854362242977991410020070;
array of uint256 stor110349606679412691172957834289542550319383271247755660854362242977991410020071;
array of uint256 stor110349606679412691172957834289542550319383271247755660854362242977991410020072;

function sub_0c95124b(?) {
    return uint16(sub_0c95124b)
}

function sub_0dfc0588(?) {
    return sub_fc0e01c7.length
}

function betsCount() {
    return stor3.length
}

function sub_279b81b7(?) {
    return sub_279b81b7
}

function sub_44e79c11(?) {
    return sub_44e79c11
}

function oraclizeGasLimit() {
    return oraclizeGasLimit
}

function sub_7233e791(?) {
    return uint16(sub_7233e791)
}

function sub_7368403d(?) {
    require arg1 < sub_7368403d.length
    return sub_7368403d[arg1]
}

function sub_7ccbe9f1(?) {
    return sub_7ccbe9f1
}

function sub_7dbc84e2(?) {
    require arg1 < sub_7dbc84e2.length
    return address(sub_7dbc84e2[arg1].field_0)
}

function sub_7f1ed54f(?) {
    return sub_7f1ed54f
}

function sub_81eb346a(?) {
    return sub_81eb346a
}

function sub_8f88236c(?) {
    require arg1 < stor5.length
    return sub_8f88236c[arg1]
}

function sub_91908600(?) {
    return sub_91908600
}

function sub_9b2fdb27(?) {
    return sub_9b2fdb27
}

function sub_a0cec6a9(?) {
    return sub_a0cec6a9
}

function sub_a0d9afc5(?) {
    return sub_a0d9afc5
}

function playersCount() {
    return stor5.length
}

function sub_bcc254f2(?) {
    return sub_7368403d.length
}

function state() {
    return state
}

function sub_c49080b2(?) {
    return sub_c49080b2
}

function developer() {
    return developerAddress
}

function sponsors(address arg1) {
    mem[224] = uint256(sponsors[arg1].field_0)
    idx = 224
    s = 0
    while sponsors[arg1].length + 224 > idx + 32:
        mem[idx + 32] = uint256(sponsors[arg1][s].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    return Array(len=sponsors[arg1].length, data=mem[224 len sponsors[arg1].length + (floor32(sponsors[arg1].length - 1) + -sponsors[arg1].length + 32 % 32)]), 
           uint256(sponsors[arg1].field_256),
           bool(uint8(sponsors[arg1].field_512))
}

function players(address arg1) {
    return uint256(players[arg1].field_0), bool(uint8(players[arg1].field_256))
}

function sub_e9adaab0(?) {
    return stor8.length
}

function sub_fc0e01c7(?) {
    require sub_fc0e01c7.length - 1 < sub_fc0e01c7.length
    return uint256(sub_fc0e01c7[sub_fc0e01c7.length - 1].field_0)
}

function _fallback() {
    revert 
}

function sub_02010d6d(?) {
    return (arg1 * arg2 / 10000)
}

function sub_81bbc85a(?) {
    return (sub_fc0e01c7.length - 1)
}

function sub_9aacbdf0(?) {
    if arg1 < 0:
        return arg1 >= 0
    return (arg1 < sub_279b81b7)
}

function sub_40438aea(?) {
    require msg.sender == developerAddress
    state = 0
    emit 0xe7221785: 0
}

function sub_4269f66a(?) {
    require msg.sender == developerAddress
    state = 1
    emit 0xe7221785: 1
}

function sub_bde8e5dc(?) {
    require arg1 < sub_fc0e01c7.length
    return uint256(sub_fc0e01c7[arg1].field_0), stor4057[arg1]
}

function sub_191f2405(?) {
    require msg.sender == developerAddress
    require arg1 >= 0
    uint256(stor16) = arg1 or Mask(240, 16, uint256(stor16))
}

function changeDeveloper(address arg1) {
    require msg.sender == developerAddress
    require arg1 != 0
    Mask(248, 0, stor10.field_8) = Mask(248, 0, arg1)
}

function sub_99b52dfc(?) {
    if sub_7dbc84e2.length != 0:
        require sub_7dbc84e2.length - 1 < sub_7dbc84e2.length
        return 0
    else:
        return 0
}

function sub_aad1fe2d(?) {
    idx = stor3.length - 1
    while idx >= 0:
        require idx < stor3.length
        mem[0] = 3
        if uint256(stor3[idx].field_1792) != arg1:
            idx = idx - 1
            continue 
        return 1, idx
    return 0
}

function bets(uint256 arg1) {
    require arg1 < stor3.length
    return address(stor3[arg1].field_0), 
           storC257[arg1],
           storC257[arg1],
           storC257[arg1],
           storC257[arg1],
           storC257[arg1],
           storC257[arg1]
}

function sub_2cea1417(?) {
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    idx = 0
    while idx < arg1.length:
        require idx < arg1.length
        if mem[(32 * idx) + 140 len 20] != arg2:
            idx = idx + 1
            continue 
        return 1
    return 0
}

function sub_9eaab184(?) {
    require msg.sender == developerAddress
    require sub_fc0e01c7.length - 1 < sub_fc0e01c7.length
    call developerAddress with:
       value eth.balance(this.address) - uint256(sub_fc0e01c7[sub_fc0e01c7.length - 1].field_0) wei
         gas 2300 * is_zero(value) wei
    require ext_call.success
}

function sub_147749bd(?) {
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    idx = 0
    while idx < arg1.length:
        require idx < arg1.length
        require mem[(32 * idx) + 158 len 2] >= 0
        require mem[(32 * idx) + 158 len 2] < sub_279b81b7
        idx = idx + 1
        continue 
    return 0
}

function getOraclizeFee() {
    require ext_code.size(stor0)
    call stor0.getAddress() with:
         gas gas_remaining - 50 wei
    require ext_call.success
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).getPrice(string rg1, uint256 rg2) with:
         gas gas_remaining - 50 wei
        args 0, 64, oraclizeGasLimit, 3, 0x55524c0000000000000000000000000000000000000000000000000000000000
    require ext_call.success
    return ext_call.return_data[0]
}

function setOraclizeGasLimit(uint256 arg1) {
    require msg.sender == developerAddress
    require arg1 >= 0
    oraclizeGasLimit = arg1
    require ext_code.size(stor0)
    call stor0.getAddress() with:
         gas gas_remaining - 50 wei
    require ext_call.success
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).getPrice(string rg1, uint256 rg2) with:
         gas gas_remaining - 50 wei
        args 0, 64, oraclizeGasLimit, 3, 0x55524c0000000000000000000000000000000000000000000000000000000000
    require ext_call.success
    emit 0x5bd5dbbb: ext_call.return_data[0]
}

function getSettings() {
    require ext_code.size(stor0)
    call stor0.getAddress() with:
         gas gas_remaining - 50 wei
    require ext_call.success
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).getPrice(string rg1, uint256 rg2) with:
         gas gas_remaining - 50 wei
        args 0, 64, oraclizeGasLimit, 3, 0x55524c0000000000000000000000000000000000000000000000000000000000
    require ext_call.success
    return sub_7ccbe9f1, 
           0,
           uint16(sub_7233e791),
           sub_a0d9afc5,
           sub_7f1ed54f,
           sub_91908600,
           sub_7f1ed54f,
           sub_c49080b2,
           ext_call.return_data[0]
}

function sub_979b2c56(?) {
    require msg.sender == developerAddress
    require arg3 >= 0
    require arg3 <= uint16(sub_7233e791)
    require arg1 >= sub_7ccbe9f1
    require arg2 >= sub_279b81b7
    require arg5 >= 0
    require arg6 >= 0
    require arg7 >= 0
    Mask(88, 0, stor10.field_168) = Mask(88, 0, arg2)
    sub_7ccbe9f1 = arg1
    uint256(stor12) = arg3 or Mask(240, 16, uint256(stor12))
    sub_a0d9afc5 = arg3 * arg1 / 10000
    sub_7f1ed54f = arg4
    sub_91908600 = arg5
    Mask(224, 0, stor14.field_32) = Mask(224, 0, arg6)
    Mask(208, 0, stor14.field_48) = Mask(208, 32, arg5) >> 32
    Mask(208, 0, stor14.field_48) = Mask(208, 48, arg4) >> 48
    sub_c49080b2 = arg7
    emit 0x802b1579: sub_7ccbe9f1, uint16(stor10.field_0), uint16(sub_7233e791), arg3 * arg1 / 10000, arg4, arg5 << 240, arg6 << 240, arg7
}

function sub_3951cb97(?) {
    require sub_fc0e01c7.length - 1 < sub_fc0e01c7.length
    if sub_7dbc84e2.length:
        mem[160] = address(sub_7dbc84e2.field_0)
        idx = 160
        s = 0
        while (32 * sub_7dbc84e2.length) + 128 > idx:
            mem[idx + 32] = address(sub_7dbc84e2[s].field_256)
            idx = idx + 32
            s = s + 1
            continue 
    return state, 
           uint256(sub_fc0e01c7[sub_fc0e01c7.length - 1].field_0),
           uint256(sub_fc0e01c7[sub_fc0e01c7.length - 1].field_256),
           sub_44e79c11,
           sub_fc0e01c7.length,
           stor3.length,
           sub_a0cec6a9,
           stor5.length,
           sub_7368403d.length,
           stor8.length,
           sub_81eb346a,
           Array(len=sub_7dbc84e2.length, data=mem[160 len 32 * sub_7dbc84e2.length])
}

function sub_dda71585(?) {
    s = 0
    idx = 0
    while idx < sub_7dbc84e2.length - 1:
        s = 0
        while s < sub_7dbc84e2.length + -idx - 1:
            require s + 1 < sub_7dbc84e2.length
            require s < sub_7dbc84e2.length
            mem[0] = address(sub_7dbc84e2[s].field_0)
            mem[32] = 6
            if uint256(sponsors[address(stor9[s].field_0)].field_256) < uint256(sponsors[address(stor9[s].field_256)].field_256):
                require s + 1 < sub_7dbc84e2.length
                require s < sub_7dbc84e2.length
                require s + 1 < sub_7dbc84e2.length
                mem[0] = 9
                address(sub_7dbc84e2[s].field_256) = address(sub_7dbc84e2[s].field_0)
                address(sub_7dbc84e2[s].field_0) = address(sub_7dbc84e2[s].field_256)
            s = s + 1
            continue 
        s = s
        idx = idx + 1
        continue 
}

function withdraw() {
    require 0 == state
    if uint256(players[address(msg.sender)].field_0) <= 0:
    if not uint8(players[address(msg.sender)].field_256):
        stor5.length++
        if not stor5.length <= stor5.length + 1:
            idx = stor5.length + 1
            while stor5.length > idx:
                uint256(stor5[idx]) = 0
                idx = idx + 1
                continue 
        uint256(stor5[stor5.length]) = msg.sender or Mask(96, 160, uint256(stor5[stor5.length]))
        emit onNewPlayer(msg.sender, block.timestamp, stor5.length);
    uint8(players[address(msg.sender)].field_256) = 1
    uint256(players[address(msg.sender)].field_0) = 0
    emit 0xf2614ced: msg.sender, uint256(players[address(msg.sender)].field_0)
    call msg.sender with:
       value uint256(players[address(msg.sender)].field_0) wei
         gas 2300 * is_zero(value) wei
    require ext_call.success
}

function sub_a74194af(?) {
    require arg1 < stor8.length
    mem[320] = uint256(stor[sha3((6 * arg1) - 0xc085601c9b05546c4de925af5cdebeab0dd5f5d4bea4dc57b37e961749c911c)].field_0)
    idx = 320
    s = 0
    while stor[(6 * arg1) - 0xc085601c9b05546c4de925af5cdebeab0dd5f5d4bea4dc57b37e961749c911c].length + 320 > idx + 32:
        mem[idx + 32] = uint256(stor[s + sha3((6 * arg1) - 0xc085601c9b05546c4de925af5cdebeab0dd5f5d4bea4dc57b37e961749c911c) + 1].field_0)
        idx = idx + 32
        s = s + 1
        continue 
    return address(stor8[arg1].field_0), 
           Array(len=stor[(6 * arg1) - 0xc085601c9b05546c4de925af5cdebeab0dd5f5d4bea4dc57b37e961749c911c].length, data=mem[320 len stor[(6 * arg1) - 0xc085601c9b05546c4de925af5cdebeab0dd5f5d4bea4dc57b37e961749c911c].length + (floor32(stor[(6 * arg1) - 0xc085601c9b05546c4de925af5cdebeab0dd5f5d4bea4dc57b37e961749c911c].length - 1) + -stor[(6 * arg1) - 0xc085601c9b05546c4de925af5cdebeab0dd5f5d4bea4dc57b37e961749c911c].length + 32 % 32)]),
           storF3F7[arg1],
           storF3F7[arg1],
           storF3F7[arg1],
           storF3F7[arg1]
}

function bytes32ToString(bytes32 arg1) {
    mem[96] = 0
    mem[128] = 0
    mem[160] = 0
    mem[192] = 32
    s = 0
    idx = 0
    s = 0
    while idx < 32:
        if 0 == Mask(8, 248, arg1 * 2^(8 * idx)):
            s = arg1 * 2^(8 * idx)
            idx = idx + 1
            s = s
            continue 
        require s < 32
        mem[s + 224 len 8] = Mask(8, -(('mask_shl', 8, 248, -3, ('mul', ('param', 'arg1'), ('exp', 2, ('mask_shl', 253, 0, 3, ('var', 0))))), 0) + 256, 0) << (('mask_shl', 8, 248, -3, ('mul', ('param', 'arg1'), ('exp', 2, ('mask_shl', 253, 0, 3, ('var', 0))))), 0) - 256
        s = arg1 * 2^(8 * idx)
        idx = idx + 1
        s = s + 1
        continue 
    _msize = max(0, s + 8)
    mem[_msize + 224] = s
    mem[64] = (_msize + 224) + (32 * s) + 32
    t = 0
    while t < s:
        require t < 32
        require t < mem[_msize + 224]
        mem[(_msize + 224) + t + 32 len 8] = Mask(8, -(('mask_shl', 8, 248, -3, ('mem', ('range', ('add', 224, ('var', 2)), 32))), 0) + 256, 0) << (('mask_shl', 8, 248, -3, ('mem', ('range', ('add', 224, ('var', 2)), 32))), 0) - 256
        t = t + 1
        continue 
    mem[(_msize + 224) + (32 * s) + 32] = 32
    mem[(_msize + 224) + (32 * s) + 64] = mem[_msize + 224]
    mem[(_msize + 224) + (32 * s) + 96 len mem[_msize + 224]] = mem[(_msize + 224) + 32 len mem[_msize + 224]]
    if not mem[max(0, s + 8) + 224] % 32:
        return 32, mem[(_msize + 224) + (32 * s) + 64 len mem[_msize + 224] + 32]
    mem[floor32(mem[_msize + 224]) + (_msize + 224) + (32 * s) + 96] = mem[floor32(mem[_msize + 224]) + (_msize + 224) + (32 * s) + -(mem[_msize + 224] % 32) + 128 len mem[_msize + 224] % 32]
    return Array(len=mem[_msize + 224], data=mem[(_msize + 224) + (32 * s) + 96 len floor32(mem[_msize + 224]) + 32])
}

function getBet(uint256 arg1) {
    if arg1 >= stor3.length:
        return 0, 288, 320, 0, 0, 0, 0, 0, 0, 0, 0, 0, None
    if storC257[arg1]:
        mem[192] = uint16(stor[sha3((9 * arg1) - 0x3da8a5f161a6c3ff06a60736d0ed24d7963cc6a5c4fafd2fa1dae9bb908e07a4)].field_0)
        idx = 192
        s = 0
        while (32 * storC257[arg1]) + 160 > idx:
            mem[idx + 32] = uint16(stor[sha3((9 * arg1) - 0x3da8a5f161a6c3ff06a60736d0ed24d7963cc6a5c4fafd2fa1dae9bb908e07a4)].field_8 * (2 * -(s + 3 / 32) + 1) + s - (s + 3 / 32 * s))
            idx = idx + 32
            s = (2 * -(s + 3 / 32) + 1) + s - (s + 3 / 32 * s)
            continue 
    if storC257[arg1]:
        mem[(32 * storC257[arg1]) + 224] = uint16(stor[sha3((9 * arg1) - 0x3da8a5f161a6c3ff06a60736d0ed24d7963cc6a5c4fafd2fa1dae9bb908e07a3)].field_0)
        idx = (32 * storC257[arg1]) + 224
        s = 0
        while (32 * storC257[arg1]) + (32 * storC257[arg1]) + 192 > idx:
            mem[idx + 32] = uint16(stor[sha3((9 * arg1) - 0x3da8a5f161a6c3ff06a60736d0ed24d7963cc6a5c4fafd2fa1dae9bb908e07a3)].field_8 * (2 * -(s + 3 / 32) + 1) + s - (s + 3 / 32 * s))
            idx = idx + 32
            s = (2 * -(s + 3 / 32) + 1) + s - (s + 3 / 32 * s)
            continue 
    mem[(64 * storC257[arg1]) + (32 * storC257[arg1]) + 544] = storC257[arg1]
    mem[(64 * storC257[arg1]) + (32 * storC257[arg1]) + 576 len 32 * storC257[arg1]] = mem[(32 * storC257[arg1]) + 224 len 32 * storC257[arg1]]
    return address(stor3[arg1].field_0), 
           Array(len=storC257[arg1], data=mem[192 len 32 * storC257[arg1]], storC257[arg1], mem[(32 * storC257[arg1]) + 224 len 32 * storC257[arg1]]),
           (32 * storC257[arg1]) + 320,
           storC257[arg1],
           storC257[arg1],
           storC257[arg1],
           storC257[arg1],
           storC257[arg1],
           storC257[arg1]
}

function sub_e3261454(?) payable {
    mem[64] = 96
    require not msg.value
    require msg.sender == developerAddress
    s = 0
    s = 0
    idx = 0
    while idx < stor5.length:
        mem[0] = address(stor5[idx])
        mem[32] = 4
        if uint256(players[address(stor5[idx])].field_0) > 0:
            call address(stor5[idx]) with:
               value uint256(players[address(stor5[idx])].field_0) wei
                 gas 2300 * is_zero(value) wei
            require ext_call.success
            mem[32] = 4
            if not uint8(players[address(stor5[idx])].field_256):
                stor5.length++
                if not stor5.length <= stor5.length + 1:
                    s = stor5.length + sha3(5) + 1
                    while sha3(5) + stor5.length > s:
                        uint256(stor[s].field_0) = 0
                        s = s + 1
                        continue 
                address(stor5[stor5.length]) = address(stor5[idx])
                mem[mem[64] + 32] = block.timestamp
                mem[mem[64] + 64] = stor5.length
                emit onNewPlayer(address(stor5[idx]), block.timestamp, stor5.length);
            uint8(players[address(stor5[idx])].field_256) = 1
            uint256(players[address(stor5[idx])].field_0) = 0
            mem[0] = address(stor5[idx])
            mem[32] = 4
            mem[mem[64]] = address(stor5[idx])
            mem[mem[64] + 32] = uint256(players[address(stor5[idx])].field_0)
            emit 0xf2614ced: address(stor5[idx]), uint256(players[address(stor5[idx])].field_0)
        s = uint256(players[address(stor5[idx])].field_0)
        s = address(stor5[idx])
        idx = idx + 1
        continue 
    s = 0
    idx = 0
    while idx < stor3.length:
        mem[0] = 3
        call address(stor3[idx].field_0) with:
           value uint256(stor3[idx].field_768) wei
             gas 2300 * is_zero(value) wei
        require ext_call.success
        s = (9 * idx) + sha3(3)
        idx = idx + 1
        continue 
    s = 0
    s = 0
    idx = 0
    while idx < stor8.length:
        mem[0] = 8
        if sub_fc0e01c7.length - 1 != uint256(stor8[idx].field_1280):
            s = sub_fc0e01c7.length - 1
            s = (6 * idx) + sha3(8)
            idx = idx + 1
            continue 
        call address(stor8[idx].field_0) with:
           value uint256(stor8[idx].field_512) wei
             gas 2300 * is_zero(value) wei
        require ext_call.success
        s = sub_fc0e01c7.length - 1
        s = (6 * idx) + sha3(8)
        idx = idx + 1
        continue 
    require sub_fc0e01c7.length - 1 < sub_fc0e01c7.length
    uint256(sub_fc0e01c7[sub_fc0e01c7.length - 1].field_0) = 0
    emit 0xcac18c3f: 0, sub_fc0e01c7.length - 1
}

function uintToString(uint256 arg1) {
    mem[96] = 0
    if 0 == arg1:
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 32
        s = 0
        idx = 0
        s = 0
        while idx < 32:
            if 0 == Mask(8, 248, '0' * 2^(8 * idx)):
                s = '0' * 2^(8 * idx)
                idx = idx + 1
                s = s
                continue 
            require s < 32
            mem[s + 256 len 8] = Mask(8, -(('mask_shl', 8, 248, -3, ('mul', "'0'", ('exp', 2, ('mask_shl', 253, 0, 3, ('var', 0))))), 0) + 256, 0) << (('mask_shl', 8, 248, -3, ('mul', "'0'", ('exp', 2, ('mask_shl', 253, 0, 3, ('var', 0))))), 0) - 256
            s = '0' * 2^(8 * idx)
            idx = idx + 1
            s = s + 1
            continue 
        _msize = max(0, s + 8)
        mem[_msize + 256] = s
        mem[64] = (_msize + 256) + (32 * s) + 32
        t = 0
        while t < s:
            require t < 32
            require t < mem[_msize + 256]
            mem[(_msize + 256) + t + 32 len 8] = Mask(8, -(('mask_shl', 8, 248, -3, ('mem', ('range', ('add', 256, ('var', 2)), 32))), 0) + 256, 0) << (('mask_shl', 8, 248, -3, ('mem', ('range', ('add', 256, ('var', 2)), 32))), 0) - 256
            t = t + 1
            continue 
        mem[(_msize + 256) + (32 * s) + 32] = 32
        mem[(_msize + 256) + (32 * s) + 64] = mem[_msize + 256]
        mem[(_msize + 256) + (32 * s) + 96 len mem[_msize + 256]] = mem[(_msize + 256) + 32 len mem[_msize + 256]]
        if not mem[max(0, s + 8) + 256] % 32:
            return 32, mem[(_msize + 256) + (32 * s) + 64 len mem[_msize + 256] + 32]
        mem[floor32(mem[_msize + 256]) + (_msize + 256) + (32 * s) + 96] = mem[floor32(mem[_msize + 256]) + (_msize + 256) + (32 * s) + -(mem[_msize + 256] % 32) + 128 len mem[_msize + 256] % 32]
        return Array(len=mem[_msize + 256], data=mem[(_msize + 256) + (32 * s) + 96 len floor32(mem[_msize + 256]) + 32])
    s = 0
    idx = arg1
    while idx > 0:
        s = s / 256 or (idx % 10) + 48 << 248
        idx = idx / 10
        continue 
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 32
    t = 0
    idx = 0
    t = 0
    while idx < 32:
        if 0 == Mask(8, 248, s * 2^(8 * idx)):
            t = s * 2^(8 * idx)
            idx = idx + 1
            t = t
            continue 
        require t < 32
        mem[t + 256 len 8] = Mask(8, -(('mask_shl', 8, 248, -3, ('mul', ('var', 1), ('exp', 2, ('mask_shl', 253, 0, 3, ('var', 0))))), 0) + 256, 0) << (('mask_shl', 8, 248, -3, ('mul', ('var', 1), ('exp', 2, ('mask_shl', 253, 0, 3, ('var', 0))))), 0) - 256
        t = s * 2^(8 * idx)
        idx = idx + 1
        t = t + 1
        continue 
    _msize = max(0, t + 8)
    mem[_msize + 256] = t
    mem[64] = (_msize + 256) + (32 * t) + 32
    s = 0
    while s < t:
        require s < 32
        require s < mem[_msize + 256]
        mem[(_msize + 256) + s + 32 len 8] = Mask(8, -(('mask_shl', 8, 248, -3, ('mem', ('range', ('add', 256, ('var', 1)), 32))), 0) + 256, 0) << (('mask_shl', 8, 248, -3, ('mem', ('range', ('add', 256, ('var', 1)), 32))), 0) - 256
        s = s + 1
        continue 
    mem[(_msize + 256) + (32 * t) + 32] = 32
    mem[(_msize + 256) + (32 * t) + 64] = mem[_msize + 256]
    mem[(_msize + 256) + (32 * t) + 96 len mem[_msize + 256]] = mem[(_msize + 256) + 32 len mem[_msize + 256]]
    if not mem[max(0, t + 8) + 256] % 32:
        return 32, mem[(_msize + 256) + (32 * t) + 64 len mem[_msize + 256] + 32]
    mem[floor32(mem[_msize + 256]) + (_msize + 256) + (32 * t) + 96] = mem[floor32(mem[_msize + 256]) + (_msize + 256) + (32 * t) + -(mem[_msize + 256] % 32) + 128 len mem[_msize + 256] % 32]
    return 32, mem[(_msize + 256) + (32 * t) + 64 len floor32(mem[_msize + 256]) + 64]
}



}
