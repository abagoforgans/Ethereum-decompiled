contract main {


// =======================  Init code  ======================


address stor0;

function _fallback() payable {
    stor0 = msg.sender
    return code.data[55 len 6992]
}



// =====================  Runtime code  =====================


#
#  - sub_8e8d748f(?)
#  - sub_b1544a29(?)
#  - sub_deb734de(?)
#  - sub_f7da677d(?)
#
address stor0;
uint256 stor1;
array of struct stor2;
uint256 sub_06f65bee;
mapping of uint256 sub_41f3f6e4;
mapping of uint256 stor5;

function sub_06f65bee(?) {
    return sub_06f65bee
}

function sub_41f3f6e4(?) {
    return sub_41f3f6e4[arg1]
}

function _fallback() {
  stop
}

function sub_b18e65d6(?) {
    require sub_41f3f6e4[arg1] < stor2.length
    require uint8(stor2[stor4[arg1]].field_2048) == 1
    require sub_41f3f6e4[arg1] < stor2.length
    address(stor2[stor4[arg1]].field_1280) = msg.sender
    bool(stor2[stor4[arg1]].field_1536) = 0
    uint255(stor2[stor4[arg1]].field_1537) = 4
    uint32(stor2[stor4[arg1]].field_1760) = 1919902571
    idx = 0
    while stor[(11 * stor4[arg1]) + ('name', 'stor2', 2) + 6].length + 31 / 32 > idx:
        uint256(stor[idx + sha3((11 * stor4[arg1]) + ('name', 'stor2', 2) + 6)].field_0) = 0
        idx = idx + 1
        continue 
    require sub_41f3f6e4[arg1] < stor2.length
    uint256(stor2[stor4[arg1]].field_1792) = block.number
    uint8(stor2[stor4[arg1]].field_2048) = 3
}

function sub_32ab809c(?) {
    require sub_41f3f6e4[arg1] < stor2.length
    require uint8(stor2[stor4[arg1]].field_2048) == 1
    require sub_41f3f6e4[arg1] < stor2.length
    address(stor2[stor4[arg1]].field_1280) = msg.sender
    bool(stor2[stor4[arg1]].field_1536) = 0
    uint255(stor2[stor4[arg1]].field_1537) = 8
    uint64(stor2[stor4[arg1]].field_1728) = uint64('scissors')
    idx = 0
    while stor[(11 * stor4[arg1]) + ('name', 'stor2', 2) + 6].length + 31 / 32 > idx:
        uint256(stor[idx + sha3((11 * stor4[arg1]) + ('name', 'stor2', 2) + 6)].field_0) = 0
        idx = idx + 1
        continue 
    require sub_41f3f6e4[arg1] < stor2.length
    uint256(stor2[stor4[arg1]].field_1792) = block.number
    uint8(stor2[stor4[arg1]].field_2048) = 3
}

function sub_9e3486ca(?) {
    require sub_41f3f6e4[arg1] < stor2.length
    require uint8(stor2[stor4[arg1]].field_2048) == 1
    require sub_41f3f6e4[arg1] < stor2.length
    address(stor2[stor4[arg1]].field_1280) = msg.sender
    bool(stor2[stor4[arg1]].field_1536) = 0
    uint255(stor2[stor4[arg1]].field_1537) = 5
    stor2[stor4[arg1]].field_1752 % 1099511627776 = 482671093106
    idx = 0
    while stor[(11 * stor4[arg1]) + ('name', 'stor2', 2) + 6].length + 31 / 32 > idx:
        uint256(stor[idx + sha3((11 * stor4[arg1]) + ('name', 'stor2', 2) + 6)].field_0) = 0
        idx = idx + 1
        continue 
    require sub_41f3f6e4[arg1] < stor2.length
    uint256(stor2[stor4[arg1]].field_1792) = block.number
    uint8(stor2[stor4[arg1]].field_2048) = 3
}

function sub_c0277338(?) {
    require not sub_41f3f6e4[arg1]
    stor2.length++
    if not stor2.length <= stor2.length + 1:
        mem[0] = 2
        idx = (11 * stor2.length) + 11
        while sha3(2) + (11 * stor2.length) > idx + sha3(mem[0]):
            address(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            if 31 >= stor[idx + sha3(mem[0]) + 2].length:
                uint256(stor[idx + sha3(mem[0]) + 3]) = 0
                uint256(stor[idx + sha3(mem[0]) + 4]) = 0
                address(stor[idx + sha3(mem[0]) + 5]) = 0
                uint256(stor[idx + sha3(mem[0]) + 6]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 6].length:
                    mem[0] = idx + sha3(mem[0]) + 6
                    s = sha3(idx + sha3(mem[0]) + 6)
                    while sha3(idx + sha3(mem[0]) + 6) + (stor[idx + sha3(mem[0]) + 6].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 7]) = 0
                uint8(stor[idx + sha3(mem[0]) + 8]) = 0
                uint256(stor[idx + sha3(mem[0]) + 9]) = 0
                uint8(stor[idx + sha3(mem[0]) + 10]) = 0
                idx = idx + 11
                continue 
            mem[0] = idx + sha3(mem[0]) + 2
            s = sha3(s + sha3(mem[0]) + 2)
            while sha3(s + sha3(mem[0]) + 2) + (stor[s + sha3(mem[0]) + 2].length + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint256(stor[s + sha3(mem[0]) + 3]) = 0
            uint256(stor[s + sha3(mem[0]) + 4]) = 0
            address(stor[s + sha3(mem[0]) + 5]) = 0
            uint256(stor[s + sha3(mem[0]) + 6]) = 0
            if 31 < stor[s + sha3(mem[0]) + 6].length:
                mem[0] = s + sha3(mem[0]) + 6
                t = sha3(s + sha3(mem[0]) + 6)
                while sha3(s + sha3(mem[0]) + 6) + (stor[s + sha3(mem[0]) + 6].length + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
            uint256(stor[s + sha3(mem[0]) + 7]) = 0
            uint8(stor[s + sha3(mem[0]) + 8]) = 0
            uint256(stor[s + sha3(mem[0]) + 9]) = 0
            uint8(stor[s + sha3(mem[0]) + 10]) = 0
            s = s + 11
            continue 
    address(stor2[stor2.length].field_0) = msg.sender
    uint256(stor2[stor2.length].field_256) = arg1
    bool(stor2[stor2.length].field_512) = 0
    uint255(stor2[stor2.length].field_513) = 0
    Mask(248, 0, stor2[stor2.length].field_520) = 0
    idx = 0
    while stor[(11 * stor2.length) + ('name', 'stor2', 2) + 2].length + 31 / 32 > idx:
        uint256(stor[idx + sha3((11 * stor2.length) + ('name', 'stor2', 2) + 2)].field_0) = 0
        idx = idx + 1
        continue 
    uint256(stor2[stor2.length].field_768) = block.number
    uint256(stor2[stor2.length].field_1024) = 0
    address(stor2[stor2.length].field_1280) = 0
    stor2[stor2.length].field_1536 % 1 = 0
    bool(stor2[stor2.length].field_1536) = 0
    uint255(stor2[stor2.length].field_1537) = 0
    Mask(248, 0, stor2[stor2.length].field_1544) = mem[512 len 31]
    idx = 0
    while stor[(11 * stor2.length) + ('name', 'stor2', 2) + 6].length + 31 / 32 > idx:
        uint256(stor[idx + sha3((11 * stor2.length) + ('name', 'stor2', 2) + 6)].field_0) = 0
        idx = idx + 1
        continue 
    uint256(stor2[stor2.length].field_1792) = 0
    uint8(stor2[stor2.length].field_2048) = 1
    uint256(stor2[stor2.length].field_2304) = 0
    uint8(stor2[stor2.length].field_2560) = 0
    stor2[stor2.length].field_2816 % 1 = 0
    sub_41f3f6e4[arg1] = sub_06f65bee
    sub_06f65bee++
}

function sub_9547d082(?) {
    require stor0 == msg.sender
    sub_06f65bee = 1
    stor1 = 2 * 3600
    stor5[0][0] = 0
    stor5[0][0] = 2
    stor5[0][uint64('scissors')] = 1
    stor5[0][0] = 1
    stor5[0][0] = 0
    stor5[0][uint64('scissors')] = 2
    stor5[uint64('scissors')][0] = 2
    stor5[uint64('scissors')][0] = 1
    stor5[uint64('scissors')][uint64('scissors')] = 0
    stor2.length++
    if not stor2.length <= stor2.length + 1:
        mem[0] = 2
        idx = (11 * stor2.length) + 11
        while sha3(2) + (11 * stor2.length) > idx + sha3(mem[0]):
            address(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            if 31 >= stor[idx + sha3(mem[0]) + 2].length:
                uint256(stor[idx + sha3(mem[0]) + 3]) = 0
                uint256(stor[idx + sha3(mem[0]) + 4]) = 0
                address(stor[idx + sha3(mem[0]) + 5]) = 0
                uint256(stor[idx + sha3(mem[0]) + 6]) = 0
                if 31 < stor[idx + sha3(mem[0]) + 6].length:
                    mem[0] = idx + sha3(mem[0]) + 6
                    s = sha3(idx + sha3(mem[0]) + 6)
                    while sha3(idx + sha3(mem[0]) + 6) + (stor[idx + sha3(mem[0]) + 6].length + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 7]) = 0
                uint8(stor[idx + sha3(mem[0]) + 8]) = 0
                uint256(stor[idx + sha3(mem[0]) + 9]) = 0
                uint8(stor[idx + sha3(mem[0]) + 10]) = 0
                idx = idx + 11
                continue 
            mem[0] = idx + sha3(mem[0]) + 2
            s = sha3(s + sha3(mem[0]) + 2)
            while sha3(s + sha3(mem[0]) + 2) + (stor[s + sha3(mem[0]) + 2].length + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint256(stor[s + sha3(mem[0]) + 3]) = 0
            uint256(stor[s + sha3(mem[0]) + 4]) = 0
            address(stor[s + sha3(mem[0]) + 5]) = 0
            uint256(stor[s + sha3(mem[0]) + 6]) = 0
            if 31 < stor[s + sha3(mem[0]) + 6].length:
                mem[0] = s + sha3(mem[0]) + 6
                t = sha3(s + sha3(mem[0]) + 6)
                while sha3(s + sha3(mem[0]) + 6) + (stor[s + sha3(mem[0]) + 6].length + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
            uint256(stor[s + sha3(mem[0]) + 7]) = 0
            uint8(stor[s + sha3(mem[0]) + 8]) = 0
            uint256(stor[s + sha3(mem[0]) + 9]) = 0
            uint8(stor[s + sha3(mem[0]) + 10]) = 0
            s = s + 11
            continue 
    address(stor2[stor2.length].field_0) = 0
    uint256(stor2[stor2.length].field_256) = 0
    bool(stor2[stor2.length].field_512) = 0
    uint255(stor2[stor2.length].field_513) = 0
    Mask(248, 0, stor2[stor2.length].field_520) = 0
    idx = 0
    while stor[(11 * stor2.length) + ('name', 'stor2', 2) + 2].length + 31 / 32 > idx:
        uint256(stor[idx + sha3((11 * stor2.length) + ('name', 'stor2', 2) + 2)].field_0) = 0
        idx = idx + 1
        continue 
    uint256(stor2[stor2.length].field_768) = 0
    uint256(stor2[stor2.length].field_1024) = 0
    address(stor2[stor2.length].field_1280) = 0
    stor2[stor2.length].field_1536 % 1 = 0
    bool(stor2[stor2.length].field_1536) = 0
    uint255(stor2[stor2.length].field_1537) = 0
    Mask(248, 0, stor2[stor2.length].field_1544) = mem[512 len 31]
    idx = 0
    while stor[(11 * stor2.length) + ('name', 'stor2', 2) + 6].length + 31 / 32 > idx:
        uint256(stor[idx + sha3((11 * stor2.length) + ('name', 'stor2', 2) + 6)].field_0) = 0
        idx = idx + 1
        continue 
    uint256(stor2[stor2.length].field_1792) = 0
    uint8(stor2[stor2.length].field_2048) = 2
    uint256(stor2[stor2.length].field_2304) = 0
    uint8(stor2[stor2.length].field_2560) = 0
    stor2[stor2.length].field_2816 % 1 = 0
}



}
