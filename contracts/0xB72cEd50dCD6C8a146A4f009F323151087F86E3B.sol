contract main {


// =======================  Init code  ======================


uint256 stor0;

function _fallback() payable {
    stor0 = block.number
    return code.data[23 len 1085]
}



// =====================  Runtime code  =====================


uint256 stor0;
uint256 stor1;
array of address stor2;
array of uint256 stor3;
mapping of uint256 stor4;
mapping of uint256 stor5;

function _fallback() payable {
  stop
}

function payoutReady() payable {
    if block.number % 88 <= 68:
        return (block.number % 88 > 68)
    return (block.number - stor0 > 68)
}

function sub_5e0572a7(?) payable {
    if block.number % 88 >= 68:
    if block.number % 88 <= 48:
    require sha3(arg1) != stor4[address(msg.sender)]
}

function buyTicket(bytes32 arg1) payable {
    if block.number % 88 < 40:
        stor4[address(msg.sender)] = arg1
        stor5[address(msg.sender)] += msg.value
        stor1 += msg.value
}

function random() payable {
    idx = 0
    s = 0
    while idx < stor3.length:
        mem[0] = 3
        idx = idx + 1
        s = s xor stor('array', ('div', 0.25, ('var', 0)), ('name', 'stor3', 3))[uint8(idx)]
        continue 
    idx = s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length
    while uint64(idx) > stor2.length:
        if uint64(15 xor Mask(1, 1, idx)) < stor2.length:
            return uint64(uint64(idx) % 65535)
        if uint64(idx) <= 65536:
            return uint64(uint64(idx) % uint16(stor2.length))
        idx = Mask(48, 16, idx) >> 16
        continue 
    return 0
}

function payout() payable {
    if block.number % 88 <= 68:
        return 0
    if block.number - stor0 <= 68:
        return 0
    idx = 0
    s = 0
    while idx < stor3.length:
        mem[0] = 3
        idx = idx + 1
        s = s xor stor('array', ('div', 0.25, ('var', 0)), ('name', 'stor3', 3))[uint8(idx)]
        continue 
    idx = s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length
    while uint64(idx) > stor2.length:
        if uint64(15 xor Mask(1, 1, idx)) < stor2.length:
            require uint64(idx) % 65535 < stor2.length
            call address(stor2[uint64(idx) % 65535]) with:
               value stor1 - (25000 * block.gasprice) wei
                 gas 0 wei
            stor0 = block.number
            stor2.length = 0
            s = 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace
            while stor2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace > s:
                stor[s] = 0
                s = s + 1
                continue 
            stor3.length = 0
            s = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
            while (stor3.length + 3 / 4) - 0x3da8a5f161a6c3ff06a60736d0ed24d7963cc6a5c4fafd2fa1dae9bb908e07a5 > s:
                stor[s] = 0
                s = s + 1
                continue 
            stor1 = 0
            s = 0
            while s < stor2.length:
                stor4[address(stor2[s])] = 0
                mem[0] = address(stor2[s])
                mem[32] = 5
                stor5[address(stor2[s])] = 0
                s = s + 1
                continue 
            return address(stor2[uint64(idx) % 65535])
        if uint64(idx) > 65536:
            idx = Mask(48, 16, idx) >> 16
            continue 
        require uint64(idx) % uint16(stor2.length) < stor2.length
        call address(stor2[uint64(idx) % uint16(stor2.length)]) with:
           value stor1 - (25000 * block.gasprice) wei
             gas 0 wei
        stor0 = block.number
        stor2.length = 0
        s = 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace
        while stor2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace > s:
            stor[s] = 0
            s = s + 1
            continue 
        stor3.length = 0
        s = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
        while (stor3.length + 3 / 4) - 0x3da8a5f161a6c3ff06a60736d0ed24d7963cc6a5c4fafd2fa1dae9bb908e07a5 > s:
            stor[s] = 0
            s = s + 1
            continue 
        stor1 = 0
        s = 0
        while s < stor2.length:
            stor4[address(stor2[s])] = 0
            mem[0] = address(stor2[s])
            mem[32] = 5
            stor5[address(stor2[s])] = 0
            s = s + 1
            continue 
        return address(stor2[uint64(idx) % uint16(stor2.length)])
    require 0 < stor2.length
    call address(stor2) with:
       value stor1 - (25000 * block.gasprice) wei
         gas 0 wei
    stor0 = block.number
    stor2.length = 0
    idx = 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace
    while stor2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace > idx:
        stor[idx] = 0
        idx = idx + 1
        continue 
    stor3.length = 0
    idx = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
    while (stor3.length + 3 / 4) - 0x3da8a5f161a6c3ff06a60736d0ed24d7963cc6a5c4fafd2fa1dae9bb908e07a5 > idx:
        stor[idx] = 0
        idx = idx + 1
        continue 
    stor1 = 0
    idx = 0
    while idx < stor2.length:
        stor4[address(stor2[idx])] = 0
        mem[0] = address(stor2[idx])
        mem[32] = 5
        stor5[address(stor2[idx])] = 0
        idx = idx + 1
        continue 
    return address(stor2)
}



}
