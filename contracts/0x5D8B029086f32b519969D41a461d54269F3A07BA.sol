contract main {


// =======================  Init code  ======================


uint256 stor0;
uint256 stor2;
uint256 stor3;

function _fallback() payable {
    mem[96 len -982] = code.data[1124 len -982]
    mem[64] = -886
    stor0 = msg.sender or Mask(96, 160, stor0)
    stor2 = block.hash(block.number - 1) % 1000
    _4 = mem[mem[96] + 96]
    mem[-886 len mem[mem[96] + 96]] = mem[mem[96] + 128 len mem[mem[96] + 96]]
    stor3 = sha3(mem[-886 len _4])
    return code.data[142 len 982]
}



// =====================  Runtime code  =====================


address stor0;
array of uint256 decide;
uint256 stor3;

function decide() payable {
    return decide[block.hash(block.number - 1) % decide.length][0 len decide[block.hash(block.number - 1) % decide.length].length]
}

function kill() payable {
    if stor0 != msg.sender:
    selfdestruct(stor0)
}

function _fallback() payable {
  stop
}

function sub_5a88c229(?) payable {
    return (block.hash(block.number - 1) % arg1)
}

function sub_d8faa275(?) payable {
    if sha3(arg2[all]) == stor3:
        decide.length++
        if not decide.length <= decide.length + 1:
            mem[0] = 1
            idx = decide.length + 1
            while sha3(1) + decide.length > idx + sha3(mem[0]):
                stor[idx + sha3(mem[0])] = 0
                if 31 < stor[idx + sha3(mem[0])].length:
                    mem[0] = idx + sha3(mem[0])
                    s = sha3(idx + sha3(mem[0]))
                    while sha3(idx + sha3(mem[0])) + (stor[idx + sha3(mem[0])].length + 31 / 32) > s:
                        stor[s] = 0
                        s = s + 1
                        continue 
                idx = idx + 1
                continue 
        decide[decide.length][] = Array(len=arg1.length, data=arg1[all])
}



}
