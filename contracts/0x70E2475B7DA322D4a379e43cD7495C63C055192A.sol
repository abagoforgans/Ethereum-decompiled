contract main {


// =======================  Init code  ======================


uint256 stor0;
uint256 stor2;

function _fallback() payable {
    stor0 = msg.value
    stor2 = 0
    return code.data[27 len 704]
}



// =====================  Runtime code  =====================


uint256 stor0;
array of struct stor1;
uint256 i;
array of uint256 stor80084422859880547211683076133703299733277748156566366325829078699459944778999;

function i() payable {
    return i
}

function p(uint256 arg1) payable {
    require arg1 < stor1.length
    return stor1[arg1].field_0, storB10E[arg1]
}

function _fallback() payable {
    require stor0 >= 10^18
    require stor0 <= 10 * 10^18
    stor1.length++
    if not stor1.length <= stor1.length + 1:
        idx = 2 * stor1.length + 1
        while 2 * stor1.length > idx:
            stor1[idx].field_0 = 0
            stor1[idx].field_256 = 0
            idx = idx + 1
            continue 
    require stor1.length < stor1.length
    stor1[stor1.length].field_0 = msg.sender or Mask(96, 160, stor1[stor1.length].field_0)
    stor1[stor1.length].field_256 = 110 * stor0 / 100
    if storB10E[stor2] >= eth.balance(this.address):
    require i < stor1.length
    call stor1[stor2].field_0 with:
       value storB10E[stor2] wei
         gas 0 wei
    i++
    if storB10E[stor2] >= eth.balance(this.address):
    require i < stor1.length
    call stor1[stor2].field_0 with:
       value storB10E[stor2] wei
         gas 0 wei
    i++
    if storB10E[stor2] >= eth.balance(this.address):
    require i < stor1.length
    call stor1[stor2].field_0 with:
       value storB10E[stor2] wei
         gas 0 wei
    i++
    if storB10E[stor2] >= eth.balance(this.address):
    require i < stor1.length
    # nil
}



}
