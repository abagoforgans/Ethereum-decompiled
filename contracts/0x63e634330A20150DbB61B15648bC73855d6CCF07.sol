contract main {


// =======================  Init code  ======================


uint256 stor1;
bool stor2; offset 256
uint8 stor2;
uint8 stor2; offset 8
address stor2; offset 16
uint256 stor4;
uint256 stor5;
uint8 stor6;
uint8 stor715D;
uint8 stor20C7;
uint8 stor470D;
uint8 stor7314;
uint8 stor9312;
uint8 storAE92;
uint8 storD544;
uint8 storDDFB;
uint8 stor13BE;
uint8 stor1624;
uint8 stor17FB;
uint8 stor1C89;
uint8 stor20FD;
uint8 stor2372;
uint8 stor2461;
uint8 stor2610;
uint8 stor26DB;
uint8 stor297A;
uint8 stor2C0D;
uint8 stor2CEF;
uint8 stor3214;
uint8 stor3710;
uint8 stor395C;
uint8 stor3B73;
uint8 stor3EEE;
uint8 stor4087;
uint8 stor4187;
uint8 stor47DB;
uint8 stor47DC;
uint8 stor4B51;
uint8 stor4CC0;
uint8 stor5124;
uint8 stor51A9;
uint8 stor51DE;
uint8 stor5200;
uint8 stor5EE4;
uint8 stor6087;
uint8 stor61F2;
uint8 stor6318;
uint8 stor63F6;
uint8 stor6831;
uint8 stor6B9A;
uint8 stor6C0F;
uint8 stor6F6D;
uint8 stor726A;
uint8 stor728C;
uint8 stor7BFB;
uint8 stor7E1F;
uint8 stor806C;
uint8 stor80CC;
uint8 stor84F1;
uint8 stor85F5;
uint8 stor884D;
uint8 stor8894;
uint8 stor898B;
uint8 stor8F61;
uint8 stor9137;
uint8 stor9190;
uint8 stor9516;
uint8 stor958D;
uint8 stor9A26;
uint8 stor9CDC;
uint8 stor9D77;
uint8 stor9F0B;
uint8 stor9F7F;
uint8 storA0FC;
uint8 storAD7D;
uint8 storAFFD;
uint8 storB158;
uint8 storB2C3;
uint8 storB3D3;
uint8 storB800;
uint8 storBB9D;
uint8 storBEE0;
uint8 storC178;
uint8 storC2A0;
uint8 storC404;
uint8 storC664;
uint8 storD2BA;
uint8 storD65A;
uint8 storDBF0;
uint8 storDCBF;
uint8 storE3D4;
uint8 storE44F;
uint8 storE61A;
uint8 storE740;
uint8 storE83E;
uint8 storEBD7;
uint8 storEDCD;
uint8 storEDE5;
uint8 storEE80;
uint8 storEF03;
uint8 storF3F8;
uint8 storFB95;
uint8 storFBDE;
uint8 storFD71;
uint8 storFDFB;
uint8 storFE9B;
uint8 storFF4B;

function _fallback() payable {
    uint8(stor2.field_0) = 1
    uint8(stor2.field_8) = 0
    stor2.field_256 % 1 = 0
    stor4 = 20000
    stor5 = 25000
    stor6 = 0
    require not msg.value
    address(stor2.field_16) = msg.sender
    stor1 = 417216 * 24 * 3600
    storFD71 = 1
    stor20FD = 1
    stor2CEF = 1
    storE61A = 1
    storEDCD = 1
    stor5200 = 1
    storC404 = 1
    storDBF0 = 1
    stor726A = 1
    stor2C0D = 1
    storFF4B = 1
    stor395C = 1
    stor9516 = 1
    storB3D3 = 1
    storB2C3 = 1
    stor7E1F = 1
    stor2461 = 1
    stor898B = 1
    storC664 = 1
    stor1624 = 1
    stor470D = 1
    stor80CC = 1
    storEBD7 = 1
    stor6087 = 1
    stor61F2 = 1
    stor958D = 1
    stor9312 = 1
    stor6B9A = 1
    storE3D4 = 1
    storFE9B = 1
    storC2A0 = 1
    stor297A = 1
    stor3EEE = 1
    stor1C89 = 1
    stor85F5 = 1
    stor84F1 = 1
    stor715D = 1
    stor47DC = 1
    stor63F6 = 1
    stor9CDC = 1
    stor3B73 = 1
    storFDFB = 1
    stor2372 = 1
    stor4CC0 = 1
    storAD7D = 1
    stor2610 = 1
    storDDFB = 1
    storF3F8 = 1
    stor8F61 = 1
    stor4B51 = 1
    stor9137 = 1
    stor26DB = 1
    stor5124 = 1
    storAFFD = 1
    storE44F = 1
    stor3214 = 1
    stor47DB = 1
    stor6831 = 1
    storEE80 = 1
    stor3710 = 1
    stor9F7F = 1
    stor17FB = 1
    storD544 = 1
    stor806C = 1
    storDCBF = 1
    storD65A = 1
    stor7314 = 1
    stor5EE4 = 1
    stor6F6D = 1
    stor6318 = 1
    stor9190 = 1
    stor9D77 = 1
    storFB95 = 1
    stor6C0F = 1
    storFBDE = 1
    storA0FC = 1
    storAE92 = 1
    storEDE5 = 1
    storB800 = 1
    stor4087 = 1
    stor9A26 = 1
    stor20C7 = 1
    stor728C = 1
    stor7BFB = 1
    storC178 = 1
    storB158 = 1
    stor4187 = 1
    storEF03 = 1
    stor13BE = 1
    storBB9D = 1
    storBEE0 = 1
    storD2BA = 1
    stor884D = 1
    stor8894 = 1
    stor9F0B = 1
    storE740 = 1
    stor51DE = 1
    storE83E = 1
    stor51A9 = 1
    return code.data[4207 len 4322]
}



// =====================  Runtime code  =====================


const name = 'Lancer Token'

const decimals = 18

const symbol = 'LNC'


mapping of uint256 allowance;
uint256 fundingStart;
uint8 stor2;
uint8 stor2; offset 8
address stor2;
address masterAddress; offset 16
uint256 stor2; offset 8
uint256 totalSupply;
uint256 stor4;
uint256 stor5;
uint8 stor6;
mapping of uint256 balanceOf;
mapping of uint8 stor8;
mapping of uint256 stor9;
mapping of uint256 etherBalanceOf;
address migrationAgentAddress;
uint256 totalMigrated;
uint256 amountofTotalParticipants;

function EtherBalanceOf(address arg1) {
    return etherBalanceOf[address(arg1)]
}

function totalSupply() {
    return totalSupply
}

function balanceOf(address arg1) {
    return balanceOf[address(arg1)]
}

function migrationAgent() {
    return migrationAgentAddress
}

function totalMigrated() {
    return totalMigrated
}

function fundingStart() {
    return fundingStart
}

function isInitialInvestor(address arg1) {
    return bool(stor8[address(arg1)])
}

function funding() {
    return bool(uint8(stor2.field_0))
}

function getAmountofTotalParticipants() {
    return amountofTotalParticipants
}

function allowance(address arg1, address arg2) {
    return allowance[address(arg1)][address(arg2)]
}

function master() {
    return masterAddress
}

function setExchangeRate(uint256 arg1) {
    require masterAddress == msg.sender
    stor4 = arg1
}

function setStartRefund(bool arg1) {
    require masterAddress == msg.sender
    stor6 = uint8(arg1)
}

function setStartDate(uint256 arg1) {
    require masterAddress == msg.sender
    fundingStart = arg1
}

function setEarlyInvestorExchangeRate(uint256 arg1) {
    require masterAddress == msg.sender
    stor5 = arg1
}

function getExchangeRate(address arg1) {
    if not stor8[address(arg1)]:
        return stor4
    return stor5
}

function addInitialInvestor(address arg1) {
    require masterAddress == msg.sender
    stor8[address(arg1)] = 1
}

function setICORunning(bool arg1) {
    require masterAddress == msg.sender
    uint8(stor2.field_0) = uint8(arg1)
}

function setTransfer(bool arg1) {
    require masterAddress == msg.sender
    Mask(248, 0, stor2.field_8) = Mask(248, 0, arg1)
}

function TimeLeftBeforeCrowdsale() {
    if fundingStart <= block.timestamp:
        return 0
    return (fundingStart - block.timestamp)
}

function addToken(address arg1, uint256 arg2) {
    require masterAddress == msg.sender
    balanceOf[address(arg1)] += arg2
    totalSupply += arg2
}

function ICOopen() {
    if uint8(stor2.field_0):
        if block.timestamp >= fundingStart:
            return 1
        else:
            return 0
    else:
        return 0
}

function setMigrationAgent(address arg1) {
    require not uint8(stor2.field_0)
    require not migrationAgentAddress
    require masterAddress == msg.sender
    migrationAgentAddress = arg1
}

function approve(address arg1, uint256 arg2) {
    require not uint8(stor2.field_0)
    require uint8(stor2.field_8)
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function transfer(address arg1, uint256 arg2) {
    require not uint8(stor2.field_0)
    require uint8(stor2.field_8)
    if balanceOf[address(msg.sender)] < arg2:
        return 0
    if arg2 <= 0:
        return 0
    balanceOf[address(msg.sender)] -= arg2
    balanceOf[arg1] += arg2
    stor9[address(msg.sender)] = block.timestamp
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function refund() {
    require stor6
    require balanceOf[address(msg.sender)]
    balanceOf[address(msg.sender)] = 0
    etherBalanceOf[address(msg.sender)] = 0
    totalSupply -= balanceOf[address(msg.sender)]
    emit Refund(etherBalanceOf[address(msg.sender)], msg.sender);
    call msg.sender with:
       value etherBalanceOf[address(msg.sender)] wei
         gas 2300 * is_zero(value) wei
    require ext_call.success
}

function finalize(uint256 arg1) {
    require masterAddress == msg.sender
    require not uint8(stor2.field_0)
    uint8(stor2.field_0) = 0
    require -arg1 + 100
    totalSupply += arg1 * totalSupply / -arg1 + 100
    balanceOf[address(stor2.field_0)] += arg1 * totalSupply / -arg1 + 100
    emit Transfer((arg1 * totalSupply / -arg1 + 100), 0, masterAddress);
    call masterAddress with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    require ext_call.success
}

function migrate(uint256 arg1) {
    require not uint8(stor2.field_0)
    require migrationAgentAddress
    require arg1
    require arg1 <= balanceOf[address(msg.sender)]
    balanceOf[address(msg.sender)] -= arg1
    totalSupply -= arg1
    totalMigrated += arg1
    require ext_code.size(migrationAgentAddress)
    call migrationAgentAddress.migrateFrom(address rg1, uint256 rg2) with:
         gas gas_remaining - 50 wei
        args msg.sender, arg1
    require ext_call.success
    emit Migrate(arg1, msg.sender, migrationAgentAddress);
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require not uint8(stor2.field_0)
    require uint8(stor2.field_8)
    if balanceOf[address(arg1)] < arg3:
        return 0
    if allowance[address(arg1)][address(msg.sender)] < arg3:
        return 0
    if arg3 <= 0:
        return 0
    if balanceOf[address(arg2)] + arg3 <= balanceOf[address(arg2)]:
        return 0
    balanceOf[address(arg1)] -= arg3
    allowance[address(arg1)][address(msg.sender)] -= arg3
    balanceOf[address(arg2)] += arg3
    emit Transfer(arg3, arg1, arg2);
    return 1
}

function _fallback() payable {
    require uint8(stor2.field_0)
    require block.timestamp >= fundingStart
    require msg.value
    if not stor8[address(msg.sender)]:
        totalSupply += msg.value * stor4
        balanceOf[address(msg.sender)] += msg.value * stor4
        etherBalanceOf[address(msg.sender)] += msg.value
        amountofTotalParticipants++
        emit Transfer((msg.value * stor4), 0, msg.sender);
    else:
        totalSupply += msg.value * stor5
        balanceOf[address(msg.sender)] += msg.value * stor5
        etherBalanceOf[address(msg.sender)] += msg.value
        amountofTotalParticipants++
        emit Transfer((msg.value * stor5), 0, msg.sender);
}



}
