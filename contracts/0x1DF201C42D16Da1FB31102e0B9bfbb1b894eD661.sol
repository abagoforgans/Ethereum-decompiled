contract main {


// =======================  Init code  ======================


uint8 stor0; offset 160
uint256 stor0;
uint256 stor1;
uint256 stor2;
uint256 stor3;
array of struct stor7;
uint256 stor8;
uint256 stor9;
array of uint256 stor10;
uint256 stor11;
uint256 storC65A;
uint8 storC65A;

function _fallback() payable {
    uint8(stor0.field_160) = 16
    stor1 = 900
    stor2 = 120
    stor3 = 10^16
    stor8 = 50
    stor9 = 2 * 10^16
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    stor7.length = 1
    if not stor7.length <= 1:
        idx = 2
        while 2 * stor7.length > idx:
            address(stor7[idx].field_0) = 0
            uint256(stor7[idx].field_256) = 0
            idx = idx + 2
            continue 
    stor10.length = 1
    if not stor10.length <= 1:
        mem[0] = 10
        idx = 13
        while sha3(10) + (13 * stor10.length) > idx + sha3(mem[0]):
            uint256(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            uint256(stor[idx + sha3(mem[0]) + 3]) = 0
            uint256(stor[idx + sha3(mem[0]) + 4]) = 0
            uint256(stor[idx + sha3(mem[0]) + 5]) = 0
            uint256(stor[idx + sha3(mem[0]) + 6]) = 0
            uint256(stor[idx + sha3(mem[0]) + 7]) = 0
            uint256(stor[idx + sha3(mem[0]) + 8]) = 0
            mem[0] = idx + sha3(mem[0]) + 8
            s = sha3(s + sha3(mem[0]) + 8)
            while sha3(s + sha3(mem[0]) + 8) + (uint256(stor[s + sha3(mem[0]) + 8]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint8(stor[s + sha3(mem[0]) + 9]) = 0
            uint256(stor[s + sha3(mem[0]) + 10]) = 0
            uint256(stor[s + sha3(mem[0]) + 11]) = 0
            uint8(stor[s + sha3(mem[0]) + 12]) = 0
            s = s + 13
            continue 
    stor11 = 0
    require 0 < stor10.length
    storC65A = block.timestamp
    storC65A = 0
    stor10 = 0
    return code.data[565 len 8817]
}



// =====================  Runtime code  =====================


#
#  - draw()
#
const N = 6


uint8 maxNumber; offset 160
uint128 stor0; offset 160
address stor0;
uint256 stor0;
array of uint256 stor1;
array of uint256 stor2;
array of uint8 stor3;
mapping of address stor5;
array of uint256 sub_6a52dfdb;
array of struct stor7;
array of uint256 stor8;
array of uint8 stor9;
array of uint256 stor10;
array of uint256 stor11;
array of uint8 description;
array of uint256 stor39249365189697262212649556357205408732595607600233223271220075824908968655314;
array of uint8 stor61758742758443787526222439542919508021010928564850333680823494749507501124561;
array of uint256 stor62514009886607029107290561805838585334079798074568712924583230797734656856477;
array of uint256 stor62514009886607029107290561805838585334079798074568712924583230797734656856480;
array of uint256 stor70402538955001568223061751915610164204544900569080421535842365952732583900870;
array of uint256 stor71815890287692442175528895890898882816327790787444631907317521327134536366546;
array of uint8 stor76339018773525106059262137492800754216846149563446216440108833202443642993106;
array of uint256 stor76791331622108372447635461652990941356897985441046374893387964389974553655749;
array of uint256 stor76791331622108372447635461652990941356897985441046374893387964389974553655762;
array of uint256 stor77243644470691638836008785813181128496949821318646533346667095577505464318418;
array of address stor78946631004607910284408757630146619342980691913656354905430479875682106305489;
array of uint256 stor78946631004607910284408757630146619342980691913656354905430479875682106305491;
array of uint256 stor81314460107941036331368703254892812757416344217047959426179276265283660282309;
array of uint256 stor81314460107941036331368703254892812757416344217047959426179276265283660282310;
array of uint256 stor81314460107941036331368703254892812757416344217047959426179276265283660282311;
array of uint256 stor81314460107941036331368703254892812757416344217047959426179276265283660282315;
array of uint256 stor81314460107941036331368703254892812757416344217047959426179276265283660282316;
array of uint8 stor81314460107941036331368703254892812757416344217047959426179276265283660282318;
array of uint256 stor81314460107941036331368703254892812757416344217047959426179276265283660282319;
array of uint256 stor81314460107941036331368703254892812757416344217047959426179276265283660282320;
array of uint8 stor81314460107941036331368703254892812757416344217047959426179276265283660282321;
array of uint256 stor81314460107941036331368703254892812757416344217047959426179276265283660282322;
array of uint256 stor81710360169583227932394855920364842705840797509084382867820645641005350467270;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726046;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726047;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726048;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726059;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726060;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726061;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726063;
array of struct stor89717814153306320011181716697424560163256864414616650038987186496166826726065;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726066;

function ticketPrice() payable {
    return stor3.length
}

function sub_27ecc221(?) payable {
    return stor2.length
}

function maxNumber() payable {
    return maxNumber
}

function sub_6a52dfdb(?) payable {
    return sub_6a52dfdb[arg1]
}

function description() payable {
    return uint256(description[0 len description.length])
}

function sub_ae466313(?) payable {
    return stor1.length
}

function gameID() payable {
    return stor11.length
}

function sub_d7a58a87(?) payable {
    return stor9.length
}

function sub_fa06c38a(?) payable {
    return stor8.length
}

function kill() payable {
    if address(stor0.field_0) != msg.sender:
    selfdestruct(address(stor0.field_0))
}

function _fallback() payable {
    require stor11.length < stor10.length
    stor9EC6[stor11.length] += msg.value
}

function sub_0db35d8c(?) payable {
    require msg.sender == address(stor0.field_0)
    stor8.length = arg2
    stor9.length = 10^18 * arg1
}

function sub_766fc3ef(?) payable {
    require msg.sender == address(stor0.field_0)
    uint256(description[]) = Array(len=arg1.length, data=arg1[all])
}

function transferOwnership(address arg1) payable {
    require address(stor0.field_0) == msg.sender
    uint256(stor0.field_0) = arg1 or Mask(96, 160, uint256(stor0.field_0))
}

function tickets(uint256 arg1) payable {
    require arg1 < stor4.length
    return storAE8A[arg1], stor8A35[arg1], stor888A[arg1], uint256(stor[code.data[8785 len 32] + (6 * arg1)]), stor8A35[arg1]
}

function sub_80322dd5(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 >= 10^15
    stor3.length = arg1
    require stor11.length < stor10.length
    storC65A[stor11.length] = arg1
}

function sub_236af88c(?) payable {
    require not address(stor5[address(msg.sender)])
    require sub_6a52dfdb[address(arg1)]
    uint256(stor5[address(msg.sender)]) = arg1 or Mask(96, 160, uint256(stor5[address(msg.sender)]))
}

function sub_b28c7c25(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 > 6
    Mask(96, 0, stor0.field_160) = Mask(96, 0, arg1)
    require stor11.length < stor10.length
    uint8(storC65A[stor11.length].field_0) = arg1
    storC65A[stor11.length].field_256 % 1 = 0
}

function games(uint256 arg1) payable {
    require arg1 < stor10.length
    return storB3C6[arg1], 
           stor56C6[arg1],
           stor9EC6[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storAAC6[arg1],
           storC65A[arg1],
           uint8(storC65A[arg1].field_0),
           storC65A[arg1],
           storA9C6[arg1],
           bool(storA8C6[arg1])
}

function sub_d2a8bcf5(?) payable {
    require stor8.length > 0
    require msg.value >= stor9.length
    stor7.length++
    if not stor7.length <= stor7.length + 1:
        idx = 2 * stor7.length + 1
        while 2 * stor7.length > idx:
            address(stor7[idx].field_0) = 0
            uint256(stor7[idx].field_256) = 0
            idx = idx + 2
            continue 
    require stor7.length - 1 < stor7.length
    storB4A6[stor7.length - 1] = msg.sender or Mask(96, 160, storB4A6[stor7.length - 1])
    sub_6a52dfdb[address(msg.sender)] = stor7.length - 1
    stor8.length--
    call address(stor0.field_0) with:
       value msg.value wei
         gas 0 wei
    if not ext_call.success:
        require stor11.length < stor10.length
        stor9EC6[stor11.length] += msg.value
}

function sub_ca34f1f2(?) payable {
    idx = 0
    s = 0
    while idx < stor4.length:
        mem[0] = 4
        if stor888A[idx] != arg2:
            idx = idx + 1
            s = s
            continue 
        require idx < stor4.length
        idx = idx + 1
        s = s + stor8A35[idx]
        continue 
    if s <= 0:
        return arg1
    if arg1 / s < stor3.length:
        return arg1
    t = 0
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        if stor888A[idx] != arg2:
            t = t
            idx = idx + 1
            continue 
        require idx < stor4.length
        mem[32] = 5
        require idx < stor4.length
        mem[0] = 4
        if not address(stor5[storAE8A[idx]]):
            uint256(stor[code.data[8785 len 32] + (6 * idx)]) += 80 * arg1 / s * storAE8A[idx] / 100
        else:
            uint256(stor[code.data[8785 len 32] + (6 * idx)]) += arg1 / s * storAE8A[idx]
        t = arg1 / s * storAE8A[idx]
        idx = idx + 1
        continue 
    return 0
}

function startNextGame() payable {
    require stor11.length < stor10.length
    require bool(storA8C6[stor11.length]) != 0
    stor10.length++
    if not stor10.length <= stor10.length + 1:
        idx = (13 * stor10.length) - 0x4c39a5844729cae3e308f36a5ce933956d7c6367997d26743ca06a70b77c0621
        while (13 * stor10.length) - 0x4c39a5844729cae3e308f36a5ce933956d7c6367997d26743ca06a70b77c062e > idx:
            uint256(stor[idx]) = 0
            stor1[idx] = 0
            stor2[idx] = 0
            uint256(stor3[idx]) = 0
            uint256(stor4[idx].field_0) = 0
            uint256(stor5[idx]) = 0
            sub_6a52dfdb[idx] = 0
            uint256(stor7[idx].field_0) = 0
            stor8[idx] = 0
            mem[0] = idx + 8
            s = sha3(s + 8)
            while sha3(s + 8) + (stor8[s] + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
            stor9[s] = 0
            stor10[s] = 0
            stor11[s] = 0
            uint8(description[s]) = 0
            s = s + 13
            continue 
    stor11.length = stor10.length - 1
    require stor10.length - 1 < stor10.length
    storB3C6[stor10.length] = stor10.length - 1
    storC65A[stor10.length] = 0
    storC65A[stor10.length] = 0
    storC65A[stor10.length] = 0
    require stor11.length - 1 < stor10.length
    storB3C6[stor10.length] = storB3C6[stor11.length]
    storB3C6[stor10.length] = 0
    storB3C6[stor10.length] = maxNumber
    storB3C6[stor10.length] = stor3.length
    storB3C6[stor10.length] = 0
    storB3C6[stor10.length] = 0
    storB3C6[stor10.length] = 0
    if block.timestamp > stor1.length + storA9C6[stor11.length]:
        storB3C6[stor10.length] = block.timestamp
    else:
        require stor11.length - 1 < stor10.length
        storB3C6[stor10.length] = storA9C6[stor11.length] + stor1.length
    idx = 0
    while idx < stor7.length:
        mem[0] = 7
        stor9BA6[idx] = 0
        idx = idx + 1
        continue 
    stor4.length = 0
    if not stor4.length <= 0:
        mem[0] = 4
        idx = 0
        while sha3(4) + (6 * stor4.length) > idx + sha3(mem[0]):
            address(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            mem[0] = idx + sha3(mem[0]) + 1
            s = sha3(s + sha3(mem[0]) + 1)
            while sha3(s + sha3(mem[0]) + 1) + (uint256(stor[s + sha3(mem[0]) + 1]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint256(stor[s + sha3(mem[0]) + 2]) = 0
            uint8(stor[s + sha3(mem[0]) + 3]) = 0
            uint256(stor[s + sha3(mem[0]) + 4]) = 0
            uint256(stor[s + sha3(mem[0]) + 5]) = 0
            s = s + 6
            continue 
}

function sub_79747295(?) payable {
    mem[96] = 0
    mem[128] = 0
    mem[160] = 6
    mem[384] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 416
    idx = 0
    s = 0
    t = 0
    while idx < 123456789:
        mem[mem[64]] = block.difficulty
        mem[mem[64] + 32] = address(block.coinbase)
        mem[mem[64] + 52] = block.timestamp
        mem[mem[64] + 84] = address(msg.sender)
        mem[mem[64] + 104] = idx
        if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber):
            idx = idx + 1
            s = s
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber) < mem[384]
        if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)) + 447 len 1]:
            idx = idx + 1
            s = s
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber) < mem[384]
        mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)) + 416] = 1
        require uint8(s) < mem[160]
        mem[(32 * uint8(s)) + 192] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)
        if uint8(s + 1) != 6:
            idx = idx + 1
            s = s + 1
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        _115 = mem[64]
        mem[64] = mem[64] + 32
        mem[_115] = 0
        s = 0
        t = 0
        idx = 0
        while uint8(idx) < 5:
            u = s
            t = idx + 1
            while uint8(t) < 6:
                require uint8(t) < mem[160]
                require uint8(idx) < mem[160]
                if mem[(32 * uint8(idx)) + 223 len 1] <= mem[(32 * uint8(t)) + 223 len 1]:
                    u = u
                    t = t + 1
                    continue 
                require uint8(idx) < mem[160]
                _410 = mem[(32 * uint8(idx)) + 192]
                require uint8(t) < mem[160]
                require uint8(idx) < mem[160]
                mem[(32 * uint8(idx)) + 192] = mem[(32 * uint8(t)) + 223 len 1]
                require uint8(t) < mem[160]
                mem[(32 * uint8(t)) + 192] = uint8(_410)
                u = _410
                t = t + 1
                continue 
            s = u
            t = t
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[160]
        _317 = mem[160]
        mem[mem[64] + 64 len 32 * mem[160]] = mem[192 len 32 * mem[160]]
        return 32, mem[mem[64] + 32 len (32 * _317) + 32]
    _54 = mem[64]
    mem[64] = mem[64] + 32
    mem[_54] = 0
    s = 0
    u = 0
    t = 0
    while uint8(t) < 5:
        u = s
        idx = t + 1
        while uint8(idx) < 6:
            require uint8(idx) < mem[160]
            require uint8(t) < mem[160]
            if mem[(32 * uint8(t)) + 223 len 1] <= mem[(32 * uint8(idx)) + 223 len 1]:
                u = u
                idx = idx + 1
                continue 
            require uint8(t) < mem[160]
            _344 = mem[(32 * uint8(t)) + 192]
            require uint8(idx) < mem[160]
            require uint8(t) < mem[160]
            mem[(32 * uint8(t)) + 192] = mem[(32 * uint8(idx)) + 223 len 1]
            require uint8(idx) < mem[160]
            mem[(32 * uint8(idx)) + 192] = uint8(_344)
            u = _344
            idx = idx + 1
            continue 
        s = u
        u = idx
        t = t + 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[160]
    _220 = mem[160]
    mem[mem[64] + 64 len 32 * mem[160]] = mem[192 len 32 * mem[160]]
    return 32, mem[mem[64] + 32 len (32 * _220) + 32]
}

function sub_43ea3faa(?) payable {
    mem[96] = arg1.length
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    require arg1.length == 6
    require maxNumber == maxNumber
    require msg.value >= stor3.length
    require stor11.length < stor10.length
    require bool(storA8C6[stor11.length]) != 1
    require stor11.length < stor10.length
    require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
    require stor11.length < stor10.length
    require block.timestamp >= storA9C6[stor11.length] + stor2.length
    mem[(32 * arg1.length) + 128] = 0
    s = 0
    t = 0
    idx = 0
    while uint8(idx) < 5:
        u = s
        t = idx + 1
        while uint8(t) < 6:
            require uint8(t) < arg1.length
            require uint8(idx) < arg1.length
            if mem[(32 * uint8(idx)) + 159 len 1] <= mem[(32 * uint8(t)) + 159 len 1]:
                u = u
                t = t + 1
                continue 
            require uint8(idx) < arg1.length
            _53 = mem[(32 * uint8(idx)) + 128]
            require uint8(t) < arg1.length
            require uint8(idx) < arg1.length
            mem[(32 * uint8(idx)) + 128] = mem[(32 * uint8(t)) + 159 len 1]
            require uint8(t) < arg1.length
            mem[(32 * uint8(t)) + 128] = uint8(_53)
            u = _53
            t = t + 1
            continue 
        s = u
        t = t
        idx = idx + 1
        continue 
    s = 0
    idx = 0
    s = 0
    while uint8(idx) < 6:
        require uint8(idx) < arg1.length
        require mem[(32 * uint8(idx)) + 159 len 1] >= 1
        require mem[(32 * uint8(idx)) + 159 len 1] <= maxNumber
        require mem[(32 * uint8(idx)) + 159 len 1] > uint8(s)
        s = mem[(32 * uint8(idx)) + 128]
        idx = idx + 1
        s = mem[(32 * uint8(idx)) + 128]
        continue 
    stor4.length++
    if not stor4.length <= stor4.length + 1:
        mem[0] = 4
        idx = (6 * stor4.length) + 6
        while sha3(4) + (6 * stor4.length) > idx + sha3(mem[0]):
            address(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            mem[0] = idx + sha3(mem[0]) + 1
            s = sha3(s + sha3(mem[0]) + 1)
            while sha3(s + sha3(mem[0]) + 1) + (uint256(stor[s + sha3(mem[0]) + 1]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint256(stor[s + sha3(mem[0]) + 2]) = 0
            uint8(stor[s + sha3(mem[0]) + 3]) = 0
            uint256(stor[s + sha3(mem[0]) + 4]) = 0
            uint256(stor[s + sha3(mem[0]) + 5]) = 0
            s = s + 6
            continue 
    require stor11.length < stor10.length
    storC65A[stor11.length]++
    require storC65A[stor11.length] < stor4.length
    uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / stor3.length
    uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
    uint256(stor4[storC65A[stor11.length]].field_256) = 6
    if not uint256(stor4[storC65A[stor11.length]].field_256) <= 6:
        idx = 1
        while uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32 > idx:
            uint256(stor[idx + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = 0
            idx = idx + 1
            continue 
    uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
    idx = 0
    while uint8(idx) < 6:
        require uint8(idx) < arg1.length
        require uint8(idx) < uint256(stor4[storC65A[stor11.length]].field_256)
        mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
        uint256(stor[(uint8(idx) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(idx)) + 128] * 256^(idx % 32) or !(255 * 256^(idx % 32)) and uint256(stor[(uint8(idx) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
        idx = idx + 1
        continue 
    require stor11.length < stor10.length
    storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
    storC65A[stor11.length] += msg.value
    stor9EC6[stor11.length] += 85 * msg.value / 100
    storAAC6[stor11.length] += 5 * msg.value / 100
    if 0 == address(stor5[address(msg.sender)]):
        require stor11.length < stor10.length
        stor9EC6[stor11.length] += 10 * msg.value / 100
    else:
        require sub_6a52dfdb[address(stor5[address(msg.sender)])] < stor7.length
        stor9BA6[stor6[address(stor5[address(msg.sender)])]] += 10 * msg.value / 100
        require stor11.length < stor10.length
        storC65A[stor11.length] += 10 * msg.value / 100
}

function sub_d7264f6c(?) payable {
    mem[64] = 128
    mem[96] = 0
    require msg.value >= arg1 * stor3.length
    s = 96
    idx = 0
    while idx < arg1:
        _1028 = mem[64]
        mem[64] = mem[64] + 32
        mem[_1028] = 0
        _1029 = mem[64]
        mem[64] = mem[64] + 32
        mem[_1029] = 0
        _1030 = mem[64]
        if msize < mem[64]:
            mem[mem[64]] = 6
            if msize < mem[64] + 224:
                mem[mem[64] + 224] = uint8(maxNumber + 1)
                mem[64] = mem[64] + (32 * uint8(maxNumber + 1)) + 256
                t = 0
                u = 0
                v = 0
                while t < 123456789:
                    mem[mem[64]] = block.difficulty
                    mem[mem[64] + 32] = address(block.coinbase)
                    mem[mem[64] + 52] = block.timestamp
                    mem[mem[64] + 84] = address(msg.sender)
                    mem[mem[64] + 104] = t
                    if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber):
                        t = t + 1
                        u = u
                        v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber) < mem[_1030 + 224]
                    if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)) + _1030 + 287 len 1]:
                        t = t + 1
                        u = u
                        v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber) < mem[_1030 + 224]
                    mem[_1030 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)) + 256] = 1
                    require uint8(u) < mem[_1030]
                    mem[_1030 + (32 * uint8(u)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)
                    if uint8(u + 1) != 6:
                        t = t + 1
                        u = u + 1
                        v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                        continue 
                    _1151 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1151] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_1030]
                            require uint8(s) < mem[_1030]
                            if mem[(32 * uint8(s)) + _1030 + 63 len 1] <= mem[(32 * uint8(idx)) + _1030 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_1030]
                            _1638 = mem[(32 * uint8(s)) + _1030 + 32]
                            require uint8(idx) < mem[_1030]
                            require uint8(s) < mem[_1030]
                            mem[_1030 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1030 + 63 len 1]
                            require uint8(idx) < mem[_1030]
                            mem[(32 * uint8(idx)) + _1030 + 32] = uint8(_1638)
                            u = _1638
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    require mem[_1030] == 6
                    require maxNumber == maxNumber
                    require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                    require stor11.length < stor10.length
                    require bool(storA8C6[stor11.length]) != 1
                    require stor11.length < stor10.length
                    require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
                    require stor11.length < stor10.length
                    mem[0] = 10
                    require block.timestamp >= storA9C6[stor11.length] + stor2.length
                    _1534 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1534] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_1030]
                            require uint8(s) < mem[_1030]
                            if mem[(32 * uint8(s)) + _1030 + 63 len 1] <= mem[(32 * uint8(idx)) + _1030 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_1030]
                            _1941 = mem[(32 * uint8(s)) + _1030 + 32]
                            require uint8(idx) < mem[_1030]
                            require uint8(s) < mem[_1030]
                            mem[_1030 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1030 + 63 len 1]
                            require uint8(idx) < mem[_1030]
                            mem[(32 * uint8(idx)) + _1030 + 32] = uint8(_1941)
                            u = _1941
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    t = 0
                    s = 0
                    t = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1030]
                        require mem[(32 * uint8(s)) + _1030 + 63 len 1] >= 1
                        require mem[(32 * uint8(s)) + _1030 + 63 len 1] <= maxNumber
                        require mem[(32 * uint8(s)) + _1030 + 63 len 1] > uint8(t)
                        t = mem[(32 * uint8(s)) + _1030 + 32]
                        s = s + 1
                        t = mem[(32 * uint8(s)) + _1030 + 32]
                        continue 
                    stor4.length++
                    if not stor4.length <= stor4.length + 1:
                        mem[0] = 4
                        s = sha3(mem[0]) + (6 * stor4.length) + 6
                        while sha3(4) + (6 * stor4.length) > s:
                            address(stor[s]) = 0
                            stor1[s] = 0
                            mem[0] = s + 1
                            t = sha3(t + 1)
                            while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                                uint256(stor[t]) = 0
                                t = t + 1
                                continue 
                            stor2[t] = 0
                            uint8(stor3[t]) = 0
                            uint256(stor4[t].field_0) = 0
                            uint256(stor5[t]) = 0
                            t = t + 6
                            continue 
                    require stor11.length < stor10.length
                    storC65A[stor11.length]++
                    require storC65A[stor11.length] < stor4.length
                    mem[0] = 4
                    uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                    uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
                    uint256(stor4[storC65A[stor11.length]].field_256) = 6
                    if not uint256(stor4[storC65A[stor11.length]].field_256) <= 6:
                        mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                        s = sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + 1
                        while sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + (uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1030]
                        require uint8(s) < uint256(stor4[storC65A[stor11.length]].field_256)
                        mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                        uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _1030 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
                        s = s + 1
                        continue 
                    require stor11.length < stor10.length
                    mem[0] = 10
                    storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
                    s = _1030
                    idx = idx + 1
                    continue 
                _1090 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1090] = 0
                u = 0
                w = 0
                v = 0
                while uint8(v) < 5:
                    s = u
                    idx = v + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1030]
                        require uint8(v) < mem[_1030]
                        if mem[(32 * uint8(v)) + _1030 + 63 len 1] <= mem[(32 * uint8(idx)) + _1030 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(v) < mem[_1030]
                        _1444 = mem[(32 * uint8(v)) + _1030 + 32]
                        require uint8(idx) < mem[_1030]
                        require uint8(v) < mem[_1030]
                        mem[_1030 + (32 * uint8(v)) + 32] = mem[(32 * uint8(idx)) + _1030 + 63 len 1]
                        require uint8(idx) < mem[_1030]
                        mem[(32 * uint8(idx)) + _1030 + 32] = uint8(_1444)
                        s = _1444
                        idx = idx + 1
                        continue 
                    u = s
                    w = idx
                    v = v + 1
                    continue 
                require mem[_1030] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require stor11.length < stor10.length
                require bool(storA8C6[stor11.length]) != 1
                require stor11.length < stor10.length
                require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
                require stor11.length < stor10.length
                mem[0] = 10
                require block.timestamp >= storA9C6[stor11.length] + stor2.length
                _1342 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1342] = 0
                u = 0
                v = 0
                t = 0
                while uint8(t) < 5:
                    s = u
                    idx = t + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1030]
                        require uint8(t) < mem[_1030]
                        if mem[(32 * uint8(t)) + _1030 + 63 len 1] <= mem[(32 * uint8(idx)) + _1030 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(t) < mem[_1030]
                        _1763 = mem[(32 * uint8(t)) + _1030 + 32]
                        require uint8(idx) < mem[_1030]
                        require uint8(t) < mem[_1030]
                        mem[_1030 + (32 * uint8(t)) + 32] = mem[(32 * uint8(idx)) + _1030 + 63 len 1]
                        require uint8(idx) < mem[_1030]
                        mem[(32 * uint8(idx)) + _1030 + 32] = uint8(_1763)
                        s = _1763
                        idx = idx + 1
                        continue 
                    u = s
                    v = idx
                    t = t + 1
                    continue 
                u = 0
                t = 0
                u = 0
                while uint8(t) < 6:
                    require uint8(t) < mem[_1030]
                    require mem[(32 * uint8(t)) + _1030 + 63 len 1] >= 1
                    require mem[(32 * uint8(t)) + _1030 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(t)) + _1030 + 63 len 1] > uint8(u)
                    u = mem[(32 * uint8(t)) + _1030 + 32]
                    t = t + 1
                    u = mem[(32 * uint8(t)) + _1030 + 32]
                    continue 
                stor4.length++
                if not stor4.length > stor4.length + 1:
                    require stor11.length < stor10.length
                    storC65A[stor11.length]++
                    require storC65A[stor11.length] < stor4.length
                    mem[0] = 4
                    uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                    uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
                    uint256(stor4[storC65A[stor11.length]].field_256) = 6
                    if not uint256(stor4[storC65A[stor11.length]].field_256) <= 6:
                        mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                        s = sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + 1
                        while sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + (uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1030]
                        require uint8(s) < uint256(stor4[storC65A[stor11.length]].field_256)
                        mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                        uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _1030 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
                        s = s + 1
                        continue 
                    require stor11.length < stor10.length
                    mem[0] = 10
                    storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
                    s = _1030
                    idx = idx + 1
                    continue 
                mem[0] = 4
                t = sha3(mem[0]) + (6 * stor4.length) + 6
                while sha3(4) + (6 * stor4.length) > t:
                    address(stor[t]) = 0
                    stor1[t] = 0
                    mem[0] = t + 1
                    s = sha3(s + 1)
                    while sha3(s + 1) + (stor1[s] + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                    stor2[s] = 0
                    uint8(stor3[s]) = 0
                    uint256(stor4[s].field_0) = 0
                    uint256(stor5[s]) = 0
                    s = s + 6
                    continue 
                require stor11.length < stor10.length
                storC65A[stor11.length]++
                require storC65A[stor11.length] < stor4.length
                mem[0] = 4
                uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
                uint256(stor4[storC65A[stor11.length]].field_256) = 6
                if not uint256(stor4[storC65A[stor11.length]].field_256) > 6:
                    uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1030]
                        require uint8(s) < uint256(stor4[storC65A[stor11.length]].field_256)
                        mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                        uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _1030 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
                        s = s + 1
                        continue 
                    require stor11.length < stor10.length
                    mem[0] = 10
                    storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
                    s = _1030
                    idx = idx + 1
                    continue 
                mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                t = sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + 1
                while sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + (uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
            else:
                _1036 = msize
                mem[msize] = uint8(maxNumber + 1)
                mem[64] = _1036 + (32 * uint8(maxNumber + 1)) + 32
                s = 0
                t = 0
                u = 0
                while s < 123456789:
                    mem[mem[64]] = block.difficulty
                    mem[mem[64] + 32] = address(block.coinbase)
                    mem[mem[64] + 52] = block.timestamp
                    mem[mem[64] + 84] = address(msg.sender)
                    mem[mem[64] + 104] = s
                    if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                        s = s + 1
                        t = t
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1036]
                    if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _1036 + 63 len 1]:
                        s = s + 1
                        t = t
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1036]
                    mem[_1036 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 32] = 1
                    require uint8(t) < mem[_1030]
                    mem[_1030 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                    if uint8(t + 1) != 6:
                        s = s + 1
                        t = t + 1
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    _1153 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1153] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_1030]
                            require uint8(s) < mem[_1030]
                            if mem[(32 * uint8(s)) + _1030 + 63 len 1] <= mem[(32 * uint8(idx)) + _1030 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_1030]
                            _1644 = mem[(32 * uint8(s)) + _1030 + 32]
                            require uint8(idx) < mem[_1030]
                            require uint8(s) < mem[_1030]
                            mem[_1030 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1030 + 63 len 1]
                            require uint8(idx) < mem[_1030]
                            mem[(32 * uint8(idx)) + _1030 + 32] = uint8(_1644)
                            u = _1644
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    require mem[_1030] == 6
                    require maxNumber == maxNumber
                    require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                    require stor11.length < stor10.length
                    require bool(storA8C6[stor11.length]) != 1
                    require stor11.length < stor10.length
                    require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
                    require stor11.length < stor10.length
                    mem[0] = 10
                    require block.timestamp >= storA9C6[stor11.length] + stor2.length
                    _1535 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1535] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_1030]
                            require uint8(s) < mem[_1030]
                            if mem[(32 * uint8(s)) + _1030 + 63 len 1] <= mem[(32 * uint8(idx)) + _1030 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_1030]
                            _1946 = mem[(32 * uint8(s)) + _1030 + 32]
                            require uint8(idx) < mem[_1030]
                            require uint8(s) < mem[_1030]
                            mem[_1030 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1030 + 63 len 1]
                            require uint8(idx) < mem[_1030]
                            mem[(32 * uint8(idx)) + _1030 + 32] = uint8(_1946)
                            u = _1946
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    t = 0
                    s = 0
                    t = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1030]
                        require mem[(32 * uint8(s)) + _1030 + 63 len 1] >= 1
                        require mem[(32 * uint8(s)) + _1030 + 63 len 1] <= maxNumber
                        require mem[(32 * uint8(s)) + _1030 + 63 len 1] > uint8(t)
                        t = mem[(32 * uint8(s)) + _1030 + 32]
                        s = s + 1
                        t = mem[(32 * uint8(s)) + _1030 + 32]
                        continue 
                    stor4.length++
                    if not stor4.length <= stor4.length + 1:
                        mem[0] = 4
                        s = sha3(mem[0]) + (6 * stor4.length) + 6
                        while sha3(4) + (6 * stor4.length) > s:
                            address(stor[s]) = 0
                            stor1[s] = 0
                            mem[0] = s + 1
                            t = sha3(t + 1)
                            while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                                uint256(stor[t]) = 0
                                t = t + 1
                                continue 
                            stor2[t] = 0
                            uint8(stor3[t]) = 0
                            uint256(stor4[t].field_0) = 0
                            uint256(stor5[t]) = 0
                            t = t + 6
                            continue 
                    require stor11.length < stor10.length
                    storC65A[stor11.length]++
                    require storC65A[stor11.length] < stor4.length
                    mem[0] = 4
                    uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                    uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
                    uint256(stor4[storC65A[stor11.length]].field_256) = 6
                    if not uint256(stor4[storC65A[stor11.length]].field_256) <= 6:
                        mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                        s = sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + 1
                        while sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + (uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1030]
                        require uint8(s) < uint256(stor4[storC65A[stor11.length]].field_256)
                        mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                        uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _1030 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
                        s = s + 1
                        continue 
                    require stor11.length < stor10.length
                    mem[0] = 10
                    storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
                    s = _1030
                    idx = idx + 1
                    continue 
                _1092 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1092] = 0
                t = 0
                v = 0
                u = 0
                while uint8(u) < 5:
                    s = t
                    idx = u + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1030]
                        require uint8(u) < mem[_1030]
                        if mem[(32 * uint8(u)) + _1030 + 63 len 1] <= mem[(32 * uint8(idx)) + _1030 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(u) < mem[_1030]
                        _1449 = mem[(32 * uint8(u)) + _1030 + 32]
                        require uint8(idx) < mem[_1030]
                        require uint8(u) < mem[_1030]
                        mem[_1030 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _1030 + 63 len 1]
                        require uint8(idx) < mem[_1030]
                        mem[(32 * uint8(idx)) + _1030 + 32] = uint8(_1449)
                        s = _1449
                        idx = idx + 1
                        continue 
                    t = s
                    v = idx
                    u = u + 1
                    continue 
                require mem[_1030] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require stor11.length < stor10.length
                require bool(storA8C6[stor11.length]) != 1
                require stor11.length < stor10.length
                require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
                require stor11.length < stor10.length
                mem[0] = 10
                require block.timestamp >= storA9C6[stor11.length] + stor2.length
                _1343 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1343] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1030]
                        require uint8(s) < mem[_1030]
                        if mem[(32 * uint8(s)) + _1030 + 63 len 1] <= mem[(32 * uint8(idx)) + _1030 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1030]
                        _1768 = mem[(32 * uint8(s)) + _1030 + 32]
                        require uint8(idx) < mem[_1030]
                        require uint8(s) < mem[_1030]
                        mem[_1030 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1030 + 63 len 1]
                        require uint8(idx) < mem[_1030]
                        mem[(32 * uint8(idx)) + _1030 + 32] = uint8(_1768)
                        u = _1768
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                t = 0
                s = 0
                t = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1030]
                    require mem[(32 * uint8(s)) + _1030 + 63 len 1] >= 1
                    require mem[(32 * uint8(s)) + _1030 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(s)) + _1030 + 63 len 1] > uint8(t)
                    t = mem[(32 * uint8(s)) + _1030 + 32]
                    s = s + 1
                    t = mem[(32 * uint8(s)) + _1030 + 32]
                    continue 
                stor4.length++
                if not stor4.length <= stor4.length + 1:
                    mem[0] = 4
                    s = sha3(mem[0]) + (6 * stor4.length) + 6
                    while sha3(4) + (6 * stor4.length) > s:
                        address(stor[s]) = 0
                        stor1[s] = 0
                        mem[0] = s + 1
                        t = sha3(t + 1)
                        while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                            uint256(stor[t]) = 0
                            t = t + 1
                            continue 
                        stor2[t] = 0
                        uint8(stor3[t]) = 0
                        uint256(stor4[t].field_0) = 0
                        uint256(stor5[t]) = 0
                        t = t + 6
                        continue 
                require stor11.length < stor10.length
                storC65A[stor11.length]++
                require storC65A[stor11.length] < stor4.length
                mem[0] = 4
                uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
                uint256(stor4[storC65A[stor11.length]].field_256) = 6
                if not uint256(stor4[storC65A[stor11.length]].field_256) <= 6:
                    mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                    s = sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + 1
                    while sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + (uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
            uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
            s = 0
            while uint8(s) < 6:
                require uint8(s) < mem[_1030]
                require uint8(s) < uint256(stor4[storC65A[stor11.length]].field_256)
                mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _1030 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
                s = s + 1
                continue 
            require stor11.length < stor10.length
            mem[0] = 10
            storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
            t = _1030
            idx = idx + 1
            continue 
        _1033 = msize
        mem[msize] = 6
        if msize < _1033 + 224:
            mem[_1033 + 224] = uint8(maxNumber + 1)
            mem[64] = _1033 + (32 * uint8(maxNumber + 1)) + 256
            s = 0
            t = 0
            u = 0
            while s < 123456789:
                mem[mem[64]] = block.difficulty
                mem[mem[64] + 32] = address(block.coinbase)
                mem[mem[64] + 52] = block.timestamp
                mem[mem[64] + 84] = address(msg.sender)
                mem[mem[64] + 104] = s
                if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1033 + 224]
                if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _1033 + 287 len 1]:
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1033 + 224]
                mem[_1033 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 256] = 1
                require uint8(t) < mem[_1033]
                mem[_1033 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                if uint8(t + 1) != 6:
                    s = s + 1
                    t = t + 1
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                _1155 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1155] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1033]
                        require uint8(s) < mem[_1033]
                        if mem[(32 * uint8(s)) + _1033 + 63 len 1] <= mem[(32 * uint8(idx)) + _1033 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1033]
                        _1650 = mem[(32 * uint8(s)) + _1033 + 32]
                        require uint8(idx) < mem[_1033]
                        require uint8(s) < mem[_1033]
                        mem[_1033 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1033 + 63 len 1]
                        require uint8(idx) < mem[_1033]
                        mem[(32 * uint8(idx)) + _1033 + 32] = uint8(_1650)
                        u = _1650
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                require mem[_1033] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require stor11.length < stor10.length
                require bool(storA8C6[stor11.length]) != 1
                require stor11.length < stor10.length
                require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
                require stor11.length < stor10.length
                mem[0] = 10
                require block.timestamp >= storA9C6[stor11.length] + stor2.length
                _1536 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1536] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1033]
                        require uint8(s) < mem[_1033]
                        if mem[(32 * uint8(s)) + _1033 + 63 len 1] <= mem[(32 * uint8(idx)) + _1033 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1033]
                        _1951 = mem[(32 * uint8(s)) + _1033 + 32]
                        require uint8(idx) < mem[_1033]
                        require uint8(s) < mem[_1033]
                        mem[_1033 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1033 + 63 len 1]
                        require uint8(idx) < mem[_1033]
                        mem[(32 * uint8(idx)) + _1033 + 32] = uint8(_1951)
                        u = _1951
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                t = 0
                s = 0
                t = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1033]
                    require mem[(32 * uint8(s)) + _1033 + 63 len 1] >= 1
                    require mem[(32 * uint8(s)) + _1033 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(s)) + _1033 + 63 len 1] > uint8(t)
                    t = mem[(32 * uint8(s)) + _1033 + 32]
                    s = s + 1
                    t = mem[(32 * uint8(s)) + _1033 + 32]
                    continue 
                stor4.length++
                if not stor4.length <= stor4.length + 1:
                    mem[0] = 4
                    s = sha3(mem[0]) + (6 * stor4.length) + 6
                    while sha3(4) + (6 * stor4.length) > s:
                        address(stor[s]) = 0
                        stor1[s] = 0
                        mem[0] = s + 1
                        t = sha3(t + 1)
                        while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                            uint256(stor[t]) = 0
                            t = t + 1
                            continue 
                        stor2[t] = 0
                        uint8(stor3[t]) = 0
                        uint256(stor4[t].field_0) = 0
                        uint256(stor5[t]) = 0
                        t = t + 6
                        continue 
                require stor11.length < stor10.length
                storC65A[stor11.length]++
                require storC65A[stor11.length] < stor4.length
                mem[0] = 4
                uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
                uint256(stor4[storC65A[stor11.length]].field_256) = 6
                if not uint256(stor4[storC65A[stor11.length]].field_256) <= 6:
                    mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                    s = sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + 1
                    while sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + (uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
                s = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1033]
                    require uint8(s) < uint256(stor4[storC65A[stor11.length]].field_256)
                    mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                    uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _1033 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
                    s = s + 1
                    continue 
                require stor11.length < stor10.length
                mem[0] = 10
                storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
                s = _1033
                idx = idx + 1
                continue 
            _1094 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1094] = 0
            t = 0
            v = 0
            u = 0
            while uint8(u) < 5:
                s = t
                idx = u + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_1033]
                    require uint8(u) < mem[_1033]
                    if mem[(32 * uint8(u)) + _1033 + 63 len 1] <= mem[(32 * uint8(idx)) + _1033 + 63 len 1]:
                        s = s
                        idx = idx + 1
                        continue 
                    require uint8(u) < mem[_1033]
                    _1454 = mem[(32 * uint8(u)) + _1033 + 32]
                    require uint8(idx) < mem[_1033]
                    require uint8(u) < mem[_1033]
                    mem[_1033 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _1033 + 63 len 1]
                    require uint8(idx) < mem[_1033]
                    mem[(32 * uint8(idx)) + _1033 + 32] = uint8(_1454)
                    s = _1454
                    idx = idx + 1
                    continue 
                t = s
                v = idx
                u = u + 1
                continue 
            require mem[_1033] == 6
            require maxNumber == maxNumber
            require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
            require stor11.length < stor10.length
            require bool(storA8C6[stor11.length]) != 1
            require stor11.length < stor10.length
            require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
            require stor11.length < stor10.length
            mem[0] = 10
            require block.timestamp >= storA9C6[stor11.length] + stor2.length
            _1344 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1344] = 0
            t = 0
            u = 0
            s = 0
            while uint8(s) < 5:
                u = t
                idx = s + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_1033]
                    require uint8(s) < mem[_1033]
                    if mem[(32 * uint8(s)) + _1033 + 63 len 1] <= mem[(32 * uint8(idx)) + _1033 + 63 len 1]:
                        u = u
                        idx = idx + 1
                        continue 
                    require uint8(s) < mem[_1033]
                    _1773 = mem[(32 * uint8(s)) + _1033 + 32]
                    require uint8(idx) < mem[_1033]
                    require uint8(s) < mem[_1033]
                    mem[_1033 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1033 + 63 len 1]
                    require uint8(idx) < mem[_1033]
                    mem[(32 * uint8(idx)) + _1033 + 32] = uint8(_1773)
                    u = _1773
                    idx = idx + 1
                    continue 
                t = u
                u = idx
                s = s + 1
                continue 
        else:
            _1041 = msize
            mem[msize] = uint8(maxNumber + 1)
            mem[64] = _1041 + (32 * uint8(maxNumber + 1)) + 32
            s = 0
            t = 0
            u = 0
            while s < 123456789:
                mem[mem[64]] = block.difficulty
                mem[mem[64] + 32] = address(block.coinbase)
                mem[mem[64] + 52] = block.timestamp
                mem[mem[64] + 84] = address(msg.sender)
                mem[mem[64] + 104] = s
                if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1041]
                if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _1041 + 63 len 1]:
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1041]
                mem[_1041 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 32] = 1
                require uint8(t) < mem[_1033]
                mem[_1033 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                if uint8(t + 1) != 6:
                    s = s + 1
                    t = t + 1
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                _1157 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1157] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1033]
                        require uint8(s) < mem[_1033]
                        if mem[(32 * uint8(s)) + _1033 + 63 len 1] <= mem[(32 * uint8(idx)) + _1033 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1033]
                        _1656 = mem[(32 * uint8(s)) + _1033 + 32]
                        require uint8(idx) < mem[_1033]
                        require uint8(s) < mem[_1033]
                        mem[_1033 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1033 + 63 len 1]
                        require uint8(idx) < mem[_1033]
                        mem[(32 * uint8(idx)) + _1033 + 32] = uint8(_1656)
                        u = _1656
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                require mem[_1033] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require stor11.length < stor10.length
                require bool(storA8C6[stor11.length]) != 1
                require stor11.length < stor10.length
                require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
                require stor11.length < stor10.length
                mem[0] = 10
                require block.timestamp >= storA9C6[stor11.length] + stor2.length
                _1537 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1537] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1033]
                        require uint8(s) < mem[_1033]
                        if mem[(32 * uint8(s)) + _1033 + 63 len 1] <= mem[(32 * uint8(idx)) + _1033 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1033]
                        _1956 = mem[(32 * uint8(s)) + _1033 + 32]
                        require uint8(idx) < mem[_1033]
                        require uint8(s) < mem[_1033]
                        mem[_1033 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1033 + 63 len 1]
                        require uint8(idx) < mem[_1033]
                        mem[(32 * uint8(idx)) + _1033 + 32] = uint8(_1956)
                        u = _1956
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                t = 0
                s = 0
                t = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1033]
                    require mem[(32 * uint8(s)) + _1033 + 63 len 1] >= 1
                    require mem[(32 * uint8(s)) + _1033 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(s)) + _1033 + 63 len 1] > uint8(t)
                    t = mem[(32 * uint8(s)) + _1033 + 32]
                    s = s + 1
                    t = mem[(32 * uint8(s)) + _1033 + 32]
                    continue 
                stor4.length++
                if not stor4.length <= stor4.length + 1:
                    mem[0] = 4
                    s = sha3(mem[0]) + (6 * stor4.length) + 6
                    while sha3(4) + (6 * stor4.length) > s:
                        address(stor[s]) = 0
                        stor1[s] = 0
                        mem[0] = s + 1
                        t = sha3(t + 1)
                        while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                            uint256(stor[t]) = 0
                            t = t + 1
                            continue 
                        stor2[t] = 0
                        uint8(stor3[t]) = 0
                        uint256(stor4[t].field_0) = 0
                        uint256(stor5[t]) = 0
                        t = t + 6
                        continue 
                require stor11.length < stor10.length
                storC65A[stor11.length]++
                require storC65A[stor11.length] < stor4.length
                mem[0] = 4
                uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
                uint256(stor4[storC65A[stor11.length]].field_256) = 6
                if not uint256(stor4[storC65A[stor11.length]].field_256) <= 6:
                    mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                    s = sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + 1
                    while sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + (uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
                s = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1033]
                    require uint8(s) < uint256(stor4[storC65A[stor11.length]].field_256)
                    mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
                    uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _1033 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
                    s = s + 1
                    continue 
                require stor11.length < stor10.length
                mem[0] = 10
                storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
                s = _1033
                idx = idx + 1
                continue 
            _1096 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1096] = 0
            t = 0
            v = 0
            u = 0
            while uint8(u) < 5:
                s = t
                idx = u + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_1033]
                    require uint8(u) < mem[_1033]
                    if mem[(32 * uint8(u)) + _1033 + 63 len 1] <= mem[(32 * uint8(idx)) + _1033 + 63 len 1]:
                        s = s
                        idx = idx + 1
                        continue 
                    require uint8(u) < mem[_1033]
                    _1459 = mem[(32 * uint8(u)) + _1033 + 32]
                    require uint8(idx) < mem[_1033]
                    require uint8(u) < mem[_1033]
                    mem[_1033 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _1033 + 63 len 1]
                    require uint8(idx) < mem[_1033]
                    mem[(32 * uint8(idx)) + _1033 + 32] = uint8(_1459)
                    s = _1459
                    idx = idx + 1
                    continue 
                t = s
                v = idx
                u = u + 1
                continue 
            require mem[_1033] == 6
            require maxNumber == maxNumber
            require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
            require stor11.length < stor10.length
            require bool(storA8C6[stor11.length]) != 1
            require stor11.length < stor10.length
            require block.timestamp <= storA9C6[stor11.length] + stor1.length - stor2.length
            require stor11.length < stor10.length
            mem[0] = 10
            require block.timestamp >= storA9C6[stor11.length] + stor2.length
            _1345 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1345] = 0
            t = 0
            u = 0
            s = 0
            while uint8(s) < 5:
                u = t
                idx = s + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_1033]
                    require uint8(s) < mem[_1033]
                    if mem[(32 * uint8(s)) + _1033 + 63 len 1] <= mem[(32 * uint8(idx)) + _1033 + 63 len 1]:
                        u = u
                        idx = idx + 1
                        continue 
                    require uint8(s) < mem[_1033]
                    _1778 = mem[(32 * uint8(s)) + _1033 + 32]
                    require uint8(idx) < mem[_1033]
                    require uint8(s) < mem[_1033]
                    mem[_1033 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1033 + 63 len 1]
                    require uint8(idx) < mem[_1033]
                    mem[(32 * uint8(idx)) + _1033 + 32] = uint8(_1778)
                    u = _1778
                    idx = idx + 1
                    continue 
                t = u
                u = idx
                s = s + 1
                continue 
        t = 0
        s = 0
        t = 0
        while uint8(s) < 6:
            require uint8(s) < mem[_1033]
            require mem[(32 * uint8(s)) + _1033 + 63 len 1] >= 1
            require mem[(32 * uint8(s)) + _1033 + 63 len 1] <= maxNumber
            require mem[(32 * uint8(s)) + _1033 + 63 len 1] > uint8(t)
            t = mem[(32 * uint8(s)) + _1033 + 32]
            s = s + 1
            t = mem[(32 * uint8(s)) + _1033 + 32]
            continue 
        stor4.length++
        if not stor4.length <= stor4.length + 1:
            mem[0] = 4
            s = sha3(mem[0]) + (6 * stor4.length) + 6
            while sha3(4) + (6 * stor4.length) > s:
                address(stor[s]) = 0
                stor1[s] = 0
                mem[0] = s + 1
                t = sha3(t + 1)
                while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
                stor2[t] = 0
                uint8(stor3[t]) = 0
                uint256(stor4[t].field_0) = 0
                uint256(stor5[t]) = 0
                t = t + 6
                continue 
        require stor11.length < stor10.length
        storC65A[stor11.length]++
        require storC65A[stor11.length] < stor4.length
        mem[0] = 4
        uint256(stor4[storC65A[stor11.length]].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
        uint256(stor4[storC65A[stor11.length]].field_0) = msg.sender or Mask(96, 160, uint256(stor4[storC65A[stor11.length]].field_0))
        uint256(stor4[storC65A[stor11.length]].field_256) = 6
        if not uint256(stor4[storC65A[stor11.length]].field_256) <= 6:
            mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
            s = sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + 1
            while sha3((6 * storC65A[stor11.length]) + sha3(4) + 1) + (uint256(stor4[storC65A[stor11.length]].field_256) + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
        uint256(stor4[storC65A[stor11.length]].field_1280) = stor11.length
        s = 0
        while uint8(s) < 6:
            require uint8(s) < mem[_1033]
            require uint8(s) < uint256(stor4[storC65A[stor11.length]].field_256)
            mem[0] = (6 * storC65A[stor11.length]) + sha3(4) + 1
            uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _1033 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * storC65A[stor11.length]) + ('name', 'stor4', 4) + 1)].field_0)
            s = s + 1
            continue 
        require stor11.length < stor10.length
        mem[0] = 10
        storC65A[stor11.length] += uint256(stor4[storC65A[stor11.length]].field_512)
        t = _1033
        idx = idx + 1
        continue 
    require stor11.length < stor10.length
    storC65A[stor11.length] += msg.value
    stor9EC6[stor11.length] += 85 * msg.value / 100
    storAAC6[stor11.length] += 5 * msg.value / 100
    if 0 == address(stor5[address(msg.sender)]):
        require stor11.length < stor10.length
        stor9EC6[stor11.length] += 10 * msg.value / 100
    else:
        require sub_6a52dfdb[address(stor5[address(msg.sender)])] < stor7.length
        stor9BA6[stor6[address(stor5[address(msg.sender)])]] += 10 * msg.value / 100
        require stor11.length < stor10.length
        storC65A[stor11.length] += 10 * msg.value / 100
}



}
