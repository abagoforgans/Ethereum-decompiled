contract main {


// =======================  Init code  ======================


uint8 stor0; offset 160
uint256 stor0;
uint256 stor1;
uint256 stor2;
uint256 stor3;
array of struct stor7;
uint256 stor8;
uint256 stor9;
array of uint256 stor10;
uint256 stor11;
uint256 stor12;
uint256 stor13;
uint256 stor14;
uint256 stor15;
uint256 stor16;
uint256 stor17;
uint256 stor18;
uint256 stor19;
uint8 stor20;
uint256 stor21;
uint256 stor22;
uint8 stor23;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint8 storC65A;
uint256 storC65A;
uint256 storC65A;
uint8 storC65A;

function _fallback() payable {
    uint8(stor0.field_160) = 16
    stor1 = 1800
    stor2 = 300
    stor3 = 10^16
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    stor7.length = 1
    if not stor7.length <= 1:
        idx = 2
        while 2 * stor7.length > idx:
            address(stor7[idx].field_0) = 0
            uint256(stor7[idx].field_256) = 0
            idx = idx + 2
            continue 
    stor8 = 50
    stor9 = 10 * 10^18
    stor10.length = 1
    if not stor10.length <= 1:
        mem[0] = 10
        idx = 13
        while sha3(10) + (13 * stor10.length) > idx + sha3(mem[0]):
            uint256(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            uint256(stor[idx + sha3(mem[0]) + 3]) = 0
            uint256(stor[idx + sha3(mem[0]) + 4]) = 0
            uint256(stor[idx + sha3(mem[0]) + 5]) = 0
            uint256(stor[idx + sha3(mem[0]) + 6]) = 0
            uint256(stor[idx + sha3(mem[0]) + 7]) = 0
            uint256(stor[idx + sha3(mem[0]) + 8]) = 0
            mem[0] = idx + sha3(mem[0]) + 8
            s = sha3(s + sha3(mem[0]) + 8)
            while sha3(s + sha3(mem[0]) + 8) + (uint256(stor[s + sha3(mem[0]) + 8]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint8(stor[s + sha3(mem[0]) + 9]) = 0
            uint256(stor[s + sha3(mem[0]) + 10]) = 0
            uint256(stor[s + sha3(mem[0]) + 11]) = 0
            uint8(stor[s + sha3(mem[0]) + 12]) = 0
            s = s + 13
            continue 
    require 0 < stor10.length
    stor11 = stor10
    stor12 = storC65A
    stor13 = storC65A
    stor14 = storC65A
    stor15 = storC65A
    stor16 = storC65A
    stor17 = storC65A
    stor18 = storC65A
    stor19 = storC65A
    if not storC65A:
        idx = 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        while (stor19 + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090 > idx:
            uint8(stor[idx]) = 0
            idx = idx + 1
            continue 
    else:
        s = 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        idx = sha3(0xc65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2b0)
        while sha3(0xc65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2b0) + (storC65A + 31 / 32) > idx:
            uint256(stor[s]) = uint256(stor[idx])
            s = s + 1
            idx = idx + 1
            continue 
        idx = (storC65A + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        while (stor19 + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090 > idx:
            uint8(stor[idx]) = 0
            idx = idx + 1
            continue 
    stor20 = storC65A
    stor21 = storC65A
    stor22 = storC65A
    stor23 = storC65A
    stor22 = block.timestamp
    stor23 = 0
    stor11 = 0
    return code.data[1013 len 7505]
}



// =====================  Runtime code  =====================


#
#  - draw()
#
const N = 6


uint8 maxNumber; offset 160
uint128 stor0; offset 160
address stor0;
uint256 stor0;
array of uint256 stor1;
array of uint256 stor2;
array of uint8 stor3;
mapping of address stor5;
mapping of uint256 sub_6a52dfdb;
array of struct stor7;
uint256 sub_fa06c38a;
uint256 sub_d7a58a87;
array of uint256 stor10;
uint256 stor11;
uint256 stor12;
uint256 stor13;
uint256 stor14;
uint256 stor15;
uint256 stor16;
uint256 stor17;
uint256 stor18;
array of uint256 stor19;
bool stor20; offset 256
uint8 stor20;
uint256 stor21;
uint256 stor22;
uint8 stor23;
uint256 stor24;
uint256 stor25;
uint256 stor26;
uint256 stor27;
uint256 stor28;
uint256 stor29;
uint256 stor30;
uint256 stor31;
uint256 stor32;
uint8 stor33;
uint256 stor34;
uint256 stor35;
uint8 stor36;
array of uint256 description;
array of uint8 stor39143100329280468107556231533410151018419134684842411016866935372961967991761;
array of uint256 stor62514009886607029107290561805838585334079798074568712924583230797734656856477;
array of uint256 stor70402538955001568223061751915610164204544900569080421535842365952732583900870;
array of address stor71709625427275648070435571067103625102151317872053819652964380875187535702993;
array of uint256 stor71709625427275648070435571067103625102151317872053819652964380875187535702995;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726043;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726044;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726045;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726046;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726047;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726048;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726049;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726050;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726051;
array of uint8 stor89717814153306320011181716697424560163256864414616650038987186496166826726052;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726053;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726054;
array of uint8 stor89717814153306320011181716697424560163256864414616650038987186496166826726055;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726057;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726058;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726059;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726060;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726061;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726062;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726063;
array of uint8 stor89717814153306320011181716697424560163256864414616650038987186496166826726065;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726066;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726067;
array of uint8 stor89717814153306320011181716697424560163256864414616650038987186496166826726068;

function ticketPrice() payable {
    return stor3.length
}

function sub_27ecc221(?) payable {
    return stor2.length
}

function maxNumber() payable {
    return maxNumber
}

function sub_6a52dfdb(?) payable {
    return sub_6a52dfdb[arg1]
}

function description() payable {
    return description[0 len description.length]
}

function sub_ae466313(?) payable {
    return stor1.length
}

function sub_d7a58a87(?) payable {
    return sub_d7a58a87
}

function sub_fa06c38a(?) payable {
    return sub_fa06c38a
}

function _fallback() payable {
    stor13 += msg.value
}

function sub_0db35d8c(?) payable {
    require msg.sender == address(stor0.field_0)
    sub_fa06c38a = arg2
    sub_d7a58a87 = 10^18 * arg1
}

function sub_766fc3ef(?) payable {
    require msg.sender == address(stor0.field_0)
    description[] = Array(len=arg1.length, data=arg1[all])
}

function sub_d9ddb179(?) payable {
    return stor24, stor25, stor26, stor27, stor28, stor29, stor30, stor31, stor33, stor34, stor35, bool(stor36)
}

function sub_80322dd5(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 >= 10^15
    stor3.length = arg1
    stor21 = arg1
}

function sub_60b663bb(?) payable {
    return stor11, stor12, stor13, stor14, stor15, stor16, stor17, stor18, uint8(stor20.field_0), stor21, stor22, bool(stor23)
}

function transferOwnership(address arg1) payable {
    require address(stor0.field_0) == msg.sender
    uint256(stor0.field_0) = arg1 or Mask(96, 160, uint256(stor0.field_0))
}

function tickets(uint256 arg1) payable {
    require arg1 < stor4.length
    return stor9E8A[arg1], stor8A35[arg1], stor568A[arg1], uint256(stor[(5 * arg1) + code.data[7473 len 32]])
}

function sub_b28c7c25(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 > 6
    Mask(96, 0, stor0.field_160) = Mask(96, 0, arg1)
    uint8(stor20.field_0) = arg1
    stor20.field_256 % 1 = 0
}

function sub_236af88c(?) payable {
    require not address(stor5[address(msg.sender)])
    require sub_6a52dfdb[address(arg1)]
    uint256(stor5[address(msg.sender)]) = arg1 or Mask(96, 160, uint256(stor5[address(msg.sender)]))
}

function games(uint256 arg1) payable {
    require arg1 < stor10.length
    return stor10[arg1], 
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           bool(storC65A[arg1])
}

function sub_d2a8bcf5(?) payable {
    require sub_fa06c38a > 0
    require msg.value >= sub_d7a58a87
    stor7.length++
    if not stor7.length <= stor7.length + 1:
        idx = 2 * stor7.length + 1
        while 2 * stor7.length > idx:
            address(stor7[idx].field_0) = 0
            uint256(stor7[idx].field_256) = 0
            idx = idx + 2
            continue 
    require stor7.length - 1 < stor7.length
    uint256(stor7[stor7.length - 1].field_0) = msg.sender or Mask(96, 160, uint256(stor7[stor7.length - 1].field_0))
    sub_6a52dfdb[address(msg.sender)] = stor7.length - 1
    sub_fa06c38a--
    call address(stor0.field_0) with:
       value msg.value wei
         gas 0 wei
    if not ext_call.success:
        stor13 += msg.value
}

function sub_ca34f1f2(?) payable {
    idx = 0
    s = 0
    while idx < stor4.length:
        mem[0] = 4
        if stor568A[idx] != arg2:
            idx = idx + 1
            s = s
            continue 
        require idx < stor4.length
        idx = idx + 1
        s = s + stor8A35[idx]
        continue 
    if s <= 0:
        return arg1
    if arg1 / s < stor3.length:
        return arg1
    t = 0
    idx = 0
    while idx < stor4.length:
        mem[0] = 4
        if stor568A[idx] != arg2:
            t = t
            idx = idx + 1
            continue 
        require idx < stor4.length
        mem[32] = 5
        require idx < stor4.length
        mem[0] = 4
        if not address(stor5[stor9E8A[idx]]):
            uint256(stor[code.data[7473 len 32] + (5 * idx)]) += 80 * arg1 / s * stor9E8A[idx] / 100
        else:
            uint256(stor[code.data[7473 len 32] + (5 * idx)]) += arg1 / s * stor9E8A[idx]
        t = arg1 / s * stor9E8A[idx]
        idx = idx + 1
        continue 
    return 0
}

function sub_612c10bf(?) payable {
    mem[96] = arg1.length
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    require arg1.length == 6
    require maxNumber == arg2
    require msg.value >= stor3.length
    require bool(stor23) != 1
    require block.timestamp <= stor22 + stor1.length - stor2.length
    require block.timestamp >= stor22 + stor2.length
    mem[(32 * arg1.length) + 128] = 0
    s = 0
    t = 0
    idx = 0
    while uint8(idx) < 5:
        u = s
        t = idx + 1
        while uint8(t) < 6:
            require uint8(t) < arg1.length
            require uint8(idx) < arg1.length
            if mem[(32 * uint8(idx)) + 159 len 1] <= mem[(32 * uint8(t)) + 159 len 1]:
                u = u
                t = t + 1
                continue 
            require uint8(idx) < arg1.length
            _47 = mem[(32 * uint8(idx)) + 128]
            require uint8(t) < arg1.length
            require uint8(idx) < arg1.length
            mem[(32 * uint8(idx)) + 128] = mem[(32 * uint8(t)) + 159 len 1]
            require uint8(t) < arg1.length
            mem[(32 * uint8(t)) + 128] = uint8(_47)
            u = _47
            t = t + 1
            continue 
        s = u
        t = t
        idx = idx + 1
        continue 
    s = 0
    idx = 0
    s = 0
    while uint8(idx) < 6:
        require uint8(idx) < arg1.length
        require mem[(32 * uint8(idx)) + 159 len 1] >= 1
        require mem[(32 * uint8(idx)) + 159 len 1] <= maxNumber
        require mem[(32 * uint8(idx)) + 159 len 1] > uint8(s)
        s = mem[(32 * uint8(idx)) + 128]
        idx = idx + 1
        s = mem[(32 * uint8(idx)) + 128]
        continue 
    stor4.length++
    if not stor4.length <= stor4.length + 1:
        mem[0] = 4
        idx = (5 * stor4.length) + 5
        while sha3(4) + (5 * stor4.length) > idx + sha3(mem[0]):
            address(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            mem[0] = idx + sha3(mem[0]) + 1
            s = sha3(s + sha3(mem[0]) + 1)
            while sha3(s + sha3(mem[0]) + 1) + (uint256(stor[s + sha3(mem[0]) + 1]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint256(stor[s + sha3(mem[0]) + 2]) = 0
            uint8(stor[s + sha3(mem[0]) + 3]) = 0
            uint256(stor[s + sha3(mem[0]) + 4]) = 0
            s = s + 5
            continue 
    stor15++
    require stor15 < stor4.length
    uint256(stor4[stor15].field_512) = msg.value / stor3.length
    uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
    uint256(stor4[stor15].field_256) = 6
    if not uint256(stor4[stor15].field_256) <= 6:
        idx = 1
        while uint256(stor4[stor15].field_256) + 31 / 32 > idx:
            uint256(stor[idx + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = 0
            idx = idx + 1
            continue 
    idx = 0
    while uint8(idx) < 6:
        require uint8(idx) < arg1.length
        require uint8(idx) < uint256(stor4[stor15].field_256)
        mem[0] = (5 * stor15) + sha3(4) + 1
        uint256(stor[(uint8(idx) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(idx)) + 128] * 256^(idx % 32) or !(255 * 256^(idx % 32)) and uint256(stor[(uint8(idx) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
        idx = idx + 1
        continue 
    stor16 += uint256(stor4[stor15].field_512)
    stor14 += msg.value
    stor13 += 85 * msg.value / 100
    stor17 += 5 * msg.value / 100
    stor18 += 10 * msg.value / 100
    if address(stor5[address(msg.sender)]) != 0:
        require sub_6a52dfdb[address(stor5[address(msg.sender)])] < stor7.length
        stor9BA6[stor6[address(stor5[address(msg.sender)])]] += 5 * msg.value / 100
}

function sub_79747295(?) payable {
    mem[96] = 0
    mem[128] = 0
    mem[160] = 6
    mem[384] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 416
    idx = 0
    s = 0
    t = 0
    while idx < 123456789:
        mem[mem[64]] = block.difficulty
        mem[mem[64] + 32] = address(block.coinbase)
        mem[mem[64] + 52] = block.timestamp
        mem[mem[64] + 84] = address(msg.sender)
        mem[mem[64] + 104] = idx
        if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber):
            idx = idx + 1
            s = s
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber) < mem[384]
        if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)) + 447 len 1]:
            idx = idx + 1
            s = s
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber) < mem[384]
        mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)) + 416] = 1
        require uint8(s) < mem[160]
        mem[(32 * uint8(s)) + 192] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)
        if uint8(s + 1) != 6:
            idx = idx + 1
            s = s + 1
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        _115 = mem[64]
        mem[64] = mem[64] + 32
        mem[_115] = 0
        s = 0
        t = 0
        idx = 0
        while uint8(idx) < 5:
            u = s
            t = idx + 1
            while uint8(t) < 6:
                require uint8(t) < mem[160]
                require uint8(idx) < mem[160]
                if mem[(32 * uint8(idx)) + 223 len 1] <= mem[(32 * uint8(t)) + 223 len 1]:
                    u = u
                    t = t + 1
                    continue 
                require uint8(idx) < mem[160]
                _410 = mem[(32 * uint8(idx)) + 192]
                require uint8(t) < mem[160]
                require uint8(idx) < mem[160]
                mem[(32 * uint8(idx)) + 192] = mem[(32 * uint8(t)) + 223 len 1]
                require uint8(t) < mem[160]
                mem[(32 * uint8(t)) + 192] = uint8(_410)
                u = _410
                t = t + 1
                continue 
            s = u
            t = t
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[160]
        _317 = mem[160]
        mem[mem[64] + 64 len 32 * mem[160]] = mem[192 len 32 * mem[160]]
        return 32, mem[mem[64] + 32 len (32 * _317) + 32]
    _54 = mem[64]
    mem[64] = mem[64] + 32
    mem[_54] = 0
    s = 0
    u = 0
    t = 0
    while uint8(t) < 5:
        u = s
        idx = t + 1
        while uint8(idx) < 6:
            require uint8(idx) < mem[160]
            require uint8(t) < mem[160]
            if mem[(32 * uint8(t)) + 223 len 1] <= mem[(32 * uint8(idx)) + 223 len 1]:
                u = u
                idx = idx + 1
                continue 
            require uint8(t) < mem[160]
            _344 = mem[(32 * uint8(t)) + 192]
            require uint8(idx) < mem[160]
            require uint8(t) < mem[160]
            mem[(32 * uint8(t)) + 192] = mem[(32 * uint8(idx)) + 223 len 1]
            require uint8(idx) < mem[160]
            mem[(32 * uint8(idx)) + 192] = uint8(_344)
            u = _344
            idx = idx + 1
            continue 
        s = u
        u = idx
        t = t + 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[160]
    _220 = mem[160]
    mem[mem[64] + 64 len 32 * mem[160]] = mem[192 len 32 * mem[160]]
    return 32, mem[mem[64] + 32 len (32 * _220) + 32]
}

function startGame() payable {
    require bool(stor23) != 0
    stor24 = stor11
    stor25 = stor12
    stor26 = stor13
    stor27 = stor14
    stor28 = stor15
    stor29 = stor16
    stor30 = stor17
    stor31 = stor18
    stor32 = stor19.length
    if not stor19.length:
        idx = 0xc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb
        while (stor32 + 31 / 32) - 0x3684050d07118f73cfc5f92ecb0a1327c7651fbcd509d23ecd5dbee7d6d79945 > idx:
            uint8(stor[idx]) = 0
            idx = idx + 1
            continue 
    else:
        s = 0xc97bfaf2f8ee708c303a06d134f5ecd8389ae0432af62dc132a24118292866bb
        idx = 0
        while stor19.length + 31 / 32 > idx:
            uint256(stor[s]) = stor19[idx]
            s = s + 1
            idx = idx + 1
            continue 
        idx = (stor19.length + 31 / 32) - 0x3684050d07118f73cfc5f92ecb0a1327c7651fbcd509d23ecd5dbee7d6d79945
        while (stor32 + 31 / 32) - 0x3684050d07118f73cfc5f92ecb0a1327c7651fbcd509d23ecd5dbee7d6d79945 > idx:
            uint8(stor[idx]) = 0
            idx = idx + 1
            continue 
    stor33 = uint8(stor20.field_0)
    stor34 = stor21
    stor35 = stor22
    stor36 = stor23
    stor10.length++
    if not stor10.length <= stor10.length + 1:
        mem[0] = 10
        idx = (13 * stor10.length) + 13
        while sha3(10) + (13 * stor10.length) > idx + sha3(mem[0]):
            uint256(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            uint256(stor[idx + sha3(mem[0]) + 3]) = 0
            uint256(stor[idx + sha3(mem[0]) + 4]) = 0
            uint256(stor[idx + sha3(mem[0]) + 5]) = 0
            uint256(stor[idx + sha3(mem[0]) + 6]) = 0
            uint256(stor[idx + sha3(mem[0]) + 7]) = 0
            uint256(stor[idx + sha3(mem[0]) + 8]) = 0
            mem[0] = idx + sha3(mem[0]) + 8
            s = sha3(s + sha3(mem[0]) + 8)
            while sha3(s + sha3(mem[0]) + 8) + (uint256(stor[s + sha3(mem[0]) + 8]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint8(stor[s + sha3(mem[0]) + 9]) = 0
            uint256(stor[s + sha3(mem[0]) + 10]) = 0
            uint256(stor[s + sha3(mem[0]) + 11]) = 0
            uint8(stor[s + sha3(mem[0]) + 12]) = 0
            s = s + 13
            continue 
    require stor10.length - 1 < stor10.length
    stor11 = storC65A[stor10.length]
    stor12 = storC65A[stor10.length]
    stor13 = storC65A[stor10.length]
    stor14 = storC65A[stor10.length]
    stor15 = storC65A[stor10.length]
    stor16 = storC65A[stor10.length]
    stor17 = storC65A[stor10.length]
    stor18 = storC65A[stor10.length]
    stor19.length = storC65A[stor10.length]
    if not storC65A[stor10.length]:
        idx = 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        while (stor19.length + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090 > idx:
            uint8(stor[idx]) = 0
            idx = idx + 1
            continue 
    else:
        s = 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        idx = 0
        while storC65A[stor10.length] + 31 / 32 > idx:
            uint256(stor[s]) = uint256(stor[idx + sha3((13 * stor10.length) - 0x39a5844729cae3e308f36a5ce933956d7c6367997d26743ca06a70b77c062d5d)])
            s = s + 1
            idx = idx + 1
            continue 
        idx = (storC65A[stor10.length] + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        while (stor19.length + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090 > idx:
            uint8(stor[idx]) = 0
            idx = idx + 1
            continue 
    uint8(stor20.field_0) = storC65A[stor10.length]
    stor21 = storC65A[stor10.length]
    stor22 = storC65A[stor10.length]
    stor23 = storC65A[stor10.length]
    stor11 = stor10.length - 1
    stor15 = 0
    stor16 = 0
    stor14 = 0
    stor12 = stor26
    stor13 = 0
    uint8(stor20.field_0) = maxNumber
    stor21 = stor3.length
    stor17 = 0
    stor18 = 0
    stor23 = 0
    if block.timestamp <= stor35 + stor1.length:
        stor22 = stor35 + stor1.length
    else:
        stor22 = block.timestamp
    idx = 0
    while idx < stor7.length:
        mem[0] = 7
        stor9BA6[idx] = 0
        idx = idx + 1
        continue 
    stor4.length = 0
    if not stor4.length <= 0:
        mem[0] = 4
        idx = 0
        while sha3(4) + (5 * stor4.length) > idx + sha3(mem[0]):
            address(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            mem[0] = idx + sha3(mem[0]) + 1
            s = sha3(s + sha3(mem[0]) + 1)
            while sha3(s + sha3(mem[0]) + 1) + (uint256(stor[s + sha3(mem[0]) + 1]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint256(stor[s + sha3(mem[0]) + 2]) = 0
            uint8(stor[s + sha3(mem[0]) + 3]) = 0
            uint256(stor[s + sha3(mem[0]) + 4]) = 0
            s = s + 5
            continue 
}

function sub_d7264f6c(?) payable {
    mem[64] = 128
    mem[96] = 0
    require msg.value >= arg1 * stor3.length
    s = 96
    idx = 0
    while idx < arg1:
        _973 = mem[64]
        mem[64] = mem[64] + 32
        mem[_973] = 0
        _974 = mem[64]
        mem[64] = mem[64] + 32
        mem[_974] = 0
        _975 = mem[64]
        if msize < mem[64]:
            mem[mem[64]] = 6
            if msize < mem[64] + 224:
                mem[mem[64] + 224] = uint8(maxNumber + 1)
                mem[64] = mem[64] + (32 * uint8(maxNumber + 1)) + 256
                s = 0
                t = 0
                u = 0
                while s < 123456789:
                    mem[mem[64]] = block.difficulty
                    mem[mem[64] + 32] = address(block.coinbase)
                    mem[mem[64] + 52] = block.timestamp
                    mem[mem[64] + 84] = address(msg.sender)
                    mem[mem[64] + 104] = s
                    if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                        s = s + 1
                        t = t
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_975 + 224]
                    if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _975 + 287 len 1]:
                        s = s + 1
                        t = t
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_975 + 224]
                    mem[_975 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 256] = 1
                    require uint8(t) < mem[_975]
                    mem[_975 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                    if uint8(t + 1) != 6:
                        s = s + 1
                        t = t + 1
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    _1087 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1087] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_975]
                            require uint8(s) < mem[_975]
                            if mem[(32 * uint8(s)) + _975 + 63 len 1] <= mem[(32 * uint8(idx)) + _975 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_975]
                            _1526 = mem[(32 * uint8(s)) + _975 + 32]
                            require uint8(idx) < mem[_975]
                            require uint8(s) < mem[_975]
                            mem[_975 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _975 + 63 len 1]
                            require uint8(idx) < mem[_975]
                            mem[_975 + (32 * uint8(idx)) + 32] = uint8(_1526)
                            u = _1526
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    require mem[_975] == 6
                    require maxNumber == maxNumber
                    require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                    require bool(stor23) != 1
                    require block.timestamp <= stor22 + stor1.length - stor2.length
                    require block.timestamp >= stor22 + stor2.length
                    _1422 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1422] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_975]
                            require uint8(s) < mem[_975]
                            if mem[(32 * uint8(s)) + _975 + 63 len 1] <= mem[(32 * uint8(idx)) + _975 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_975]
                            _1835 = mem[(32 * uint8(s)) + _975 + 32]
                            require uint8(idx) < mem[_975]
                            require uint8(s) < mem[_975]
                            mem[_975 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _975 + 63 len 1]
                            require uint8(idx) < mem[_975]
                            mem[_975 + (32 * uint8(idx)) + 32] = uint8(_1835)
                            u = _1835
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    t = 0
                    s = 0
                    t = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_975]
                        require mem[(32 * uint8(s)) + _975 + 63 len 1] >= 1
                        require mem[(32 * uint8(s)) + _975 + 63 len 1] <= maxNumber
                        require mem[(32 * uint8(s)) + _975 + 63 len 1] > uint8(t)
                        t = mem[(32 * uint8(s)) + _975 + 32]
                        s = s + 1
                        t = mem[(32 * uint8(s)) + _975 + 32]
                        continue 
                    stor4.length++
                    if not stor4.length <= stor4.length + 1:
                        mem[0] = 4
                        s = sha3(mem[0]) + (5 * stor4.length) + 5
                        while sha3(4) + (5 * stor4.length) > s:
                            address(stor[s]) = 0
                            stor1[s] = 0
                            mem[0] = s + 1
                            t = sha3(t + 1)
                            while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                                uint256(stor[t]) = 0
                                t = t + 1
                                continue 
                            stor2[t] = 0
                            stor3[t] = 0
                            uint256(stor4[t].field_0) = 0
                            t = t + 5
                            continue 
                    stor15++
                    require stor15 < stor4.length
                    mem[0] = 4
                    uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                    uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
                    uint256(stor4[stor15].field_256) = 6
                    if not uint256(stor4[stor15].field_256) <= 6:
                        mem[0] = (5 * stor15) + sha3(4) + 1
                        s = sha3((5 * stor15) + sha3(4) + 1) + 1
                        while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_975]
                        require uint8(s) < uint256(stor4[stor15].field_256)
                        mem[0] = (5 * stor15) + sha3(4) + 1
                        uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _975 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                        s = s + 1
                        continue 
                    stor16 += uint256(stor4[stor15].field_512)
                    s = _975
                    idx = idx + 1
                    continue 
                _1026 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1026] = 0
                t = 0
                v = 0
                u = 0
                while uint8(u) < 5:
                    s = t
                    idx = u + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_975]
                        require uint8(u) < mem[_975]
                        if mem[(32 * uint8(u)) + _975 + 63 len 1] <= mem[(32 * uint8(idx)) + _975 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(u) < mem[_975]
                        _1356 = mem[(32 * uint8(u)) + _975 + 32]
                        require uint8(idx) < mem[_975]
                        require uint8(u) < mem[_975]
                        mem[_975 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _975 + 63 len 1]
                        require uint8(idx) < mem[_975]
                        mem[_975 + (32 * uint8(idx)) + 32] = uint8(_1356)
                        s = _1356
                        idx = idx + 1
                        continue 
                    t = s
                    v = idx
                    u = u + 1
                    continue 
                require mem[_975] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require bool(stor23) != 1
                require block.timestamp <= stor22 + stor1.length - stor2.length
                require block.timestamp >= stor22 + stor2.length
                _1254 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1254] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_975]
                        require uint8(s) < mem[_975]
                        if mem[(32 * uint8(s)) + _975 + 63 len 1] <= mem[(32 * uint8(idx)) + _975 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_975]
                        _1654 = mem[(32 * uint8(s)) + _975 + 32]
                        require uint8(idx) < mem[_975]
                        require uint8(s) < mem[_975]
                        mem[_975 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _975 + 63 len 1]
                        require uint8(idx) < mem[_975]
                        mem[_975 + (32 * uint8(idx)) + 32] = uint8(_1654)
                        u = _1654
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
            else:
                _983 = msize
                mem[msize] = uint8(maxNumber + 1)
                mem[64] = _983 + (32 * uint8(maxNumber + 1)) + 32
                s = 0
                t = 0
                u = 0
                while s < 123456789:
                    mem[mem[64]] = block.difficulty
                    mem[mem[64] + 32] = address(block.coinbase)
                    mem[mem[64] + 52] = block.timestamp
                    mem[mem[64] + 84] = address(msg.sender)
                    mem[mem[64] + 104] = s
                    if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                        s = s + 1
                        t = t
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_983]
                    if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _983 + 63 len 1]:
                        s = s + 1
                        t = t
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_983]
                    mem[_983 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 32] = 1
                    require uint8(t) < mem[_975]
                    mem[_975 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                    if uint8(t + 1) != 6:
                        s = s + 1
                        t = t + 1
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    _1089 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1089] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_975]
                            require uint8(s) < mem[_975]
                            if mem[(32 * uint8(s)) + _975 + 63 len 1] <= mem[(32 * uint8(idx)) + _975 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_975]
                            _1532 = mem[(32 * uint8(s)) + _975 + 32]
                            require uint8(idx) < mem[_975]
                            require uint8(s) < mem[_975]
                            mem[_975 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _975 + 63 len 1]
                            require uint8(idx) < mem[_975]
                            mem[_975 + (32 * uint8(idx)) + 32] = uint8(_1532)
                            u = _1532
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    require mem[_975] == 6
                    require maxNumber == maxNumber
                    require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                    require bool(stor23) != 1
                    require block.timestamp <= stor22 + stor1.length - stor2.length
                    require block.timestamp >= stor22 + stor2.length
                    _1423 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1423] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_975]
                            require uint8(s) < mem[_975]
                            if mem[(32 * uint8(s)) + _975 + 63 len 1] <= mem[(32 * uint8(idx)) + _975 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_975]
                            _1838 = mem[(32 * uint8(s)) + _975 + 32]
                            require uint8(idx) < mem[_975]
                            require uint8(s) < mem[_975]
                            mem[_975 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _975 + 63 len 1]
                            require uint8(idx) < mem[_975]
                            mem[_975 + (32 * uint8(idx)) + 32] = uint8(_1838)
                            u = _1838
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    t = 0
                    s = 0
                    t = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_975]
                        require mem[(32 * uint8(s)) + _975 + 63 len 1] >= 1
                        require mem[(32 * uint8(s)) + _975 + 63 len 1] <= maxNumber
                        require mem[(32 * uint8(s)) + _975 + 63 len 1] > uint8(t)
                        t = mem[(32 * uint8(s)) + _975 + 32]
                        s = s + 1
                        t = mem[(32 * uint8(s)) + _975 + 32]
                        continue 
                    stor4.length++
                    if not stor4.length <= stor4.length + 1:
                        mem[0] = 4
                        s = sha3(mem[0]) + (5 * stor4.length) + 5
                        while sha3(4) + (5 * stor4.length) > s:
                            address(stor[s]) = 0
                            stor1[s] = 0
                            mem[0] = s + 1
                            t = sha3(t + 1)
                            while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                                uint256(stor[t]) = 0
                                t = t + 1
                                continue 
                            stor2[t] = 0
                            stor3[t] = 0
                            uint256(stor4[t].field_0) = 0
                            t = t + 5
                            continue 
                    stor15++
                    require stor15 < stor4.length
                    mem[0] = 4
                    uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                    uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
                    uint256(stor4[stor15].field_256) = 6
                    if not uint256(stor4[stor15].field_256) <= 6:
                        mem[0] = (5 * stor15) + sha3(4) + 1
                        s = sha3((5 * stor15) + sha3(4) + 1) + 1
                        while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_975]
                        require uint8(s) < uint256(stor4[stor15].field_256)
                        mem[0] = (5 * stor15) + sha3(4) + 1
                        uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _975 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                        s = s + 1
                        continue 
                    stor16 += uint256(stor4[stor15].field_512)
                    s = _975
                    idx = idx + 1
                    continue 
                _1028 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1028] = 0
                t = 0
                v = 0
                u = 0
                while uint8(u) < 5:
                    s = t
                    idx = u + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_975]
                        require uint8(u) < mem[_975]
                        if mem[(32 * uint8(u)) + _975 + 63 len 1] <= mem[(32 * uint8(idx)) + _975 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(u) < mem[_975]
                        _1361 = mem[(32 * uint8(u)) + _975 + 32]
                        require uint8(idx) < mem[_975]
                        require uint8(u) < mem[_975]
                        mem[_975 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _975 + 63 len 1]
                        require uint8(idx) < mem[_975]
                        mem[_975 + (32 * uint8(idx)) + 32] = uint8(_1361)
                        s = _1361
                        idx = idx + 1
                        continue 
                    t = s
                    v = idx
                    u = u + 1
                    continue 
                require mem[_975] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require bool(stor23) != 1
                require block.timestamp <= stor22 + stor1.length - stor2.length
                require block.timestamp >= stor22 + stor2.length
                _1255 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1255] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_975]
                        require uint8(s) < mem[_975]
                        if mem[(32 * uint8(s)) + _975 + 63 len 1] <= mem[(32 * uint8(idx)) + _975 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_975]
                        _1658 = mem[(32 * uint8(s)) + _975 + 32]
                        require uint8(idx) < mem[_975]
                        require uint8(s) < mem[_975]
                        mem[_975 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _975 + 63 len 1]
                        require uint8(idx) < mem[_975]
                        mem[_975 + (32 * uint8(idx)) + 32] = uint8(_1658)
                        u = _1658
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
            t = 0
            s = 0
            t = 0
            while uint8(s) < 6:
                require uint8(s) < mem[_975]
                require mem[(32 * uint8(s)) + _975 + 63 len 1] >= 1
                require mem[(32 * uint8(s)) + _975 + 63 len 1] <= maxNumber
                require mem[(32 * uint8(s)) + _975 + 63 len 1] > uint8(t)
                t = mem[(32 * uint8(s)) + _975 + 32]
                s = s + 1
                t = mem[(32 * uint8(s)) + _975 + 32]
                continue 
            stor4.length++
            if not stor4.length <= stor4.length + 1:
                mem[0] = 4
                s = sha3(mem[0]) + (5 * stor4.length) + 5
                while sha3(4) + (5 * stor4.length) > s:
                    address(stor[s]) = 0
                    stor1[s] = 0
                    mem[0] = s + 1
                    t = sha3(t + 1)
                    while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                        uint256(stor[t]) = 0
                        t = t + 1
                        continue 
                    stor2[t] = 0
                    stor3[t] = 0
                    uint256(stor4[t].field_0) = 0
                    t = t + 5
                    continue 
            stor15++
            require stor15 < stor4.length
            mem[0] = 4
            uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
            uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
            uint256(stor4[stor15].field_256) = 6
            if not uint256(stor4[stor15].field_256) <= 6:
                mem[0] = (5 * stor15) + sha3(4) + 1
                s = sha3((5 * stor15) + sha3(4) + 1) + 1
                while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
            s = 0
            while uint8(s) < 6:
                require uint8(s) < mem[_975]
                require uint8(s) < uint256(stor4[stor15].field_256)
                mem[0] = (5 * stor15) + sha3(4) + 1
                uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _975 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                s = s + 1
                continue 
            stor16 += uint256(stor4[stor15].field_512)
            t = _975
            idx = idx + 1
            continue 
        _980 = msize
        mem[msize] = 6
        if msize < _980 + 224:
            mem[_980 + 224] = uint8(maxNumber + 1)
            mem[64] = _980 + (32 * uint8(maxNumber + 1)) + 256
            s = 0
            t = 0
            u = 0
            while s < 123456789:
                mem[mem[64]] = block.difficulty
                mem[mem[64] + 32] = address(block.coinbase)
                mem[mem[64] + 52] = block.timestamp
                mem[mem[64] + 84] = address(msg.sender)
                mem[mem[64] + 104] = s
                if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_980 + 224]
                if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _980 + 287 len 1]:
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_980 + 224]
                mem[_980 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 256] = 1
                require uint8(t) < mem[_980]
                mem[_980 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                if uint8(t + 1) != 6:
                    s = s + 1
                    t = t + 1
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                _1091 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1091] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_980]
                        require uint8(s) < mem[_980]
                        if mem[(32 * uint8(s)) + _980 + 63 len 1] <= mem[(32 * uint8(idx)) + _980 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_980]
                        _1538 = mem[(32 * uint8(s)) + _980 + 32]
                        require uint8(idx) < mem[_980]
                        require uint8(s) < mem[_980]
                        mem[_980 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _980 + 63 len 1]
                        require uint8(idx) < mem[_980]
                        mem[_980 + (32 * uint8(idx)) + 32] = uint8(_1538)
                        u = _1538
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                require mem[_980] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require bool(stor23) != 1
                require block.timestamp <= stor22 + stor1.length - stor2.length
                require block.timestamp >= stor22 + stor2.length
                _1424 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1424] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_980]
                        require uint8(s) < mem[_980]
                        if mem[(32 * uint8(s)) + _980 + 63 len 1] <= mem[(32 * uint8(idx)) + _980 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_980]
                        _1841 = mem[(32 * uint8(s)) + _980 + 32]
                        require uint8(idx) < mem[_980]
                        require uint8(s) < mem[_980]
                        mem[_980 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _980 + 63 len 1]
                        require uint8(idx) < mem[_980]
                        mem[_980 + (32 * uint8(idx)) + 32] = uint8(_1841)
                        u = _1841
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                t = 0
                s = 0
                t = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_980]
                    require mem[(32 * uint8(s)) + _980 + 63 len 1] >= 1
                    require mem[(32 * uint8(s)) + _980 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(s)) + _980 + 63 len 1] > uint8(t)
                    t = mem[(32 * uint8(s)) + _980 + 32]
                    s = s + 1
                    t = mem[(32 * uint8(s)) + _980 + 32]
                    continue 
                stor4.length++
                if not stor4.length <= stor4.length + 1:
                    mem[0] = 4
                    s = sha3(mem[0]) + (5 * stor4.length) + 5
                    while sha3(4) + (5 * stor4.length) > s:
                        address(stor[s]) = 0
                        stor1[s] = 0
                        mem[0] = s + 1
                        t = sha3(t + 1)
                        while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                            uint256(stor[t]) = 0
                            t = t + 1
                            continue 
                        stor2[t] = 0
                        stor3[t] = 0
                        uint256(stor4[t].field_0) = 0
                        t = t + 5
                        continue 
                stor15++
                require stor15 < stor4.length
                mem[0] = 4
                uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
                uint256(stor4[stor15].field_256) = 6
                if not uint256(stor4[stor15].field_256) <= 6:
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    s = sha3((5 * stor15) + sha3(4) + 1) + 1
                    while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                s = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_980]
                    require uint8(s) < uint256(stor4[stor15].field_256)
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _980 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                    s = s + 1
                    continue 
                stor16 += uint256(stor4[stor15].field_512)
                s = _980
                idx = idx + 1
                continue 
            _1030 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1030] = 0
            t = 0
            v = 0
            u = 0
            while uint8(u) < 5:
                s = t
                idx = u + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_980]
                    require uint8(u) < mem[_980]
                    if mem[(32 * uint8(u)) + _980 + 63 len 1] <= mem[(32 * uint8(idx)) + _980 + 63 len 1]:
                        s = s
                        idx = idx + 1
                        continue 
                    require uint8(u) < mem[_980]
                    _1366 = mem[(32 * uint8(u)) + _980 + 32]
                    require uint8(idx) < mem[_980]
                    require uint8(u) < mem[_980]
                    mem[_980 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _980 + 63 len 1]
                    require uint8(idx) < mem[_980]
                    mem[_980 + (32 * uint8(idx)) + 32] = uint8(_1366)
                    s = _1366
                    idx = idx + 1
                    continue 
                t = s
                v = idx
                u = u + 1
                continue 
            require mem[_980] == 6
            require maxNumber == maxNumber
            require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
            require bool(stor23) != 1
            require block.timestamp <= stor22 + stor1.length - stor2.length
            require block.timestamp >= stor22 + stor2.length
            _1256 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1256] = 0
            t = 0
            u = 0
            s = 0
            while uint8(s) < 5:
                u = t
                idx = s + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_980]
                    require uint8(s) < mem[_980]
                    if mem[(32 * uint8(s)) + _980 + 63 len 1] <= mem[(32 * uint8(idx)) + _980 + 63 len 1]:
                        u = u
                        idx = idx + 1
                        continue 
                    require uint8(s) < mem[_980]
                    _1662 = mem[(32 * uint8(s)) + _980 + 32]
                    require uint8(idx) < mem[_980]
                    require uint8(s) < mem[_980]
                    mem[_980 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _980 + 63 len 1]
                    require uint8(idx) < mem[_980]
                    mem[_980 + (32 * uint8(idx)) + 32] = uint8(_1662)
                    u = _1662
                    idx = idx + 1
                    continue 
                t = u
                u = idx
                s = s + 1
                continue 
            t = 0
            s = 0
            t = 0
            while uint8(s) < 6:
                require uint8(s) < mem[_980]
                require mem[(32 * uint8(s)) + _980 + 63 len 1] >= 1
                require mem[(32 * uint8(s)) + _980 + 63 len 1] <= maxNumber
                require mem[(32 * uint8(s)) + _980 + 63 len 1] > uint8(t)
                t = mem[(32 * uint8(s)) + _980 + 32]
                s = s + 1
                t = mem[(32 * uint8(s)) + _980 + 32]
                continue 
            stor4.length++
            if not stor4.length <= stor4.length + 1:
                mem[0] = 4
                s = sha3(mem[0]) + (5 * stor4.length) + 5
                while sha3(4) + (5 * stor4.length) > s:
                    address(stor[s]) = 0
                    stor1[s] = 0
                    mem[0] = s + 1
                    t = sha3(t + 1)
                    while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                        uint256(stor[t]) = 0
                        t = t + 1
                        continue 
                    stor2[t] = 0
                    stor3[t] = 0
                    uint256(stor4[t].field_0) = 0
                    t = t + 5
                    continue 
        else:
            _985 = msize
            mem[msize] = uint8(maxNumber + 1)
            mem[64] = _985 + (32 * uint8(maxNumber + 1)) + 32
            t = 0
            u = 0
            v = 0
            while t < 123456789:
                mem[mem[64]] = block.difficulty
                mem[mem[64] + 32] = address(block.coinbase)
                mem[mem[64] + 52] = block.timestamp
                mem[mem[64] + 84] = address(msg.sender)
                mem[mem[64] + 104] = t
                if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber):
                    t = t + 1
                    u = u
                    v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber) < mem[_985]
                if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)) + _985 + 63 len 1]:
                    t = t + 1
                    u = u
                    v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber) < mem[_985]
                mem[_985 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)) + 32] = 1
                require uint8(u) < mem[_980]
                mem[_980 + (32 * uint8(u)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)
                if uint8(u + 1) != 6:
                    t = t + 1
                    u = u + 1
                    v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                    continue 
                _1093 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1093] = 0
                u = 0
                v = 0
                t = 0
                while uint8(t) < 5:
                    s = u
                    idx = t + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_980]
                        require uint8(t) < mem[_980]
                        if mem[(32 * uint8(t)) + _980 + 63 len 1] <= mem[(32 * uint8(idx)) + _980 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(t) < mem[_980]
                        _1544 = mem[(32 * uint8(t)) + _980 + 32]
                        require uint8(idx) < mem[_980]
                        require uint8(t) < mem[_980]
                        mem[_980 + (32 * uint8(t)) + 32] = mem[(32 * uint8(idx)) + _980 + 63 len 1]
                        require uint8(idx) < mem[_980]
                        mem[_980 + (32 * uint8(idx)) + 32] = uint8(_1544)
                        s = _1544
                        idx = idx + 1
                        continue 
                    u = s
                    v = idx
                    t = t + 1
                    continue 
                require mem[_980] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require bool(stor23) != 1
                require block.timestamp <= stor22 + stor1.length - stor2.length
                require block.timestamp >= stor22 + stor2.length
                _1425 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1425] = 0
                u = 0
                v = 0
                t = 0
                while uint8(t) < 5:
                    s = u
                    idx = t + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_980]
                        require uint8(t) < mem[_980]
                        if mem[(32 * uint8(t)) + _980 + 63 len 1] <= mem[(32 * uint8(idx)) + _980 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(t) < mem[_980]
                        _1844 = mem[(32 * uint8(t)) + _980 + 32]
                        require uint8(idx) < mem[_980]
                        require uint8(t) < mem[_980]
                        mem[_980 + (32 * uint8(t)) + 32] = mem[(32 * uint8(idx)) + _980 + 63 len 1]
                        require uint8(idx) < mem[_980]
                        mem[_980 + (32 * uint8(idx)) + 32] = uint8(_1844)
                        s = _1844
                        idx = idx + 1
                        continue 
                    u = s
                    v = idx
                    t = t + 1
                    continue 
                s = 0
                idx = 0
                s = 0
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_980]
                    require mem[(32 * uint8(idx)) + _980 + 63 len 1] >= 1
                    require mem[(32 * uint8(idx)) + _980 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(idx)) + _980 + 63 len 1] > uint8(s)
                    s = mem[(32 * uint8(idx)) + _980 + 32]
                    idx = idx + 1
                    s = mem[(32 * uint8(idx)) + _980 + 32]
                    continue 
                stor4.length++
                if not stor4.length <= stor4.length + 1:
                    mem[0] = 4
                    idx = sha3(mem[0]) + (5 * stor4.length) + 5
                    while sha3(4) + (5 * stor4.length) > idx:
                        address(stor[idx]) = 0
                        stor1[idx] = 0
                        mem[0] = idx + 1
                        s = sha3(s + 1)
                        while sha3(s + 1) + (stor1[s] + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        stor2[s] = 0
                        stor3[s] = 0
                        uint256(stor4[s].field_0) = 0
                        s = s + 5
                        continue 
                stor15++
                require stor15 < stor4.length
                mem[0] = 4
                uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
                uint256(stor4[stor15].field_256) = 6
                if not uint256(stor4[stor15].field_256) <= 6:
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    idx = sha3((5 * stor15) + sha3(4) + 1) + 1
                    while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > idx:
                        uint256(stor[idx]) = 0
                        idx = idx + 1
                        continue 
                idx = 0
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_980]
                    require uint8(idx) < uint256(stor4[stor15].field_256)
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    uint256(stor[(uint8(idx) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(idx)) + _980 + 32] * 256^(idx % 32) or !(255 * 256^(idx % 32)) and uint256(stor[(uint8(idx) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                    idx = idx + 1
                    continue 
                stor16 += uint256(stor4[stor15].field_512)
                u = _980
                v = v + 1
                continue 
            _1032 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1032] = 0
            u = 0
            w = 0
            v = 0
            while uint8(v) < 5:
                s = u
                idx = v + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_980]
                    require uint8(v) < mem[_980]
                    if mem[(32 * uint8(v)) + _980 + 63 len 1] <= mem[(32 * uint8(idx)) + _980 + 63 len 1]:
                        s = s
                        idx = idx + 1
                        continue 
                    require uint8(v) < mem[_980]
                    _1371 = mem[(32 * uint8(v)) + _980 + 32]
                    require uint8(idx) < mem[_980]
                    require uint8(v) < mem[_980]
                    mem[_980 + (32 * uint8(v)) + 32] = mem[(32 * uint8(idx)) + _980 + 63 len 1]
                    require uint8(idx) < mem[_980]
                    mem[_980 + (32 * uint8(idx)) + 32] = uint8(_1371)
                    s = _1371
                    idx = idx + 1
                    continue 
                u = s
                w = idx
                v = v + 1
                continue 
            require mem[_980] == 6
            require maxNumber == maxNumber
            require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
            require bool(stor23) != 1
            require block.timestamp <= stor22 + stor1.length - stor2.length
            require block.timestamp >= stor22 + stor2.length
            _1257 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1257] = 0
            u = 0
            v = 0
            t = 0
            while uint8(t) < 5:
                w = u
                v = t + 1
                while uint8(v) < 6:
                    require uint8(v) < mem[_980]
                    require uint8(t) < mem[_980]
                    if mem[(32 * uint8(t)) + _980 + 63 len 1] <= mem[(32 * uint8(v)) + _980 + 63 len 1]:
                        w = w
                        v = v + 1
                        continue 
                    require uint8(t) < mem[_980]
                    _1666 = mem[(32 * uint8(t)) + _980 + 32]
                    require uint8(v) < mem[_980]
                    require uint8(t) < mem[_980]
                    mem[_980 + (32 * uint8(t)) + 32] = mem[(32 * uint8(v)) + _980 + 63 len 1]
                    require uint8(v) < mem[_980]
                    mem[_980 + (32 * uint8(v)) + 32] = uint8(_1666)
                    w = _1666
                    v = v + 1
                    continue 
                u = w
                v = v
                t = t + 1
                continue 
            u = 0
            t = 0
            u = 0
            while uint8(t) < 6:
                require uint8(t) < mem[_980]
                require mem[(32 * uint8(t)) + _980 + 63 len 1] >= 1
                require mem[(32 * uint8(t)) + _980 + 63 len 1] <= maxNumber
                require mem[(32 * uint8(t)) + _980 + 63 len 1] > uint8(u)
                u = mem[(32 * uint8(t)) + _980 + 32]
                t = t + 1
                u = mem[(32 * uint8(t)) + _980 + 32]
                continue 
            stor4.length++
            if not stor4.length > stor4.length + 1:
                stor15++
                require stor15 < stor4.length
                mem[0] = 4
                uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
                uint256(stor4[stor15].field_256) = 6
                if not uint256(stor4[stor15].field_256) <= 6:
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    s = sha3((5 * stor15) + sha3(4) + 1) + 1
                    while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                s = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_980]
                    require uint8(s) < uint256(stor4[stor15].field_256)
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _980 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                    s = s + 1
                    continue 
                stor16 += uint256(stor4[stor15].field_512)
                s = _980
                idx = idx + 1
                continue 
            mem[0] = 4
            t = sha3(mem[0]) + (5 * stor4.length) + 5
            while sha3(4) + (5 * stor4.length) > t:
                address(stor[t]) = 0
                stor1[t] = 0
                mem[0] = t + 1
                s = sha3(s + 1)
                while sha3(s + 1) + (stor1[s] + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
                stor2[s] = 0
                stor3[s] = 0
                uint256(stor4[s].field_0) = 0
                s = s + 5
                continue 
        stor15++
        require stor15 < stor4.length
        mem[0] = 4
        uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
        uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
        uint256(stor4[stor15].field_256) = 6
        if not uint256(stor4[stor15].field_256) <= 6:
            mem[0] = (5 * stor15) + sha3(4) + 1
            s = sha3((5 * stor15) + sha3(4) + 1) + 1
            while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
        s = 0
        while uint8(s) < 6:
            require uint8(s) < mem[_980]
            require uint8(s) < uint256(stor4[stor15].field_256)
            mem[0] = (5 * stor15) + sha3(4) + 1
            uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _980 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
            s = s + 1
            continue 
        stor16 += uint256(stor4[stor15].field_512)
        t = _980
        idx = idx + 1
        continue 
    stor14 += msg.value
    stor13 += 85 * msg.value / 100
    stor17 += 5 * msg.value / 100
    stor18 += 10 * msg.value / 100
    if address(stor5[address(msg.sender)]) != 0:
        require sub_6a52dfdb[address(stor5[address(msg.sender)])] < stor7.length
        stor9BA6[stor6[address(stor5[address(msg.sender)])]] += 5 * msg.value / 100
}



}
