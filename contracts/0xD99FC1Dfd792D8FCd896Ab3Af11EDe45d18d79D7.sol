contract main {


// =======================  Init code  ======================


uint8 stor0; offset 160
uint256 stor0;
uint256 stor1;
uint256 stor2;
uint256 stor3;
array of struct stor5;
uint256 stor6;
uint256 stor7;
uint256 stor10;
uint256 stor11;
uint256 stor175B;
uint8 stor175B;
uint256 stor175B;
uint256 stor175B;
uint8 stor175B;

function _fallback() payable {
    uint8(stor0.field_160) = 16
    stor1 = 900
    stor2 = 120
    stor3 = 10^16
    stor6 = 50
    stor7 = 2 * 10^16
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    stor5.length = 1
    if not stor5.length <= 1:
        idx = 2
        while 2 * stor5.length > idx:
            address(stor5[idx].field_0) = 0
            uint256(stor5[idx].field_256) = 0
            idx = idx + 2
            continue 
    stor11 = 1
    if not stor11 <= 1:
        mem[0] = 11
        idx = 15
        while sha3(11) + (15 * stor11) > idx + sha3(mem[0]):
            uint256(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            uint256(stor[idx + sha3(mem[0]) + 3]) = 0
            uint256(stor[idx + sha3(mem[0]) + 4]) = 0
            uint256(stor[idx + sha3(mem[0]) + 5]) = 0
            uint256(stor[idx + sha3(mem[0]) + 6]) = 0
            uint256(stor[idx + sha3(mem[0]) + 7]) = 0
            uint256(stor[idx + sha3(mem[0]) + 8]) = 0
            mem[0] = idx + sha3(mem[0]) + 8
            s = sha3(idx + sha3(mem[0]) + 8)
            while sha3(idx + sha3(mem[0]) + 8) + (uint256(stor[idx + sha3(mem[0]) + 8]) + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
            uint256(stor[idx + sha3(mem[0]) + 9]) = 0
            if 31 < stor[idx + sha3(mem[0]) + 9].length:
                mem[0] = idx + sha3(mem[0]) + 9
                s = sha3(idx + sha3(mem[0]) + 9)
                while sha3(idx + sha3(mem[0]) + 9) + (stor[idx + sha3(mem[0]) + 9].length + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
            uint8(stor[idx + sha3(mem[0]) + 10]) = 0
            uint256(stor[idx + sha3(mem[0]) + 11]) = 0
            uint256(stor[idx + sha3(mem[0]) + 12]) = 0
            uint256(stor[idx + sha3(mem[0]) + 13]) = 0
            uint8(stor[idx + sha3(mem[0]) + 14]) = 0
            idx = idx + 15
            continue 
    stor10 = 0
    require 0 < stor11
    stor175B = block.timestamp
    stor175B = 0
    stor175B = 0
    stor175B = stor3
    stor175B = uint8(stor0.field_160)
    return code.data[754 len 13216]
}



// =====================  Runtime code  =====================


#
#  - sub_43ea3faa(?)
#
const N = 6


uint8 maxNumber; offset 160
uint128 stor0; offset 160
address stor0;
uint256 stor0;
uint256 sub_ae466313;
uint256 sub_27ecc221;
uint256 ticketPrice;
mapping of uint256 sub_6a52dfdb;
array of struct stor5;
uint256 sub_fa06c38a;
uint256 sub_d7a58a87;
array of uint256 description;
uint256 numTickets;
uint256 gameID;
uint256 stor11;
array of struct sub_3963ef83;
uint256 numPlayers;
mapping of struct players;
array of struct sub_44d855f1;
array of uint256 stor660301456019777184113296434797620819555017468543624515662331739614079884730;
array of uint256 stor660301456019777184113296434797620819555017468543624515662331739614079884732;
array of uint256 stor660301456019777184113296434797620819555017468543624515662331739614079884733;
array of uint256 stor660301456019777184113296434797620819555017468543624515662331739614079884734;
array of uint256 stor660301456019777184113296434797620819555017468543624515662331739614079884736;
array of struct stor660301456019777184113296434797620819555017468543624515662331739614079884739;
array of uint256 stor660301456019777184113296434797620819555017468543624515662331739614079884740;
array of uint256 stor660301456019777184113296434797620819555017468543624515662331739614079884742;
array of uint8 stor38901484280723486654731320340554522250784272260600125515269588111016184487965;
array of uint256 stor79609640653217461608330494757671364855449501244614386310391394988798144127005;
array of uint256 stor80065415910302374404002858606536494160112422142973424089479232975324052765501;
array of uint256 stor83680456290466859103690412199383049115916024143015812389903575676576340090909;
array of uint256 stor86394333381966457433930357160524171956227039408616763109578362801761804066845;
array of uint256 stor90016298579134234948215990130720611241252811450176910061620119101004087343933;

function ticketPrice() payable {
    return ticketPrice
}

function sub_27ecc221(?) payable {
    return sub_27ecc221
}

function numTickets() payable {
    return numTickets
}

function sub_3963ef83(?) payable {
    require arg2 < sub_3963ef83[arg1].field_0
    mem[512] = stor[sha3((13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 12)) + 6)].field_0
    idx = 512
    s = 0
    while stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 12)) + 6].length + 512 > idx + 32:
        mem[idx + 32] = stor[s + sha3((13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 12)) + 6)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return sub_3963ef83[arg1][arg2].field_0, 
           sub_3963ef83[arg1][arg2].field_256,
           sub_3963ef83[arg1][arg2].field_512,
           address(sub_3963ef83[arg1][arg2].field_768),
           sub_3963ef83[arg1][arg2].field_1024,
           Array(len=stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 12)) + 6].length, data=mem[512 len stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 12)) + 6].length + (floor32(stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 12)) + 6].length - 1) + -stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 12)) + 6].length + 32 % 32)]),
           sub_3963ef83[arg1][arg2].field_1792,
           uint8(sub_3963ef83[arg1][arg2].field_2048),
           sub_3963ef83[arg1][arg2].field_2304,
           bool(uint8(sub_3963ef83[arg1][arg2].field_2560)),
           sub_3963ef83[arg1][arg2].field_2816,
           sub_3963ef83[arg1][arg2].field_3072
}

function maxNumber() payable {
    return maxNumber
}

function sub_44d855f1(?) payable {
    require arg2 < sub_44d855f1[arg1].field_0
    mem[512] = stor[sha3((13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 15)) + 6)].field_0
    idx = 512
    s = 0
    while stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 15)) + 6].length + 512 > idx + 32:
        mem[idx + 32] = stor[s + sha3((13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 15)) + 6)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return sub_44d855f1[arg1][arg2].field_0, 
           sub_44d855f1[arg1][arg2].field_256,
           sub_44d855f1[arg1][arg2].field_512,
           address(sub_44d855f1[arg1][arg2].field_768),
           sub_44d855f1[arg1][arg2].field_1024,
           Array(len=stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 15)) + 6].length, data=mem[512 len stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 15)) + 6].length + (floor32(stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 15)) + 6].length - 1) + -stor[(13 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 15)) + 6].length + 32 % 32)]),
           sub_44d855f1[arg1][arg2].field_1792,
           uint8(sub_44d855f1[arg1][arg2].field_2048),
           sub_44d855f1[arg1][arg2].field_2304,
           bool(uint8(sub_44d855f1[arg1][arg2].field_2560)),
           sub_44d855f1[arg1][arg2].field_2816,
           sub_44d855f1[arg1][arg2].field_3072
}

function sub_6a52dfdb(?) payable {
    return sub_6a52dfdb[arg1]
}

function description() payable {
    return description[0 len description.length]
}

function numPlayers() payable {
    return numPlayers
}

function sub_ae466313(?) payable {
    return sub_ae466313
}

function gameID() payable {
    return gameID
}

function sub_d7a58a87(?) payable {
    return sub_d7a58a87
}

function players(address arg1) payable {
    return players[arg1].field_0, 
           address(players[arg1].field_256),
           players[arg1].field_512,
           players[arg1].field_768,
           players[arg1].field_1024,
           players[arg1].field_1280
}

function sub_fa06c38a(?) payable {
    return sub_fa06c38a
}

function kill() payable {
    require msg.sender == address(stor0.field_0)
    selfdestruct(address(stor0.field_0))
}

function _fallback() payable {
    require gameID < stor11
    storB901[stor10] += msg.value
}

function sub_0db35d8c(?) payable {
    require msg.sender == address(stor0.field_0)
    sub_fa06c38a = arg2
    sub_d7a58a87 = 10^18 * arg1
}

function sub_766fc3ef(?) payable {
    require msg.sender == address(stor0.field_0)
    description[] = Array(len=arg1.length, data=arg1[all])
}

function transferOwnership(address arg1) payable {
    require address(stor0.field_0) == msg.sender
    uint256(stor0.field_0) = arg1 or Mask(96, 160, uint256(stor0.field_0))
}

function sub_80322dd5(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 >= 10^15
    ticketPrice = arg1
    require gameID < stor11
    stor175B[stor10] = arg1
}

function sub_236af88c(?) payable {
    require not players[address(msg.sender)].field_512
    require sub_6a52dfdb[address(arg1)]
    players[address(msg.sender)].field_512 = sub_6a52dfdb[address(arg1)]
}

function sub_b28c7c25(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 > 6
    Mask(96, 0, stor0.field_160) = Mask(96, 0, arg1)
    require gameID < stor11
    uint8(stor175B[stor10].field_0) = arg1
    stor175B[stor10].field_256 % 1 = 0
}

function sub_d2a8bcf5(?) payable {
    require sub_fa06c38a > 0
    require msg.value >= sub_d7a58a87
    stor5.length++
    if not stor5.length <= stor5.length + 1:
        idx = 2 * stor5.length + 1
        while 2 * stor5.length > idx:
            address(stor5[idx].field_0) = 0
            stor5[idx].field_256 = 0
            idx = idx + 2
            continue 
    require stor5.length - 1 < stor5.length
    storB103[stor5.length - 1] = msg.sender or Mask(96, 160, storB103[stor5.length - 1])
    sub_6a52dfdb[address(msg.sender)] = stor5.length - 1
    sub_fa06c38a--
    call address(stor0.field_0) with:
       value msg.value wei
         gas 0 wei
    if not ext_call.success:
        require gameID < stor11
        storB901[stor10] += msg.value
}

function games(uint256 arg1) payable {
    require arg1 < stor11
    mem[576] = stor[sha3((15 * arg1) + 0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01dc2)]
    idx = 576
    s = 0
    while stor[(15 * arg1) + 0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01dc2].length + 576 > idx + 32:
        mem[idx + 32] = stor[s + sha3((15 * arg1) + 0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01dc2) + 1]
        idx = idx + 32
        s = s + 1
        continue 
    return storBF01[arg1], 
           stor175B[arg1],
           storB901[arg1],
           stor175B[arg1],
           stor175B[arg1],
           stor175B[arg1],
           storB001[arg1],
           stor175B[arg1],
           Array(len=stor[(15 * arg1) + 0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01dc2].length, data=mem[576 len stor[(15 * arg1) + 0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01dc2].length + (floor32(stor[(15 * arg1) + 0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01dc2].length - 1) + -stor[(15 * arg1) + 0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01dc2].length + 32 % 32)]),
           uint8(stor175B[arg1].field_0),
           stor175B[arg1],
           stor[(15 * arg1) + code.data[13184 len 32]],
           stor175B[arg1],
           bool(stor5601[arg1])
}

function draw() payable {
    mem[96] = 0
    require gameID < stor11
    require block.timestamp >= stor[code.data[13184 len 32] + (15 * stor10)] + sub_ae466313
    require gameID < stor11
    require bool(stor5601[stor10]) != 1
    require gameID < stor11
    mem[0] = 11
    stor5601[stor10] = 1
    stor175B[stor10] = block.timestamp
    mem[128] = 0
    mem[160] = 0
    mem[192] = 6
    mem[416] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 448
    mem[(32 * uint8(maxNumber + 1)) + 448] = block.difficulty
    mem[(32 * uint8(maxNumber + 1)) + 480] = address(block.coinbase)
    mem[(32 * uint8(maxNumber + 1)) + 500] = numTickets
    mem[(32 * uint8(maxNumber + 1)) + 532] = block.timestamp
    mem[(32 * uint8(maxNumber + 1)) + 564] = address(msg.sender)
    mem[(32 * uint8(maxNumber + 1)) + 584] = var18001
    if uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var18001) % uint8(maxNumber + 1)) != 0:
        require uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var18001) % uint8(maxNumber + 1)) < uint8(maxNumber + 1)
        if mem[(32 * uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var18001) % uint8(maxNumber + 1))) + 479 len 1] != 1:
            require uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var18001) % uint8(maxNumber + 1)) < uint8(maxNumber + 1)
            mem[(32 * uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var18001) % uint8(maxNumber + 1))) + 448] = 1
            mem[224] = uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var18001) % uint8(maxNumber + 1))
    var18001 = var18001 + 1
    var18004 = sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var18001) % uint8(maxNumber + 1)
    continue 
}

function sub_ef2d1714(?) payable {
    mem[96] = 0
    require msg.value >= arg1 * ticketPrice
    if 0 >= arg1:
        require gameID < stor11
        stor175B[stor10] += msg.value
        storB901[stor10] += 85 * msg.value / 100
        storB001[stor10] += 5 * msg.value / 100
        if 0 == players[address(msg.sender)].field_512:
            require gameID < stor11
            storB901[stor10] += 10 * msg.value / 100
        else:
            require players[address(msg.sender)].field_512 < stor5.length
            storC703[stor14[address(msg.sender)].field_512] += 10 * msg.value / 100
            require gameID < stor11
            stor175B[stor10] += 10 * msg.value / 100
    mem[128] = 0
    mem[160] = 0
    mem[192] = 6
    mem[416] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 448
    mem[(32 * uint8(maxNumber + 1)) + 448] = block.difficulty
    mem[(32 * uint8(maxNumber + 1)) + 480] = address(block.coinbase)
    mem[(32 * uint8(maxNumber + 1)) + 500] = numTickets
    mem[(32 * uint8(maxNumber + 1)) + 532] = block.timestamp
    mem[(32 * uint8(maxNumber + 1)) + 564] = address(msg.sender)
    mem[(32 * uint8(maxNumber + 1)) + 584] = var15001
    if uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1)) != 0:
        require uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1)) < uint8(maxNumber + 1)
        if mem[(32 * uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1))) + 479 len 1] != 1:
            require uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1)) < uint8(maxNumber + 1)
            mem[(32 * uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1))) + 448] = 1
            mem[224] = uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1))
    var15001 = var15001 + 1
    var15004 = sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1)
    continue 
}



}
