contract main {


// =======================  Init code  ======================


array of uint256 stor0;
array of uint256 stor1;
uint256 stor2;

function _fallback() payable {
    mem[96 len -404] = code.data[719 len -404]
    mem[64] = -308
    stor0[] = Array(len=mem[mem[96] + 96], data=mem[mem[96] + 128 len mem[mem[96] + 96]])
    stor2 = mem[128]
    stor1.length++
    if not stor1.length <= stor1.length + 1:
        idx = stor1.length - 0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f309
        while stor1.length - 0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a > idx:
            stor[idx] = 0
            idx = idx + 1
            continue 
    stor1[stor1.length] = msg.sender or Mask(96, 160, stor1[stor1.length])
    return code.data[315 len 404]
}



// =====================  Runtime code  =====================


array of uint256 name;
array of address sub_efa8154e;
uint256 industry;

function name() payable {
    return name[0 len name.length]
}

function industry() payable {
    return industry
}

function sub_efa8154e(?) payable {
    require arg1 < sub_efa8154e.length
    return sub_efa8154e[arg1]
}

function _fallback() payable {
  stop
}



}
