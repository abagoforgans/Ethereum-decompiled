contract main {


// =======================  Init code  ======================


uint256 stor0;

function _fallback() payable {
    stor0 = block.number
    return code.data[23 len 963]
}



// =====================  Runtime code  =====================


uint256 stor0;
uint256 stor1;
array of address stor2;
array of uint256 stor3;
mapping of uint256 stor4;
mapping of uint256 stor5;

function _fallback() payable {
  stop
}

function payoutReady() payable {
    if block.number % 88 <= 68:
        return (block.number % 88 > 68)
    return (block.number - stor0 > 68)
}

function sub_5e0572a7(?) payable {
    if block.number % 88 >= 68:
    if block.number % 88 <= 48:
    require sha3(arg1) != stor4[address(msg.sender)]
}

function buyTicket(bytes32 arg1) payable {
    if block.number % 88 < 40:
        stor4[address(msg.sender)] = arg1
        stor5[address(msg.sender)] += msg.value
        stor1 += msg.value
}

function random() payable {
    idx = 0
    s = 0
    while idx < stor3.length:
        mem[0] = 3
        idx = idx + 1
        s = s xor stor('array', ('div', 0.25, ('var', 0)), ('name', 'stor3', 3))[uint8(idx)]
        continue 
    return uint16(uint64(s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length) % stor2.length)
}

function payout() payable {
    if block.number % 88 <= 68:
        return 0
    if block.number - stor0 <= 68:
        return 0
    idx = 0
    s = 0
    while idx < stor3.length:
        mem[0] = 3
        idx = idx + 1
        s = s xor stor('array', ('div', 0.25, ('var', 0)), ('name', 'stor3', 3))[uint8(idx)]
        continue 
    require uint16(uint64(s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length) % stor2.length) < stor2.length
    call stor2[uint16(uint64(s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length) % stor2.length)] with:
       value stor1 - (25000 * block.gasprice) wei
         gas 0 wei
    stor0 = block.number
    stor2.length = 0
    idx = 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace
    while stor2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace > idx:
        stor[idx] = 0
        idx = idx + 1
        continue 
    stor3.length = 0
    idx = 0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
    while (stor3.length + 3 / 4) - 0x3da8a5f161a6c3ff06a60736d0ed24d7963cc6a5c4fafd2fa1dae9bb908e07a5 > idx:
        stor[idx] = 0
        idx = idx + 1
        continue 
    stor1 = 0
    idx = 0
    while idx < stor2.length:
        stor4[stor2[idx]] = 0
        mem[0] = stor2[idx]
        mem[32] = 5
        stor5[stor2[idx]] = 0
        idx = idx + 1
        continue 
    return stor2[uint16(uint64(s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length) % stor2.length)]
}



}
