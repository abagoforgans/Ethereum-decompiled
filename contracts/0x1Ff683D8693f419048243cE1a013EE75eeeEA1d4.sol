contract main {


// =======================  Init code  ======================


uint8 stor0; offset 160
uint256 stor0;
array of uint256 stor1;
array of uint256 stor2;
array of uint8 stor3;
array of uint256 stor4;
array of uint256 stor5;
array of struct stor6;
uint256 stor7;
uint256 stor8;
array of uint256 stor9;
uint256 stor10;
uint256 stor6E15;
uint8 stor6E15;

function _fallback() payable {
    uint8(stor0.field_160) = 16
    stor1.length = 900
    stor2.length = 120
    stor3.length = 10^16
    stor7 = 50
    stor8 = 2 * 10^16
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    stor6.length = 1
    if not stor6.length <= 1:
        idx = 2
        while 2 * stor6.length > idx:
            address(stor6[idx].field_0) = 0
            uint256(stor6[idx].field_256) = 0
            idx = idx + 2
            continue 
    stor9.length = 1
    if not stor9.length <= 1:
        mem[0] = 9
        idx = 14
        while sha3(9) + (14 * stor9.length) > idx + sha3(mem[0]):
            uint256(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            uint256(stor[idx + sha3(mem[0]) + 3]) = 0
            uint256(stor[idx + sha3(mem[0]) + 4]) = 0
            uint256(stor[idx + sha3(mem[0]) + 5]) = 0
            uint256(stor[idx + sha3(mem[0]) + 6]) = 0
            uint256(stor[idx + sha3(mem[0]) + 7]) = 0
            uint256(stor[idx + sha3(mem[0]) + 8]) = 0
            s = sha3(idx + sha3(mem[0]) + 8)
            while sha3(idx + sha3(mem[0]) + 8) + (uint256(stor[idx + sha3(mem[0]) + 8]) + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
            uint8(stor[idx + sha3(mem[0]) + 9]) = 0
            uint256(stor[idx + sha3(mem[0]) + 10]) = 0
            uint256(stor[idx + sha3(mem[0]) + 11]) = 0
            uint8(stor[idx + sha3(mem[0]) + 12]) = 0
            uint256(stor[idx + sha3(mem[0]) + 13]) = 0
            mem[0] = idx + sha3(mem[0]) + 13
            s = sha3(mem[0])
            while sha3(idx + sha3(mem[0]) + 13) + (6 * uint256(stor[idx + sha3(mem[0]) + 13])) > s:
                address(stor[s]) = 0
                stor1[s] = 0
                mem[0] = s + 1
                t = sha3(t + 1)
                while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
                stor2[t] = 0
                stor3[t] = 0
                stor4[t] = 0
                stor5[t] = 0
                t = t + 6
                continue 
            idx = idx + 14
            continue 
    stor10 = 0
    require 0 < stor9.length
    stor6E15 = block.timestamp
    stor6E15 = 0
    stor9 = 0
    return code.data[700 len 9324]
}



// =====================  Runtime code  =====================


#
#  - draw()
#
const N = 6


uint8 maxNumber; offset 160
uint128 stor0; offset 160
address stor0;
uint256 stor0;
array of uint256 stor1;
array of uint256 stor2;
array of uint8 stor3;
mapping of address stor4;
array of uint256 sub_6a52dfdb;
array of struct stor6;
uint256 sub_fa06c38a;
uint256 sub_d7a58a87;
uint256 stor9;
uint256 gameID;
array of uint256 description;
array of uint8 stor28690209302414737535705887447216511099470000590569108171409879509876465432007;
array of uint256 stor29142522150998003924079211607406698239521836468169266624689010697407376094663;
array of uint256 stor39093404819829864468292343131590815320662225775372752596829896823087410673095;
array of uint256 stor49791959467252497455735130940088646708311117250336157395101362029847983278000;
array of uint256 stor49791959467252497455735130940088646708311117250336157395101362029847983278002;
array of uint256 stor49791959467252497455735130940088646708311117250336157395101362029847983278003;
array of uint256 stor49791959467252497455735130940088646708311117250336157395101362029847983278004;
array of uint256 stor49791959467252497455735130940088646708311117250336157395101362029847983278006;
array of struct stor49791959467252497455735130940088646708311117250336157395101362029847983278008;
array of uint256 stor49791959467252497455735130940088646708311117250336157395101362029847983278009;
array of uint256 stor79589959743539834373573931410743583868296197227158937230892893998180357078029;
array of uint256 stor80253874040907105810264841708897845065379290636987171845230834888400280974791;
array of uint256 stor84324689678156503305624759150609529325845813535388597924743015576178476938695;
array of uint256 stor84324689678156503305624759150609529325845813535388597924743015576178476938699;
array of uint256 stor84324689678156503305624759150609529325845813535388597924743015576178476938700;
array of uint8 stor84324689678156503305624759150609529325845813535388597924743015576178476938707;
array of uint256 stor84324689678156503305624759150609529325845813535388597924743015576178476938708;
array of uint256 stor85470026775122297422427145493216016688970063635960997123521599436082195692557;

function ticketPrice() payable {
    return stor3.length
}

function sub_27ecc221(?) payable {
    return stor2.length
}

function maxNumber() payable {
    return maxNumber
}

function sub_6a52dfdb(?) payable {
    return sub_6a52dfdb[arg1]
}

function description() payable {
    return description[0 len description.length]
}

function sub_ae466313(?) payable {
    return stor1.length
}

function gameID() payable {
    return gameID
}

function sub_d7a58a87(?) payable {
    return sub_d7a58a87
}

function sub_fa06c38a(?) payable {
    return sub_fa06c38a
}

function kill() payable {
    require msg.sender == address(stor0.field_0)
    selfdestruct(address(stor0.field_0))
}

function _fallback() payable {
    require gameID < stor9
    stor406E[stor10] += msg.value
}

function sub_0db35d8c(?) payable {
    require msg.sender == address(stor0.field_0)
    sub_fa06c38a = arg2
    sub_d7a58a87 = 10^18 * arg1
}

function sub_766fc3ef(?) payable {
    require msg.sender == address(stor0.field_0)
    description[] = Array(len=arg1.length, data=arg1[all])
}

function transferOwnership(address arg1) payable {
    require address(stor0.field_0) == msg.sender
    uint256(stor0.field_0) = arg1 or Mask(96, 160, uint256(stor0.field_0))
}

function sub_80322dd5(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 >= 10^15
    stor3.length = arg1
    require gameID < stor9
    stor6E15[stor10] = arg1
}

function sub_236af88c(?) payable {
    require not address(stor4[address(msg.sender)])
    require sub_6a52dfdb[address(arg1)]
    uint256(stor4[address(msg.sender)]) = arg1 or Mask(96, 160, uint256(stor4[address(msg.sender)]))
}

function sub_b28c7c25(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 > 6
    Mask(96, 0, stor0.field_160) = Mask(96, 0, arg1)
    require gameID < stor9
    uint8(stor6E15[stor10].field_0) = arg1
    stor6E15[stor10].field_256 % 1 = 0
}

function games(uint256 arg1) payable {
    require arg1 < stor9
    return storBA6E[arg1], 
           stor6E15[arg1],
           stor406E[arg1],
           stor6E15[arg1],
           stor6E15[arg1],
           stor6E15[arg1],
           uint256(stor[(14 * arg1) + code.data[9292 len 32]]),
           stor6E15[arg1],
           uint8(stor6E15[arg1].field_0),
           stor6E15[arg1],
           storB16E[arg1],
           bool(stor3F6E[arg1])
}

function sub_d2a8bcf5(?) payable {
    require sub_fa06c38a > 0
    require msg.value >= sub_d7a58a87
    stor6.length++
    if not stor6.length <= stor6.length + 1:
        idx = 2 * stor6.length + 1
        while 2 * stor6.length > idx:
            address(stor6[idx].field_0) = 0
            uint256(stor6[idx].field_256) = 0
            idx = idx + 2
            continue 
    require stor6.length - 1 < stor6.length
    storAFF6[stor6.length - 1] = msg.sender or Mask(96, 160, storAFF6[stor6.length - 1])
    sub_6a52dfdb[address(msg.sender)] = stor6.length - 1
    sub_fa06c38a--
    call address(stor0.field_0) with:
       value msg.value wei
         gas 0 wei
    if not ext_call.success:
        require gameID < stor9
        stor406E[stor10] += msg.value
}

function sub_79747295(?) payable {
    mem[96] = 0
    mem[128] = 0
    mem[160] = 6
    mem[384] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 416
    idx = 0
    s = 0
    t = 0
    while idx < 123456789:
        mem[mem[64]] = block.difficulty
        mem[mem[64] + 32] = address(block.coinbase)
        mem[mem[64] + 52] = block.timestamp
        mem[mem[64] + 84] = address(msg.sender)
        mem[mem[64] + 104] = idx
        if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber):
            idx = idx + 1
            s = s
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber) < mem[384]
        if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)) + 447 len 1]:
            idx = idx + 1
            s = s
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber) < mem[384]
        mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)) + 416] = 1
        require uint8(s) < mem[160]
        mem[(32 * uint8(s)) + 192] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber)
        if uint8(s + 1) != 6:
            idx = idx + 1
            s = s + 1
            t = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, idx) % maxNumber
            continue 
        _115 = mem[64]
        mem[64] = mem[64] + 32
        mem[_115] = 0
        s = 0
        t = 0
        idx = 0
        while uint8(idx) < 5:
            u = s
            t = idx + 1
            while uint8(t) < 6:
                require uint8(t) < mem[160]
                require uint8(idx) < mem[160]
                if mem[(32 * uint8(idx)) + 223 len 1] <= mem[(32 * uint8(t)) + 223 len 1]:
                    u = u
                    t = t + 1
                    continue 
                require uint8(idx) < mem[160]
                _410 = mem[(32 * uint8(idx)) + 192]
                require uint8(t) < mem[160]
                require uint8(idx) < mem[160]
                mem[(32 * uint8(idx)) + 192] = mem[(32 * uint8(t)) + 223 len 1]
                require uint8(t) < mem[160]
                mem[(32 * uint8(t)) + 192] = uint8(_410)
                u = _410
                t = t + 1
                continue 
            s = u
            t = t
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[160]
        _317 = mem[160]
        mem[mem[64] + 64 len 32 * mem[160]] = mem[192 len 32 * mem[160]]
        return 32, mem[mem[64] + 32 len (32 * _317) + 32]
    _54 = mem[64]
    mem[64] = mem[64] + 32
    mem[_54] = 0
    s = 0
    u = 0
    t = 0
    while uint8(t) < 5:
        u = s
        idx = t + 1
        while uint8(idx) < 6:
            require uint8(idx) < mem[160]
            require uint8(t) < mem[160]
            if mem[(32 * uint8(t)) + 223 len 1] <= mem[(32 * uint8(idx)) + 223 len 1]:
                u = u
                idx = idx + 1
                continue 
            require uint8(t) < mem[160]
            _344 = mem[(32 * uint8(t)) + 192]
            require uint8(idx) < mem[160]
            require uint8(t) < mem[160]
            mem[(32 * uint8(t)) + 192] = mem[(32 * uint8(idx)) + 223 len 1]
            require uint8(idx) < mem[160]
            mem[(32 * uint8(idx)) + 192] = uint8(_344)
            u = _344
            idx = idx + 1
            continue 
        s = u
        u = idx
        t = t + 1
        continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[160]
    _220 = mem[160]
    mem[mem[64] + 64 len 32 * mem[160]] = mem[192 len 32 * mem[160]]
    return 32, mem[mem[64] + 32 len (32 * _220) + 32]
}

function sub_43ea3faa(?) payable {
    mem[96] = arg1.length
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    require arg1.length == 6
    require maxNumber == maxNumber
    require msg.value >= stor3.length
    require gameID < stor9
    require bool(storBA6E[stor10]) != 1
    require gameID < stor9
    require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
    require gameID < stor9
    require block.timestamp >= storB16E[stor10] + stor2.length
    mem[(32 * arg1.length) + 128] = 0
    s = 0
    t = 0
    idx = 0
    while uint8(idx) < 5:
        u = s
        t = idx + 1
        while uint8(t) < 6:
            require uint8(t) < arg1.length
            require uint8(idx) < arg1.length
            if mem[(32 * uint8(idx)) + 159 len 1] <= mem[(32 * uint8(t)) + 159 len 1]:
                u = u
                t = t + 1
                continue 
            require uint8(idx) < arg1.length
            _57 = mem[(32 * uint8(idx)) + 128]
            require uint8(t) < arg1.length
            require uint8(idx) < arg1.length
            mem[(32 * uint8(idx)) + 128] = mem[(32 * uint8(t)) + 159 len 1]
            require uint8(t) < arg1.length
            mem[(32 * uint8(t)) + 128] = uint8(_57)
            u = _57
            t = t + 1
            continue 
        s = u
        t = t
        idx = idx + 1
        continue 
    s = 0
    idx = 0
    s = 0
    while uint8(idx) < 6:
        require uint8(idx) < arg1.length
        require mem[(32 * uint8(idx)) + 159 len 1] >= 1
        require mem[(32 * uint8(idx)) + 159 len 1] <= maxNumber
        require mem[(32 * uint8(idx)) + 159 len 1] > uint8(s)
        s = mem[(32 * uint8(idx)) + 128]
        idx = idx + 1
        s = mem[(32 * uint8(idx)) + 128]
        continue 
    require gameID < stor9
    storBA6E[stor10]++
    if not storBA6E[stor10] <= storBA6E[stor10] + 1:
        mem[0] = (14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c
        idx = (6 * storBA6E[stor10]) + 6
        while sha3((14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c) + (6 * storBA6E[stor10]) > idx + sha3(mem[0]):
            address(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            mem[0] = idx + sha3(mem[0]) + 1
            s = sha3(s + sha3(mem[0]) + 1)
            while sha3(s + sha3(mem[0]) + 1) + (uint256(stor[s + sha3(mem[0]) + 1]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint256(stor[s + sha3(mem[0]) + 2]) = 0
            uint8(stor[s + sha3(mem[0]) + 3]) = 0
            uint256(stor[s + sha3(mem[0]) + 4]) = 0
            uint256(stor[s + sha3(mem[0]) + 5]) = 0
            s = s + 6
            continue 
    require gameID < stor9
    storBA6E[stor10] = stor566E[stor10]
    require stor6E15[stor10] - 1 < stor566E[stor10]
    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / stor3.length
    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
    if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) <= 6:
        idx = 1
        while uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32 > idx:
            uint256(stor[idx + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = 0
            idx = idx + 1
            continue 
    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
    idx = 0
    while uint8(idx) < 6:
        require uint8(idx) < arg1.length
        require uint8(idx) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
        mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
        uint256(stor[(uint8(idx) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(idx)) + 128] * 256^(idx % 32) or !(255 * 256^(idx % 32)) and uint256(stor[(uint8(idx) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
        idx = idx + 1
        continue 
    require gameID < stor9
    storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
    stor6E15[stor10] += msg.value
    stor406E[stor10] += 85 * msg.value / 100
    uint256(stor[code.data[9292 len 32] + (14 * stor10)]) += 5 * msg.value / 100
    if 0 == address(stor4[address(msg.sender)]):
        require gameID < stor9
        stor406E[stor10] += 10 * msg.value / 100
    else:
        require sub_6a52dfdb[address(stor4[address(msg.sender)])] < stor6.length
        storBCF6[stor5[address(stor4[address(msg.sender)])]] += 10 * msg.value / 100
        require gameID < stor9
        stor6E15[stor10] += 10 * msg.value / 100
}

function sub_d7264f6c(?) payable {
    mem[64] = 128
    mem[96] = 0
    require msg.value >= arg1 * stor3.length
    s = 96
    idx = 0
    while idx < arg1:
        _1172 = mem[64]
        mem[64] = mem[64] + 32
        mem[_1172] = 0
        _1173 = mem[64]
        mem[64] = mem[64] + 32
        mem[_1173] = 0
        _1174 = mem[64]
        if msize < mem[64]:
            mem[mem[64]] = 6
            if msize < mem[64] + 224:
                mem[mem[64] + 224] = uint8(maxNumber + 1)
                mem[64] = mem[64] + (32 * uint8(maxNumber + 1)) + 256
                t = 0
                u = 0
                v = 0
                while t < 123456789:
                    mem[mem[64]] = block.difficulty
                    mem[mem[64] + 32] = address(block.coinbase)
                    mem[mem[64] + 52] = block.timestamp
                    mem[mem[64] + 84] = address(msg.sender)
                    mem[mem[64] + 104] = t
                    if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber):
                        t = t + 1
                        u = u
                        v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber) < mem[_1174 + 224]
                    if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)) + _1174 + 287 len 1]:
                        t = t + 1
                        u = u
                        v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber) < mem[_1174 + 224]
                    mem[_1174 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)) + 256] = 1
                    require uint8(u) < mem[_1174]
                    mem[_1174 + (32 * uint8(u)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)
                    if uint8(u + 1) != 6:
                        t = t + 1
                        u = u + 1
                        v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                        continue 
                    _1295 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1295] = 0
                    u = 0
                    v = 0
                    t = 0
                    while uint8(t) < 5:
                        s = u
                        idx = t + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_1174]
                            require uint8(t) < mem[_1174]
                            if mem[(32 * uint8(t)) + _1174 + 63 len 1] <= mem[(32 * uint8(idx)) + _1174 + 63 len 1]:
                                s = s
                                idx = idx + 1
                                continue 
                            require uint8(t) < mem[_1174]
                            _1782 = mem[(32 * uint8(t)) + _1174 + 32]
                            require uint8(idx) < mem[_1174]
                            require uint8(t) < mem[_1174]
                            mem[_1174 + (32 * uint8(t)) + 32] = mem[(32 * uint8(idx)) + _1174 + 63 len 1]
                            require uint8(idx) < mem[_1174]
                            mem[_1174 + (32 * uint8(idx)) + 32] = uint8(_1782)
                            s = _1782
                            idx = idx + 1
                            continue 
                        u = s
                        v = idx
                        t = t + 1
                        continue 
                    require mem[_1174] == 6
                    require maxNumber == maxNumber
                    require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                    require gameID < stor9
                    require bool(storBA6E[stor10]) != 1
                    require gameID < stor9
                    require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
                    require gameID < stor9
                    mem[0] = 9
                    require block.timestamp >= storB16E[stor10] + stor2.length
                    _1678 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1678] = 0
                    u = 0
                    v = 0
                    t = 0
                    while uint8(t) < 5:
                        w = u
                        v = t + 1
                        while uint8(v) < 6:
                            require uint8(v) < mem[_1174]
                            require uint8(t) < mem[_1174]
                            if mem[(32 * uint8(t)) + _1174 + 63 len 1] <= mem[(32 * uint8(v)) + _1174 + 63 len 1]:
                                w = w
                                v = v + 1
                                continue 
                            require uint8(t) < mem[_1174]
                            _2170 = mem[(32 * uint8(t)) + _1174 + 32]
                            require uint8(v) < mem[_1174]
                            require uint8(t) < mem[_1174]
                            mem[_1174 + (32 * uint8(t)) + 32] = mem[(32 * uint8(v)) + _1174 + 63 len 1]
                            require uint8(v) < mem[_1174]
                            mem[_1174 + (32 * uint8(v)) + 32] = uint8(_2170)
                            w = _2170
                            v = v + 1
                            continue 
                        u = w
                        v = v
                        t = t + 1
                        continue 
                    t = 0
                    s = 0
                    t = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1174]
                        require mem[(32 * uint8(s)) + _1174 + 63 len 1] >= 1
                        require mem[(32 * uint8(s)) + _1174 + 63 len 1] <= maxNumber
                        require mem[(32 * uint8(s)) + _1174 + 63 len 1] > uint8(t)
                        t = mem[(32 * uint8(s)) + _1174 + 32]
                        s = s + 1
                        t = mem[(32 * uint8(s)) + _1174 + 32]
                        continue 
                    require gameID < stor9
                    storBA6E[stor10]++
                    if not storBA6E[stor10] <= storBA6E[stor10] + 1:
                        mem[0] = (14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c
                        s = sha3(mem[0]) + (6 * storBA6E[stor10]) + 6
                        while sha3((14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c) + (6 * storBA6E[stor10]) > s:
                            address(stor[s]) = 0
                            stor1[s] = 0
                            mem[0] = s + 1
                            t = sha3(t + 1)
                            while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                                uint256(stor[t]) = 0
                                t = t + 1
                                continue 
                            stor2[t] = 0
                            stor3[t] = 0
                            uint256(stor4[t]) = 0
                            sub_6a52dfdb[t] = 0
                            t = t + 6
                            continue 
                    require gameID < stor9
                    storBA6E[stor10] = stor566E[stor10]
                    require stor6E15[stor10] - 1 < stor566E[stor10]
                    mem[0] = (14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
                    if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) <= 6:
                        mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                        s = sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + 1
                        while sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + (uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1174]
                        require uint8(s) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
                        mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                        uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(s)) + _1174 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
                        s = s + 1
                        continue 
                    require gameID < stor9
                    mem[0] = 9
                    storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
                    s = _1174
                    idx = idx + 1
                    continue 
                _1234 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1234] = 0
                u = 0
                w = 0
                v = 0
                while uint8(v) < 5:
                    s = u
                    idx = v + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1174]
                        require uint8(v) < mem[_1174]
                        if mem[(32 * uint8(v)) + _1174 + 63 len 1] <= mem[(32 * uint8(idx)) + _1174 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(v) < mem[_1174]
                        _1588 = mem[(32 * uint8(v)) + _1174 + 32]
                        require uint8(idx) < mem[_1174]
                        require uint8(v) < mem[_1174]
                        mem[_1174 + (32 * uint8(v)) + 32] = mem[(32 * uint8(idx)) + _1174 + 63 len 1]
                        require uint8(idx) < mem[_1174]
                        mem[_1174 + (32 * uint8(idx)) + 32] = uint8(_1588)
                        s = _1588
                        idx = idx + 1
                        continue 
                    u = s
                    w = idx
                    v = v + 1
                    continue 
                require mem[_1174] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require gameID < stor9
                require bool(storBA6E[stor10]) != 1
                require gameID < stor9
                require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
                require gameID < stor9
                mem[0] = 9
                require block.timestamp >= storB16E[stor10] + stor2.length
                _1486 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1486] = 0
                u = 0
                v = 0
                t = 0
                while uint8(t) < 5:
                    s = u
                    idx = t + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1174]
                        require uint8(t) < mem[_1174]
                        if mem[(32 * uint8(t)) + _1174 + 63 len 1] <= mem[(32 * uint8(idx)) + _1174 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(t) < mem[_1174]
                        _1917 = mem[(32 * uint8(t)) + _1174 + 32]
                        require uint8(idx) < mem[_1174]
                        require uint8(t) < mem[_1174]
                        mem[_1174 + (32 * uint8(t)) + 32] = mem[(32 * uint8(idx)) + _1174 + 63 len 1]
                        require uint8(idx) < mem[_1174]
                        mem[_1174 + (32 * uint8(idx)) + 32] = uint8(_1917)
                        s = _1917
                        idx = idx + 1
                        continue 
                    u = s
                    v = idx
                    t = t + 1
                    continue 
                u = 0
                t = 0
                u = 0
                while uint8(t) < 6:
                    require uint8(t) < mem[_1174]
                    require mem[(32 * uint8(t)) + _1174 + 63 len 1] >= 1
                    require mem[(32 * uint8(t)) + _1174 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(t)) + _1174 + 63 len 1] > uint8(u)
                    u = mem[(32 * uint8(t)) + _1174 + 32]
                    t = t + 1
                    u = mem[(32 * uint8(t)) + _1174 + 32]
                    continue 
                require gameID < stor9
                storBA6E[stor10]++
                if not storBA6E[stor10] > storBA6E[stor10] + 1:
                    require gameID < stor9
                    storBA6E[stor10] = stor566E[stor10]
                    require stor6E15[stor10] - 1 < stor566E[stor10]
                    mem[0] = (14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
                    if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) <= 6:
                        mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                        s = sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + 1
                        while sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + (uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1174]
                        require uint8(s) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
                        mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                        uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(s)) + _1174 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
                        s = s + 1
                        continue 
                    require gameID < stor9
                    mem[0] = 9
                    storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
                    s = _1174
                    idx = idx + 1
                    continue 
                mem[0] = (14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c
                t = sha3(mem[0]) + (6 * storBA6E[stor10]) + 6
                while sha3((14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c) + (6 * storBA6E[stor10]) > t:
                    address(stor[t]) = 0
                    stor1[t] = 0
                    mem[0] = t + 1
                    s = sha3(s + 1)
                    while sha3(s + 1) + (stor1[s] + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                    stor2[s] = 0
                    stor3[s] = 0
                    uint256(stor4[s]) = 0
                    sub_6a52dfdb[s] = 0
                    s = s + 6
                    continue 
                require gameID < stor9
                storBA6E[stor10] = stor566E[stor10]
                require stor6E15[stor10] - 1 < stor566E[stor10]
                mem[0] = (14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
                if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) > 6:
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1174]
                        require uint8(s) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
                        mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                        uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(s)) + _1174 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
                        s = s + 1
                        continue 
                    require gameID < stor9
                    mem[0] = 9
                    storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
                    s = _1174
                    idx = idx + 1
                    continue 
                mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                t = sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + 1
                while sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + (uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
            else:
                _1180 = msize
                mem[msize] = uint8(maxNumber + 1)
                mem[64] = _1180 + (32 * uint8(maxNumber + 1)) + 32
                s = 0
                t = 0
                u = 0
                while s < 123456789:
                    mem[mem[64]] = block.difficulty
                    mem[mem[64] + 32] = address(block.coinbase)
                    mem[mem[64] + 52] = block.timestamp
                    mem[mem[64] + 84] = address(msg.sender)
                    mem[mem[64] + 104] = s
                    if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                        s = s + 1
                        t = t
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1180]
                    if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _1180 + 63 len 1]:
                        s = s + 1
                        t = t
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1180]
                    mem[_1180 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 32] = 1
                    require uint8(t) < mem[_1174]
                    mem[_1174 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                    if uint8(t + 1) != 6:
                        s = s + 1
                        t = t + 1
                        u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                        continue 
                    _1297 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1297] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_1174]
                            require uint8(s) < mem[_1174]
                            if mem[(32 * uint8(s)) + _1174 + 63 len 1] <= mem[(32 * uint8(idx)) + _1174 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_1174]
                            _1788 = mem[(32 * uint8(s)) + _1174 + 32]
                            require uint8(idx) < mem[_1174]
                            require uint8(s) < mem[_1174]
                            mem[_1174 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1174 + 63 len 1]
                            require uint8(idx) < mem[_1174]
                            mem[_1174 + (32 * uint8(idx)) + 32] = uint8(_1788)
                            u = _1788
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    require mem[_1174] == 6
                    require maxNumber == maxNumber
                    require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                    require gameID < stor9
                    require bool(storBA6E[stor10]) != 1
                    require gameID < stor9
                    require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
                    require gameID < stor9
                    mem[0] = 9
                    require block.timestamp >= storB16E[stor10] + stor2.length
                    _1679 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1679] = 0
                    t = 0
                    u = 0
                    s = 0
                    while uint8(s) < 5:
                        u = t
                        idx = s + 1
                        while uint8(idx) < 6:
                            require uint8(idx) < mem[_1174]
                            require uint8(s) < mem[_1174]
                            if mem[(32 * uint8(s)) + _1174 + 63 len 1] <= mem[(32 * uint8(idx)) + _1174 + 63 len 1]:
                                u = u
                                idx = idx + 1
                                continue 
                            require uint8(s) < mem[_1174]
                            _2176 = mem[(32 * uint8(s)) + _1174 + 32]
                            require uint8(idx) < mem[_1174]
                            require uint8(s) < mem[_1174]
                            mem[_1174 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1174 + 63 len 1]
                            require uint8(idx) < mem[_1174]
                            mem[_1174 + (32 * uint8(idx)) + 32] = uint8(_2176)
                            u = _2176
                            idx = idx + 1
                            continue 
                        t = u
                        u = idx
                        s = s + 1
                        continue 
                    t = 0
                    s = 0
                    t = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1174]
                        require mem[(32 * uint8(s)) + _1174 + 63 len 1] >= 1
                        require mem[(32 * uint8(s)) + _1174 + 63 len 1] <= maxNumber
                        require mem[(32 * uint8(s)) + _1174 + 63 len 1] > uint8(t)
                        t = mem[(32 * uint8(s)) + _1174 + 32]
                        s = s + 1
                        t = mem[(32 * uint8(s)) + _1174 + 32]
                        continue 
                    require gameID < stor9
                    storBA6E[stor10]++
                    if not storBA6E[stor10] <= storBA6E[stor10] + 1:
                        mem[0] = (14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c
                        s = sha3(mem[0]) + (6 * storBA6E[stor10]) + 6
                        while sha3((14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c) + (6 * storBA6E[stor10]) > s:
                            address(stor[s]) = 0
                            stor1[s] = 0
                            mem[0] = s + 1
                            t = sha3(t + 1)
                            while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                                uint256(stor[t]) = 0
                                t = t + 1
                                continue 
                            stor2[t] = 0
                            stor3[t] = 0
                            uint256(stor4[t]) = 0
                            sub_6a52dfdb[t] = 0
                            t = t + 6
                            continue 
                    require gameID < stor9
                    storBA6E[stor10] = stor566E[stor10]
                    require stor6E15[stor10] - 1 < stor566E[stor10]
                    mem[0] = (14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
                    if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) <= 6:
                        mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                        s = sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + 1
                        while sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + (uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
                    s = 0
                    while uint8(s) < 6:
                        require uint8(s) < mem[_1174]
                        require uint8(s) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
                        mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                        uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(s)) + _1174 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
                        s = s + 1
                        continue 
                    require gameID < stor9
                    mem[0] = 9
                    storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
                    s = _1174
                    idx = idx + 1
                    continue 
                _1236 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1236] = 0
                t = 0
                v = 0
                u = 0
                while uint8(u) < 5:
                    s = t
                    idx = u + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1174]
                        require uint8(u) < mem[_1174]
                        if mem[(32 * uint8(u)) + _1174 + 63 len 1] <= mem[(32 * uint8(idx)) + _1174 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(u) < mem[_1174]
                        _1593 = mem[(32 * uint8(u)) + _1174 + 32]
                        require uint8(idx) < mem[_1174]
                        require uint8(u) < mem[_1174]
                        mem[_1174 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _1174 + 63 len 1]
                        require uint8(idx) < mem[_1174]
                        mem[_1174 + (32 * uint8(idx)) + 32] = uint8(_1593)
                        s = _1593
                        idx = idx + 1
                        continue 
                    t = s
                    v = idx
                    u = u + 1
                    continue 
                require mem[_1174] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require gameID < stor9
                require bool(storBA6E[stor10]) != 1
                require gameID < stor9
                require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
                require gameID < stor9
                mem[0] = 9
                require block.timestamp >= storB16E[stor10] + stor2.length
                _1487 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1487] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1174]
                        require uint8(s) < mem[_1174]
                        if mem[(32 * uint8(s)) + _1174 + 63 len 1] <= mem[(32 * uint8(idx)) + _1174 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1174]
                        _1924 = mem[(32 * uint8(s)) + _1174 + 32]
                        require uint8(idx) < mem[_1174]
                        require uint8(s) < mem[_1174]
                        mem[_1174 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1174 + 63 len 1]
                        require uint8(idx) < mem[_1174]
                        mem[_1174 + (32 * uint8(idx)) + 32] = uint8(_1924)
                        u = _1924
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                t = 0
                s = 0
                t = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1174]
                    require mem[(32 * uint8(s)) + _1174 + 63 len 1] >= 1
                    require mem[(32 * uint8(s)) + _1174 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(s)) + _1174 + 63 len 1] > uint8(t)
                    t = mem[(32 * uint8(s)) + _1174 + 32]
                    s = s + 1
                    t = mem[(32 * uint8(s)) + _1174 + 32]
                    continue 
                require gameID < stor9
                storBA6E[stor10]++
                if not storBA6E[stor10] <= storBA6E[stor10] + 1:
                    mem[0] = (14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c
                    s = sha3(mem[0]) + (6 * storBA6E[stor10]) + 6
                    while sha3((14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c) + (6 * storBA6E[stor10]) > s:
                        address(stor[s]) = 0
                        stor1[s] = 0
                        mem[0] = s + 1
                        t = sha3(t + 1)
                        while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                            uint256(stor[t]) = 0
                            t = t + 1
                            continue 
                        stor2[t] = 0
                        stor3[t] = 0
                        uint256(stor4[t]) = 0
                        sub_6a52dfdb[t] = 0
                        t = t + 6
                        continue 
                require gameID < stor9
                storBA6E[stor10] = stor566E[stor10]
                require stor6E15[stor10] - 1 < stor566E[stor10]
                mem[0] = (14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
                if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) <= 6:
                    mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                    s = sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + 1
                    while sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + (uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
            uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
            s = 0
            while uint8(s) < 6:
                require uint8(s) < mem[_1174]
                require uint8(s) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
                mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(s)) + _1174 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
                s = s + 1
                continue 
            require gameID < stor9
            mem[0] = 9
            storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
            t = _1174
            idx = idx + 1
            continue 
        _1177 = msize
        mem[msize] = 6
        if msize < _1177 + 224:
            mem[_1177 + 224] = uint8(maxNumber + 1)
            mem[64] = _1177 + (32 * uint8(maxNumber + 1)) + 256
            s = 0
            t = 0
            u = 0
            while s < 123456789:
                mem[mem[64]] = block.difficulty
                mem[mem[64] + 32] = address(block.coinbase)
                mem[mem[64] + 52] = block.timestamp
                mem[mem[64] + 84] = address(msg.sender)
                mem[mem[64] + 104] = s
                if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1177 + 224]
                if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _1177 + 287 len 1]:
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1177 + 224]
                mem[_1177 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 256] = 1
                require uint8(t) < mem[_1177]
                mem[_1177 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                if uint8(t + 1) != 6:
                    s = s + 1
                    t = t + 1
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                _1299 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1299] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1177]
                        require uint8(s) < mem[_1177]
                        if mem[(32 * uint8(s)) + _1177 + 63 len 1] <= mem[(32 * uint8(idx)) + _1177 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1177]
                        _1794 = mem[(32 * uint8(s)) + _1177 + 32]
                        require uint8(idx) < mem[_1177]
                        require uint8(s) < mem[_1177]
                        mem[_1177 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1177 + 63 len 1]
                        require uint8(idx) < mem[_1177]
                        mem[_1177 + (32 * uint8(idx)) + 32] = uint8(_1794)
                        u = _1794
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                require mem[_1177] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require gameID < stor9
                require bool(storBA6E[stor10]) != 1
                require gameID < stor9
                require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
                require gameID < stor9
                mem[0] = 9
                require block.timestamp >= storB16E[stor10] + stor2.length
                _1680 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1680] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1177]
                        require uint8(s) < mem[_1177]
                        if mem[(32 * uint8(s)) + _1177 + 63 len 1] <= mem[(32 * uint8(idx)) + _1177 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1177]
                        _2182 = mem[(32 * uint8(s)) + _1177 + 32]
                        require uint8(idx) < mem[_1177]
                        require uint8(s) < mem[_1177]
                        mem[_1177 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1177 + 63 len 1]
                        require uint8(idx) < mem[_1177]
                        mem[_1177 + (32 * uint8(idx)) + 32] = uint8(_2182)
                        u = _2182
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                t = 0
                s = 0
                t = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1177]
                    require mem[(32 * uint8(s)) + _1177 + 63 len 1] >= 1
                    require mem[(32 * uint8(s)) + _1177 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(s)) + _1177 + 63 len 1] > uint8(t)
                    t = mem[(32 * uint8(s)) + _1177 + 32]
                    s = s + 1
                    t = mem[(32 * uint8(s)) + _1177 + 32]
                    continue 
                require gameID < stor9
                storBA6E[stor10]++
                if not storBA6E[stor10] <= storBA6E[stor10] + 1:
                    mem[0] = (14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c
                    s = sha3(mem[0]) + (6 * storBA6E[stor10]) + 6
                    while sha3((14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c) + (6 * storBA6E[stor10]) > s:
                        address(stor[s]) = 0
                        stor1[s] = 0
                        mem[0] = s + 1
                        t = sha3(t + 1)
                        while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                            uint256(stor[t]) = 0
                            t = t + 1
                            continue 
                        stor2[t] = 0
                        stor3[t] = 0
                        uint256(stor4[t]) = 0
                        sub_6a52dfdb[t] = 0
                        t = t + 6
                        continue 
                require gameID < stor9
                storBA6E[stor10] = stor566E[stor10]
                require stor6E15[stor10] - 1 < stor566E[stor10]
                mem[0] = (14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
                if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) <= 6:
                    mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                    s = sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + 1
                    while sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + (uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
                s = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1177]
                    require uint8(s) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
                    mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                    uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(s)) + _1177 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
                    s = s + 1
                    continue 
                require gameID < stor9
                mem[0] = 9
                storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
                s = _1177
                idx = idx + 1
                continue 
            _1238 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1238] = 0
            t = 0
            v = 0
            u = 0
            while uint8(u) < 5:
                s = t
                idx = u + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_1177]
                    require uint8(u) < mem[_1177]
                    if mem[(32 * uint8(u)) + _1177 + 63 len 1] <= mem[(32 * uint8(idx)) + _1177 + 63 len 1]:
                        s = s
                        idx = idx + 1
                        continue 
                    require uint8(u) < mem[_1177]
                    _1598 = mem[(32 * uint8(u)) + _1177 + 32]
                    require uint8(idx) < mem[_1177]
                    require uint8(u) < mem[_1177]
                    mem[_1177 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _1177 + 63 len 1]
                    require uint8(idx) < mem[_1177]
                    mem[_1177 + (32 * uint8(idx)) + 32] = uint8(_1598)
                    s = _1598
                    idx = idx + 1
                    continue 
                t = s
                v = idx
                u = u + 1
                continue 
            require mem[_1177] == 6
            require maxNumber == maxNumber
            require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
            require gameID < stor9
            require bool(storBA6E[stor10]) != 1
            require gameID < stor9
            require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
            require gameID < stor9
            mem[0] = 9
            require block.timestamp >= storB16E[stor10] + stor2.length
            _1488 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1488] = 0
            t = 0
            u = 0
            s = 0
            while uint8(s) < 5:
                u = t
                idx = s + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_1177]
                    require uint8(s) < mem[_1177]
                    if mem[(32 * uint8(s)) + _1177 + 63 len 1] <= mem[(32 * uint8(idx)) + _1177 + 63 len 1]:
                        u = u
                        idx = idx + 1
                        continue 
                    require uint8(s) < mem[_1177]
                    _1931 = mem[(32 * uint8(s)) + _1177 + 32]
                    require uint8(idx) < mem[_1177]
                    require uint8(s) < mem[_1177]
                    mem[_1177 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1177 + 63 len 1]
                    require uint8(idx) < mem[_1177]
                    mem[_1177 + (32 * uint8(idx)) + 32] = uint8(_1931)
                    u = _1931
                    idx = idx + 1
                    continue 
                t = u
                u = idx
                s = s + 1
                continue 
        else:
            _1185 = msize
            mem[msize] = uint8(maxNumber + 1)
            mem[64] = _1185 + (32 * uint8(maxNumber + 1)) + 32
            s = 0
            t = 0
            u = 0
            while s < 123456789:
                mem[mem[64]] = block.difficulty
                mem[mem[64] + 32] = address(block.coinbase)
                mem[mem[64] + 52] = block.timestamp
                mem[mem[64] + 84] = address(msg.sender)
                mem[mem[64] + 104] = s
                if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1185]
                if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _1185 + 63 len 1]:
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_1185]
                mem[_1185 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 32] = 1
                require uint8(t) < mem[_1177]
                mem[_1177 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                if uint8(t + 1) != 6:
                    s = s + 1
                    t = t + 1
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                _1301 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1301] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1177]
                        require uint8(s) < mem[_1177]
                        if mem[(32 * uint8(s)) + _1177 + 63 len 1] <= mem[(32 * uint8(idx)) + _1177 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1177]
                        _1800 = mem[(32 * uint8(s)) + _1177 + 32]
                        require uint8(idx) < mem[_1177]
                        require uint8(s) < mem[_1177]
                        mem[_1177 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1177 + 63 len 1]
                        require uint8(idx) < mem[_1177]
                        mem[_1177 + (32 * uint8(idx)) + 32] = uint8(_1800)
                        u = _1800
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                require mem[_1177] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require gameID < stor9
                require bool(storBA6E[stor10]) != 1
                require gameID < stor9
                require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
                require gameID < stor9
                mem[0] = 9
                require block.timestamp >= storB16E[stor10] + stor2.length
                _1681 = mem[64]
                mem[64] = mem[64] + 32
                mem[_1681] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_1177]
                        require uint8(s) < mem[_1177]
                        if mem[(32 * uint8(s)) + _1177 + 63 len 1] <= mem[(32 * uint8(idx)) + _1177 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_1177]
                        _2188 = mem[(32 * uint8(s)) + _1177 + 32]
                        require uint8(idx) < mem[_1177]
                        require uint8(s) < mem[_1177]
                        mem[_1177 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1177 + 63 len 1]
                        require uint8(idx) < mem[_1177]
                        mem[_1177 + (32 * uint8(idx)) + 32] = uint8(_2188)
                        u = _2188
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                t = 0
                s = 0
                t = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1177]
                    require mem[(32 * uint8(s)) + _1177 + 63 len 1] >= 1
                    require mem[(32 * uint8(s)) + _1177 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(s)) + _1177 + 63 len 1] > uint8(t)
                    t = mem[(32 * uint8(s)) + _1177 + 32]
                    s = s + 1
                    t = mem[(32 * uint8(s)) + _1177 + 32]
                    continue 
                require gameID < stor9
                storBA6E[stor10]++
                if not storBA6E[stor10] <= storBA6E[stor10] + 1:
                    mem[0] = (14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c
                    s = sha3(mem[0]) + (6 * storBA6E[stor10]) + 6
                    while sha3((14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c) + (6 * storBA6E[stor10]) > s:
                        address(stor[s]) = 0
                        stor1[s] = 0
                        mem[0] = s + 1
                        t = sha3(t + 1)
                        while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                            uint256(stor[t]) = 0
                            t = t + 1
                            continue 
                        stor2[t] = 0
                        stor3[t] = 0
                        uint256(stor4[t]) = 0
                        sub_6a52dfdb[t] = 0
                        t = t + 6
                        continue 
                require gameID < stor9
                storBA6E[stor10] = stor566E[stor10]
                require stor6E15[stor10] - 1 < stor566E[stor10]
                mem[0] = (14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
                if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) <= 6:
                    mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                    s = sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + 1
                    while sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + (uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
                s = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_1177]
                    require uint8(s) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
                    mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
                    uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(s)) + _1177 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
                    s = s + 1
                    continue 
                require gameID < stor9
                mem[0] = 9
                storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
                s = _1177
                idx = idx + 1
                continue 
            _1240 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1240] = 0
            t = 0
            v = 0
            u = 0
            while uint8(u) < 5:
                s = t
                idx = u + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_1177]
                    require uint8(u) < mem[_1177]
                    if mem[(32 * uint8(u)) + _1177 + 63 len 1] <= mem[(32 * uint8(idx)) + _1177 + 63 len 1]:
                        s = s
                        idx = idx + 1
                        continue 
                    require uint8(u) < mem[_1177]
                    _1603 = mem[(32 * uint8(u)) + _1177 + 32]
                    require uint8(idx) < mem[_1177]
                    require uint8(u) < mem[_1177]
                    mem[_1177 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _1177 + 63 len 1]
                    require uint8(idx) < mem[_1177]
                    mem[_1177 + (32 * uint8(idx)) + 32] = uint8(_1603)
                    s = _1603
                    idx = idx + 1
                    continue 
                t = s
                v = idx
                u = u + 1
                continue 
            require mem[_1177] == 6
            require maxNumber == maxNumber
            require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
            require gameID < stor9
            require bool(storBA6E[stor10]) != 1
            require gameID < stor9
            require block.timestamp <= storB16E[stor10] + stor1.length - stor2.length
            require gameID < stor9
            mem[0] = 9
            require block.timestamp >= storB16E[stor10] + stor2.length
            _1489 = mem[64]
            mem[64] = mem[64] + 32
            mem[_1489] = 0
            t = 0
            u = 0
            s = 0
            while uint8(s) < 5:
                u = t
                idx = s + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_1177]
                    require uint8(s) < mem[_1177]
                    if mem[(32 * uint8(s)) + _1177 + 63 len 1] <= mem[(32 * uint8(idx)) + _1177 + 63 len 1]:
                        u = u
                        idx = idx + 1
                        continue 
                    require uint8(s) < mem[_1177]
                    _1938 = mem[(32 * uint8(s)) + _1177 + 32]
                    require uint8(idx) < mem[_1177]
                    require uint8(s) < mem[_1177]
                    mem[_1177 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _1177 + 63 len 1]
                    require uint8(idx) < mem[_1177]
                    mem[_1177 + (32 * uint8(idx)) + 32] = uint8(_1938)
                    u = _1938
                    idx = idx + 1
                    continue 
                t = u
                u = idx
                s = s + 1
                continue 
        t = 0
        s = 0
        t = 0
        while uint8(s) < 6:
            require uint8(s) < mem[_1177]
            require mem[(32 * uint8(s)) + _1177 + 63 len 1] >= 1
            require mem[(32 * uint8(s)) + _1177 + 63 len 1] <= maxNumber
            require mem[(32 * uint8(s)) + _1177 + 63 len 1] > uint8(t)
            t = mem[(32 * uint8(s)) + _1177 + 32]
            s = s + 1
            t = mem[(32 * uint8(s)) + _1177 + 32]
            continue 
        require gameID < stor9
        storBA6E[stor10]++
        if not storBA6E[stor10] <= storBA6E[stor10] + 1:
            mem[0] = (14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c
            s = sha3(mem[0]) + (6 * storBA6E[stor10]) + 6
            while sha3((14 * gameID) - 0x4591eabfe8e493f369f48e58fdf2609ff8809506ce57440a6f25fddc25308a2c) + (6 * storBA6E[stor10]) > s:
                address(stor[s]) = 0
                stor1[s] = 0
                mem[0] = s + 1
                t = sha3(t + 1)
                while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                    uint256(stor[t]) = 0
                    t = t + 1
                    continue 
                stor2[t] = 0
                stor3[t] = 0
                uint256(stor4[t]) = 0
                sub_6a52dfdb[t] = 0
                t = t + 6
                continue 
        require gameID < stor9
        storBA6E[stor10] = stor566E[stor10]
        require stor6E15[stor10] - 1 < stor566E[stor10]
        mem[0] = (14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7
        uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4]) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
        uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]) = msg.sender or Mask(96, 160, uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 6]))
        uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) = 6
        if not uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) <= 6:
            mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
            s = sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + 1
            while sha3((6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5) + (uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5]) + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
        uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 1]) = gameID
        s = 0
        while uint8(s) < 6:
            require uint8(s) < mem[_1177]
            require uint8(s) < uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5])
            mem[0] = (6 * stor6E15[stor10]) + sha3((14 * gameID) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5
            uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)]) = mem[(32 * uint8(s)) + _1177 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 5)])
            s = s + 1
            continue 
        require gameID < stor9
        mem[0] = 9
        storBA6E[stor10] += uint256(stor[(6 * stor6E15[stor10]) + sha3((14 * stor10) + 0x566e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7) - 4])
        t = _1177
        idx = idx + 1
        continue 
    require gameID < stor9
    stor6E15[stor10] += msg.value
    stor406E[stor10] += 85 * msg.value / 100
    uint256(stor[code.data[9292 len 32] + (14 * stor10)]) += 5 * msg.value / 100
    if 0 == address(stor4[address(msg.sender)]):
        require gameID < stor9
        stor406E[stor10] += 10 * msg.value / 100
    else:
        require sub_6a52dfdb[address(stor4[address(msg.sender)])] < stor6.length
        storBCF6[stor5[address(stor4[address(msg.sender)])]] += 10 * msg.value / 100
        require gameID < stor9
        stor6E15[stor10] += 10 * msg.value / 100
}



}
