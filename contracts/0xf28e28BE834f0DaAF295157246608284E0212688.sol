contract main {


// =======================  Init code  ======================


const _fallback = code.data[30 len 4599]




// =====================  Runtime code  =====================


const contract_version = '0.1._'


array of uint256 stor1;
array of uint256 stor2;
array of uint256 stor3;
array of address stor4;
array of address stor5;
array of uint8 stor19;

function sub_5ef30ac8(?) payable {
    require stor3[arg1]
    selfdestruct(0)
}

function sub_de394e0d(?) payable {
    require stor3[arg1] <= 0
    require stor2[arg1] > 0
    require stor2[arg1] + uint256(stor[arg1]) <= block.number
    stor3[arg1] = block.number
    require uint8(stor[arg1 + 18][stor4[arg1]])
    require uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1) < 2
    require uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2) < 2
    if uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 9]) - uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 9]) > uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]):
        if uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]) + uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 7]) > 0:
            require ext_code.size(stor5[arg1])
            call stor5[arg1].0xa9059cbb with:
                 gas gas_remaining - 710 wei
                args address(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 6]), uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]) + uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 7])
            require ext_call.success
            require ext_call.return_data[0]
        else:
            if uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]) + uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 7]) > 0:
                require ext_code.size(stor5[arg1])
                call stor5[arg1].0xa9059cbb with:
                     gas gas_remaining - 710 wei
                    args address(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 6]), uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]) + uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 7])
                require ext_call.success
                require ext_call.return_data[0]
    else:
        if uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 7]) + uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 9]) - uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 9]) <= 0:
            if uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]) + uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 7]) > 0:
                require ext_code.size(stor5[arg1])
                call stor5[arg1].0xa9059cbb with:
                     gas gas_remaining - 710 wei
                    args address(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 6]), uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]) + uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 7])
                require ext_call.success
                require ext_call.return_data[0]
        else:
            require ext_code.size(stor5[arg1])
            call stor5[arg1].0xa9059cbb with:
                 gas gas_remaining - 710 wei
                args address(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 6]), uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 7]) + uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 9]) - uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 9])
            require ext_call.success
            require ext_call.return_data[0]
            if uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]) - uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 9]) + uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 9]) > 0:
                require ext_code.size(stor5[arg1])
                call stor5[arg1].0xa9059cbb with:
                     gas gas_remaining - 710 wei
                    args address(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 6]), uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 7]) - uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][stor4[arg1]]) - 1)) + arg1 + 9]) + uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][stor4[arg1]]) + 2)) + arg1 + 9])
                require ext_call.success
                require ext_call.return_data[0]
    require stor3[arg1]
    selfdestruct(0)
}

function _fallback() payable {
    revert
}

function sub_3268a05a(?) payable {
    require stor1[arg1] > 0
    require not stor2[arg1]
    require ext_code.size(stor5[arg1])
    call stor5[arg1].0x70a08231 with:
         gas gas_remaining - 710 wei
        args msg.sender
    require ext_call.success
    require ext_call.return_data[0] >= arg2
    require uint8(stor[arg1 + 18][address(msg.sender)])
    require uint8(uint8(stor[arg1 + 18][address(msg.sender)]) - 1) < 2
    require ext_code.size(stor5[arg1])
    call stor5[arg1].0x23b872dd with:
         gas gas_remaining - 710 wei
        args msg.sender, address(this.address), arg2
    require ext_call.success
    if bool(ext_call.return_data[0]) != 1:
        return 0
    uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][address(msg.sender)]) - 1)) + arg1 + 7]) += arg2
    return 1, uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][address(msg.sender)]) - 1)) + arg1 + 7]) + arg2
}

function sub_f565eb36(?) payable {
    mem[128 len arg6.length] = arg6[all]
    require stor3[arg1] <= 0
    require stor2[arg1] > 0
    require stor2[arg1] + uint256(stor[arg1]) >= block.number
    require not stor19[arg1]
    stor19[arg1] = 1
    require uint8(stor[arg1 + 18][address(msg.sender)])
    require stor4[arg1] != msg.sender
    require arg6.length == 65
    mem[ceil32(arg6.length) + 128] = arg2 << 192
    mem[ceil32(arg6.length) + 136] = arg3
    mem[ceil32(arg6.length) + 168] = arg4
    if mem[192 len 1] != 27:
        require mem[192 len 1] == 28
    signer = erecover(sha3(arg2, arg3, arg4, this.address, arg5), mem[161] << 248, mem[128], mem[160]) 
    require erecover.result
    require address(signer) == stor4[arg1]
    require uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2) < 2
    uint64(stor[(6 * uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2)) + arg1 + 10]) = arg2
    uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2)) + arg1 + 8]) = arg4
    uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2)) + arg1 + 9]) = arg3
}

function sub_c800b002(?) payable {
    mem[128 len arg6.length] = arg6[all]
    require not stor2[arg1]
    stor2[arg1] = block.number
    require uint8(stor[arg1 + 18][address(msg.sender)])
    stor4[arg1] = msg.sender
    if arg6.length == 65:
        require arg6.length == 65
        mem[ceil32(arg6.length) + 128] = arg2 << 192
        mem[ceil32(arg6.length) + 136] = arg3
        mem[ceil32(arg6.length) + 168] = arg4
        if mem[192 len 1] != 27:
            require mem[192 len 1] == 28
        signer = erecover(sha3(arg2, arg3, arg4, this.address, arg5), mem[161] << 248, mem[128], mem[160]) 
        require erecover.result
        require uint8(stor[arg1 + 18][address(signer)])
        require uint8(uint8(stor[arg1 + 18][address(msg.sender)]) - 1) != uint8(uint8(stor[arg1 + 18][address(signer)]) - 1)
        require uint8(uint8(stor[arg1 + 18][address(signer)]) - 1) < 2
        uint64(stor[(6 * uint8(uint8(stor[arg1 + 18][address(signer)]) - 1)) + arg1 + 10]) = arg2
        uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][address(signer)]) - 1)) + arg1 + 8]) = arg4
        uint256(stor[(6 * uint8(uint8(stor[arg1 + 18][address(signer)]) - 1)) + arg1 + 9]) = arg3
}

function sub_c2522462(?) payable {
    mem[128 len arg2.length] = arg2[all]
    mem[ceil32(arg2.length) + 128] = arg3.length
    mem[ceil32(arg2.length) + 160 len arg3.length] = arg3[all]
    require stor3[arg1] <= 0
    require stor2[arg1] > 0
    require uint8(stor[arg1 + 18][address(msg.sender)])
    require uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2) < 2
    require uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2)) + arg1 + 8])
    require arg2.length == 72
    _6 = mem[136]
    _7 = mem[168]
    require not uint8(stor[(6 * uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2)) + arg1 + 11][mem[168]])
    uint8(stor[(6 * uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2)) + arg1 + 11][mem[168]]) = 1
    require mem[128 len 8] >= block.number
    mem[ceil32(arg2.length) + ceil32(arg3.length) + 160] = arg4
    require _7 == sha3(arg4)
    require not arg3.length % 32
    mem[ceil32(arg2.length) + ceil32(arg3.length) + 160 len floor32(arg2.length)] = call.data[arg2 + 36 len floor32(arg2.length)]
    mem[ceil32(arg2.length) + ceil32(arg3.length) + floor32(arg2.length) + -(arg2.length % 32) + 192 len arg2.length % 32] = mem[floor32(arg2.length) + -(arg2.length % 32) + 160 len arg2.length % 32]
    s = 0
    s = 0
    idx = 32
    while idx <= arg3.length:
        _43 = mem[ceil32(arg2.length) + idx + 128]
        if s + sha3(mem[ceil32(arg2.length) + ceil32(arg3.length) + 160 len arg2.length]) >= mem[ceil32(arg2.length) + idx + 128]:
            mem[ceil32(arg2.length) + ceil32(arg3.length) + 160] = mem[ceil32(arg2.length) + idx + 128]
            mem[ceil32(arg2.length) + ceil32(arg3.length) + 192] = s + sha3(mem[ceil32(arg2.length) + ceil32(arg3.length) + 160 len arg2.length])
            s = _43
            s = sha3(mem[ceil32(arg2.length) + ceil32(arg3.length) + 160 len 64])
            idx = idx + 32
            continue 
        mem[ceil32(arg2.length) + ceil32(arg3.length) + 160] = s + sha3(mem[ceil32(arg2.length) + ceil32(arg3.length) + 160 len arg2.length])
        mem[ceil32(arg2.length) + ceil32(arg3.length) + 192] = _43
        s = _43
        s = sha3(mem[ceil32(arg2.length) + ceil32(arg3.length) + 160], _43)
        idx = idx + 32
        continue 
    require uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2)) + arg1 + 8]) == s
    uint256(stor[(6 * uint8(-uint8(stor[arg1 + 18][address(msg.sender)]) + 2)) + arg1 + 9]) += _6
}



}
