contract main {


// =======================  Init code  ======================


uint8 stor0; offset 160
uint256 stor0;
uint256 stor1;
uint256 stor2;
uint256 stor3;
array of struct stor6;
uint256 stor7;
uint256 stor8;
uint256 stor11;
array of uint256 stor12;
uint256 storDF69;
uint8 storDF69;

function _fallback() payable {
    uint8(stor0.field_160) = 16
    stor1 = 900
    stor2 = 120
    stor3 = 10^16
    stor7 = 50
    stor8 = 2 * 10^16
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    stor6.length = 1
    if not stor6.length <= 1:
        idx = 2
        while 2 * stor6.length > idx:
            address(stor6[idx].field_0) = 0
            uint256(stor6[idx].field_256) = 0
            idx = idx + 2
            continue 
    stor12.length = 1
    if not stor12.length <= 1:
        mem[0] = 12
        idx = 14
        while sha3(12) + (14 * stor12.length) > idx + sha3(mem[0]):
            uint256(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            uint256(stor[idx + sha3(mem[0]) + 3]) = 0
            uint256(stor[idx + sha3(mem[0]) + 4]) = 0
            uint256(stor[idx + sha3(mem[0]) + 5]) = 0
            uint256(stor[idx + sha3(mem[0]) + 6]) = 0
            uint256(stor[idx + sha3(mem[0]) + 7]) = 0
            uint256(stor[idx + sha3(mem[0]) + 8]) = 0
            mem[0] = idx + sha3(mem[0]) + 8
            s = sha3(idx + sha3(mem[0]) + 8)
            while sha3(idx + sha3(mem[0]) + 8) + (uint256(stor[idx + sha3(mem[0]) + 8]) + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
            uint256(stor[idx + sha3(mem[0]) + 9]) = 0
            if 31 < stor[idx + sha3(mem[0]) + 9].length:
                mem[0] = idx + sha3(mem[0]) + 9
                s = sha3(idx + sha3(mem[0]) + 9)
                while sha3(idx + sha3(mem[0]) + 9) + (stor[idx + sha3(mem[0]) + 9].length + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
            uint8(stor[idx + sha3(mem[0]) + 10]) = 0
            uint256(stor[idx + sha3(mem[0]) + 11]) = 0
            uint256(stor[idx + sha3(mem[0]) + 12]) = 0
            uint8(stor[idx + sha3(mem[0]) + 13]) = 0
            idx = idx + 14
            continue 
    stor11 = 0
    require 0 < stor12.length
    storDF69 = block.timestamp
    storDF69 = 0
    stor12 = 0
    return code.data[636 len 12556]
}



// =====================  Runtime code  =====================


#
#  - sub_43ea3faa(?)
#
const N = 6


uint8 maxNumber; offset 160
uint128 stor0; offset 160
address stor0;
uint256 stor0;
uint256 sub_ae466313;
uint256 sub_27ecc221;
uint256 ticketPrice;
mapping of address stor4;
mapping of uint256 sub_6a52dfdb;
array of struct stor6;
uint256 sub_fa06c38a;
uint256 sub_d7a58a87;
array of uint256 description;
uint256 numTickets;
uint256 gameID;
uint256 stor12;
array of struct sub_3963ef83;
uint256 numPlayers;
mapping of struct players;
array of struct sub_44d855f1;
array of uint256 stor29342756659269865961029999460747232221824794544626968177770953008493700641960;
array of uint256 stor39293639328101726505243130984931349302965183851830454149911839134173735220392;
array of uint256 stor90445468109538227694533711255308075229540258289562740109592042498922212981773;
array of uint256 stor91350093806704760471280359575688449509643930044763057016150304873984034307085;
array of uint8 stor93118868309510426721668706047563618969133653286249310090128450450352104076456;
array of uint256 stor96285058249593291440281975168894928949496504429450419263082368763068478715048;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386056;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386058;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386059;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386060;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386062;
array of struct stor101051993584849178915136821395265346177868384823507754984078593667947067386065;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386066;

function ticketPrice() payable {
    return ticketPrice
}

function sub_27ecc221(?) payable {
    return sub_27ecc221
}

function numTickets() payable {
    return numTickets
}

function sub_3963ef83(?) payable {
    require arg2 < sub_3963ef83[arg1].field_0
    mem[448] = stor[sha3((11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 6)].field_0
    idx = 448
    s = 0
    while stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 6].length + 448 > idx + 32:
        mem[idx + 32] = stor[s + sha3((11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 6)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return sub_3963ef83[arg1][arg2].field_0, 
           sub_3963ef83[arg1][arg2].field_256,
           sub_3963ef83[arg1][arg2].field_512,
           address(sub_3963ef83[arg1][arg2].field_768),
           sub_3963ef83[arg1][arg2].field_1024,
           Array(len=stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 6].length, data=mem[448 len stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 6].length + (floor32(stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 6].length - 1) + -stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 6].length + 32 % 32)]),
           sub_3963ef83[arg1][arg2].field_1792,
           uint8(sub_3963ef83[arg1][arg2].field_2048),
           sub_3963ef83[arg1][arg2].field_2304,
           bool(uint8(sub_3963ef83[arg1][arg2].field_2560))
}

function maxNumber() payable {
    return maxNumber
}

function sub_44d855f1(?) payable {
    require arg2 < sub_44d855f1[arg1].field_0
    mem[448] = stor[sha3((11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 16)) + 6)].field_0
    idx = 448
    s = 0
    while stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 16)) + 6].length + 448 > idx + 32:
        mem[idx + 32] = stor[s + sha3((11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 16)) + 6)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return sub_44d855f1[arg1][arg2].field_0, 
           sub_44d855f1[arg1][arg2].field_256,
           sub_44d855f1[arg1][arg2].field_512,
           address(sub_44d855f1[arg1][arg2].field_768),
           sub_44d855f1[arg1][arg2].field_1024,
           Array(len=stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 16)) + 6].length, data=mem[448 len stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 16)) + 6].length + (floor32(stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 16)) + 6].length - 1) + -stor[(11 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 16)) + 6].length + 32 % 32)]),
           sub_44d855f1[arg1][arg2].field_1792,
           uint8(sub_44d855f1[arg1][arg2].field_2048),
           sub_44d855f1[arg1][arg2].field_2304,
           bool(uint8(sub_44d855f1[arg1][arg2].field_2560))
}

function sub_6a52dfdb(?) payable {
    return sub_6a52dfdb[arg1]
}

function description() payable {
    return description[0 len description.length]
}

function numPlayers() payable {
    return numPlayers
}

function sub_ae466313(?) payable {
    return sub_ae466313
}

function gameID() payable {
    return gameID
}

function sub_d7a58a87(?) payable {
    return sub_d7a58a87
}

function players(address arg1) payable {
    return players[arg1].field_0, 
           address(players[arg1].field_256),
           players[arg1].field_512,
           players[arg1].field_768,
           players[arg1].field_1024
}

function sub_fa06c38a(?) payable {
    return sub_fa06c38a
}

function kill() payable {
    require msg.sender == address(stor0.field_0)
    selfdestruct(address(stor0.field_0))
}

function _fallback() payable {
    require gameID < stor12
    storD4DF[stor11] += msg.value
}

function sub_0db35d8c(?) payable {
    require msg.sender == address(stor0.field_0)
    sub_fa06c38a = arg2
    sub_d7a58a87 = 10^18 * arg1
}

function sub_766fc3ef(?) payable {
    require msg.sender == address(stor0.field_0)
    description[] = Array(len=arg1.length, data=arg1[all])
}

function transferOwnership(address arg1) payable {
    require address(stor0.field_0) == msg.sender
    uint256(stor0.field_0) = arg1 or Mask(96, 160, uint256(stor0.field_0))
}

function sub_80322dd5(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 >= 10^15
    ticketPrice = arg1
    require gameID < stor12
    storDF69[stor11] = arg1
}

function sub_236af88c(?) payable {
    require not address(stor4[address(msg.sender)])
    require sub_6a52dfdb[address(arg1)]
    uint256(stor4[address(msg.sender)]) = arg1 or Mask(96, 160, uint256(stor4[address(msg.sender)]))
}

function sub_b28c7c25(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 > 6
    Mask(96, 0, stor0.field_160) = Mask(96, 0, arg1)
    require gameID < stor12
    uint8(storDF69[stor11].field_0) = arg1
    storDF69[stor11].field_256 % 1 = 0
}

function sub_d2a8bcf5(?) payable {
    require sub_fa06c38a > 0
    require msg.value >= sub_d7a58a87
    stor6.length++
    if not stor6.length <= stor6.length + 1:
        idx = 2 * stor6.length + 1
        while 2 * stor6.length > idx:
            address(stor6[idx].field_0) = 0
            stor6[idx].field_256 = 0
            idx = idx + 2
            continue 
    require stor6.length - 1 < stor6.length
    storC9F6[stor6.length - 1] = msg.sender or Mask(96, 160, storC9F6[stor6.length - 1])
    sub_6a52dfdb[address(msg.sender)] = stor6.length - 1
    sub_fa06c38a--
    call address(stor0.field_0) with:
       value msg.value wei
         gas 0 wei
    if not ext_call.success:
        require gameID < stor12
        storD4DF[stor11] += msg.value
}

function games(uint256 arg1) payable {
    require arg1 < stor12
    mem[544] = stor[sha3((14 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730)]
    idx = 544
    s = 0
    while stor[(14 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length + 544 > idx + 32:
        mem[idx + 32] = stor[s + sha3((14 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730) + 1]
        idx = idx + 32
        s = s + 1
        continue 
    return stor56DF[arg1], 
           storDF69[arg1],
           storD4DF[arg1],
           storDF69[arg1],
           storDF69[arg1],
           storDF69[arg1],
           stor40DF[arg1],
           storDF69[arg1],
           Array(len=stor[(14 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length, data=mem[544 len stor[(14 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length + (floor32(stor[(14 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length - 1) + -stor[(14 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length + 32 % 32)]),
           uint8(storDF69[arg1].field_0),
           storDF69[arg1],
           stor[(14 * arg1) + code.data[12524 len 32]],
           bool(storCDDF[arg1])
}

function draw() payable {
    mem[96] = 0
    require gameID < stor12
    require block.timestamp >= stor[code.data[12524 len 32] + (14 * stor11)] + sub_ae466313
    require gameID < stor12
    require bool(storCDDF[stor11]) != 1
    require gameID < stor12
    mem[0] = 12
    storCDDF[stor11] = 1
    mem[128] = 0
    mem[160] = 0
    mem[192] = 6
    mem[416] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 448
    mem[(32 * uint8(maxNumber + 1)) + 448] = block.difficulty
    mem[(32 * uint8(maxNumber + 1)) + 480] = address(block.coinbase)
    mem[(32 * uint8(maxNumber + 1)) + 500] = block.timestamp
    mem[(32 * uint8(maxNumber + 1)) + 532] = address(msg.sender)
    mem[(32 * uint8(maxNumber + 1)) + 552] = var17001
    if uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var17001) % maxNumber) != 0:
        require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var17001) % maxNumber) < uint8(maxNumber + 1)
        if mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var17001) % maxNumber)) + 479 len 1] != 1:
            require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var17001) % maxNumber) < uint8(maxNumber + 1)
            mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var17001) % maxNumber)) + 448] = 1
            mem[224] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var17001) % maxNumber)
    var17001 = var17001 + 1
    var17004 = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var17001) % maxNumber
    continue 
}

function sub_ef2d1714(?) payable {
    mem[96] = 0
    require msg.value >= arg1 * ticketPrice
    if 0 >= arg1:
        require gameID < stor12
        storDF69[stor11] += msg.value
        storD4DF[stor11] += 85 * msg.value / 100
        stor40DF[stor11] += 5 * msg.value / 100
        if 0 == address(stor4[address(msg.sender)]):
            require gameID < stor12
            storD4DF[stor11] += 10 * msg.value / 100
        else:
            require sub_6a52dfdb[address(stor4[address(msg.sender)])] < stor6.length
            storC7F6[stor5[address(stor4[address(msg.sender)])]] += 10 * msg.value / 100
            require gameID < stor12
            storDF69[stor11] += 10 * msg.value / 100
    mem[128] = 0
    mem[160] = 0
    mem[192] = 6
    mem[416] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 448
    mem[(32 * uint8(maxNumber + 1)) + 448] = block.difficulty
    mem[(32 * uint8(maxNumber + 1)) + 480] = address(block.coinbase)
    mem[(32 * uint8(maxNumber + 1)) + 500] = block.timestamp
    mem[(32 * uint8(maxNumber + 1)) + 532] = address(msg.sender)
    mem[(32 * uint8(maxNumber + 1)) + 552] = var15001
    if uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var15001) % maxNumber) != 0:
        require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var15001) % maxNumber) < uint8(maxNumber + 1)
        if mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var15001) % maxNumber)) + 479 len 1] != 1:
            require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var15001) % maxNumber) < uint8(maxNumber + 1)
            mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var15001) % maxNumber)) + 448] = 1
            mem[224] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var15001) % maxNumber)
    var15001 = var15001 + 1
    var15004 = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, var15001) % maxNumber
    continue 
}



}
