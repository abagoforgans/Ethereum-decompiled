contract main {




// =====================  Runtime code  =====================


#
#  - sub_00ecc94a(?)
#
const _fallback = sha3(sha3(sha3(Mask(160, 96, '404-method-not-found') >> 96)))


address stor0;
address stor1;
address stor2;
address stor3;

function sub_b26920a8(?) {
    require calldata.size - 4 >= 96
    require msg.sender == stor0
    stor1 = arg1
    stor2 = arg2
    stor3 = arg3
}

function sub_f0983b61(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 384
    require ('cd', 4).length < 6
    require ('cd', 4)[10] <= test266151307()
    require cd[4] + ('cd', 4)[10] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[10] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 >= 480 and ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 <= test266151307()
    require cd[4] + ('cd', 4)[10] + cd[(cd[4] + ('cd', 4)[10] + 4)] + 36 <= calldata.size
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 544] = address(('cd', 4)[1])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 564] = address(('cd', 4)[3])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 584] = ('cd', 4)[7]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 616] = address(('cd', 4)[9])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512] = 92
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 636] = sha3(mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 544 len Mask(8 * -ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + cd[(cd[4] + ('cd', 4)[10] + 4)] + 32, 0, 0), mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 544 len -cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)])]])
    return memory
      from ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 636
       len 32
}

function sub_e9d30707(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 384
    require ('cd', 4).length < 6
    require ('cd', 4)[10] <= test266151307()
    require cd[4] + ('cd', 4)[10] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[10] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 >= 480 and ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 <= test266151307()
    require cd[4] + ('cd', 4)[10] + cd[(cd[4] + ('cd', 4)[10] + 4)] + 36 <= calldata.size
    mem[512 len cd[(cd[4] + ('cd', 4)[10] + 4)]] = call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512] = 0
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512] = 0
    require ('cd', 4).length < 6
    return 32, ('cd', 4).length, 
           sha3(address(('cd', 4)[1]), address(('cd', 4)[3]), ('cd', 4)[7], address(('cd', 4)[9])),
           address(('cd', 4)[1]),
           address(('cd', 4)[2]),
           address(('cd', 4)[3]),
           address(('cd', 4)[4]),
           ('cd', 4)[5],
           ('cd', 4)[6],
           ('cd', 4)[7],
           ('cd', 4)[8],
           address(('cd', 4)[9]),
           384,
           cd[(cd[4] + ('cd', 4)[10] + 4)],
           call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]],
           mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512 len ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) - cd[(cd[4] + ('cd', 4)[10] + 4)]]
}

function sub_044bcc3a(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 384
    require ('cd', 4).length < 6
    require ('cd', 4)[10] <= test266151307()
    require cd[4] + ('cd', 4)[10] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[10] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 >= 480 and ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 <= test266151307()
    require cd[4] + ('cd', 4)[10] + cd[(cd[4] + ('cd', 4)[10] + 4)] + 36 <= calldata.size
    mem[512 len cd[(cd[4] + ('cd', 4)[10] + 4)]] = call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512] = 0
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 544] = address(('cd', 4)[1])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 564] = address(('cd', 4)[3])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 584] = ('cd', 4)[7]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 616] = address(('cd', 4)[9])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512] = 92
    require ('cd', 4).length < 6
    return sha3(uint8(('cd', 4).length), sha3(mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 544 len Mask(8 * -ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + cd[(cd[4] + ('cd', 4)[10] + 4)] + 32, 0, 0), mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 544 len -cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)])]]), address(('cd', 4)[1]), address(('cd', 4)[2]), address(('cd', 4)[3]), address(('cd', 4)[4]), ('cd', 4)[5], ('cd', 4)[6], ('cd', 4)[7], ('cd', 4)[8], address(('cd', 4)[9]), Mask(8 * cd[(cd[4] + ('cd', 4)[10] + 4)], -(8 * cd[(cd[4] + ('cd', 4)[10] + 4)]) + 256, call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]], mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512 len ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) - cd[(cd[4] + ('cd', 4)[10] + 4)]]) << (8 * cd[(cd[4] + ('cd', 4)[10] + 4)]) - 256)
}

function sub_e9a010ad(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 192
    require ('cd', 4).length < 6
    require ('cd', 4)[4] <= test266151307()
    require cd[4] + ('cd', 4)[4] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[4] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320 >= 288 and ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320 <= test266151307()
    require cd[4] + ('cd', 4)[4] + cd[(cd[4] + ('cd', 4)[4] + 4)] + 36 <= calldata.size
    mem[320 len cd[(cd[4] + ('cd', 4)[4] + 4)]] = call.data[cd[4] + ('cd', 4)[4] + 36 len cd[(cd[4] + ('cd', 4)[4] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 320] = 0
    require ('cd', 4).length < 6
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 352] = ('cd', 4).length << 248
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 353] = ('cd', 4)[0]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 385] = ('cd', 4)[1]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 417] = ('cd', 4)[2]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 449] = ('cd', 4)[3]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 481 len ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)])] = call.data[cd[4] + ('cd', 4)[4] + 36 len cd[(cd[4] + ('cd', 4)[4] + 4)]], mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 320 len ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) - cd[(cd[4] + ('cd', 4)[4] + 4)]]
    if ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) > cd[(cd[4] + ('cd', 4)[4] + 4)]:
        mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 481] = 0
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320] = cd[(cd[4] + ('cd', 4)[4] + 4)] + 129
    mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 513] = sha3(mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 352 len Mask(8 * -ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + cd[(cd[4] + ('cd', 4)[4] + 4)] + 32, 0, 0), mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 352 len -cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)])]])
    return 32, 32, mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 513]
}

function sub_e772317d(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 192
    require ('cd', 4).length < 6
    require ('cd', 4)[4] <= test266151307()
    require cd[4] + ('cd', 4)[4] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[4] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320 >= 288 and ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320 <= test266151307()
    require cd[4] + ('cd', 4)[4] + cd[(cd[4] + ('cd', 4)[4] + 4)] + 36 <= calldata.size
    mem[320 len cd[(cd[4] + ('cd', 4)[4] + 4)]] = call.data[cd[4] + ('cd', 4)[4] + 36 len cd[(cd[4] + ('cd', 4)[4] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 320] = 0
    require ('cd', 4).length < 6
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 352] = ('cd', 4).length << 248
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 353] = ('cd', 4)[0]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 385] = ('cd', 4)[1]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 417] = ('cd', 4)[2]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 449] = ('cd', 4)[3]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 481 len ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)])] = call.data[cd[4] + ('cd', 4)[4] + 36 len cd[(cd[4] + ('cd', 4)[4] + 4)]], mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 320 len ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) - cd[(cd[4] + ('cd', 4)[4] + 4)]]
    if ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) > cd[(cd[4] + ('cd', 4)[4] + 4)]:
        mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 481] = 0
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320] = cd[(cd[4] + ('cd', 4)[4] + 4)] + 129
    mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 481] = sha3(mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 352 len Mask(8 * -ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + cd[(cd[4] + ('cd', 4)[4] + 4)] + 32, 0, 0), mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 352 len -cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)])]])
    return memory
      from cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 481
       len 32
}

function sub_7f6cc692(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 256
    require ('cd', 4).length < 6
    require ('cd', 4)[6] <= test266151307()
    require cd[4] + ('cd', 4)[6] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[6] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384 >= 352 and ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384 <= test266151307()
    require cd[4] + ('cd', 4)[6] + cd[(cd[4] + ('cd', 4)[6] + 4)] + 36 <= calldata.size
    mem[384 len cd[(cd[4] + ('cd', 4)[6] + 4)]] = call.data[cd[4] + ('cd', 4)[6] + 36 len cd[(cd[4] + ('cd', 4)[6] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 384] = 0
    require ('cd', 4).length < 6
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 416] = ('cd', 4).length << 248
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 417] = ('cd', 4)[0]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 449] = ('cd', 4)[1]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 481] = ('cd', 4)[2]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 513] = ('cd', 4)[3]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 545] = ('cd', 4)[4]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 577] = ('cd', 4)[5]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 609 len ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)])] = call.data[cd[4] + ('cd', 4)[6] + 36 len cd[(cd[4] + ('cd', 4)[6] + 4)]], mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 384 len ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) - cd[(cd[4] + ('cd', 4)[6] + 4)]]
    if ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) > cd[(cd[4] + ('cd', 4)[6] + 4)]:
        mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 609] = 0
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384] = cd[(cd[4] + ('cd', 4)[6] + 4)] + 193
    mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 609] = sha3(mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 416 len Mask(8 * -ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + cd[(cd[4] + ('cd', 4)[6] + 4)] + 32, 0, 0), mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 416 len -cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)])]])
    return memory
      from cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 609
       len 32
}

function sub_c0764e7a(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 384
    require ('cd', 4).length < 6
    require ('cd', 4)[10] <= test266151307()
    require cd[4] + ('cd', 4)[10] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[10] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 >= 480 and ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 <= test266151307()
    require cd[4] + ('cd', 4)[10] + cd[(cd[4] + ('cd', 4)[10] + 4)] + 36 <= calldata.size
    mem[512 len cd[(cd[4] + ('cd', 4)[10] + 4)]] = call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512] = 0
    require ('cd', 4).length < 6
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 544] = ('cd', 4).length << 248
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 545] = ('cd', 4)[0]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 577] = address(('cd', 4)[1])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 597] = address(('cd', 4)[2])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 617] = address(('cd', 4)[3])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 637] = address(('cd', 4)[4])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 657] = ('cd', 4)[5]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 689] = ('cd', 4)[6]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 721] = ('cd', 4)[7]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 753] = ('cd', 4)[8]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 785] = address(('cd', 4)[9])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 805 len ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)])] = call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]], mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512 len ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) - cd[(cd[4] + ('cd', 4)[10] + 4)]]
    if ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) > cd[(cd[4] + ('cd', 4)[10] + 4)]:
        mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 805] = 0
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512] = cd[(cd[4] + ('cd', 4)[10] + 4)] + 261
    mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 805] = sha3(mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 544 len Mask(8 * -ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + cd[(cd[4] + ('cd', 4)[10] + 4)] + 32, 0, 0), mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 544 len -cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)])]])
    return memory
      from cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 805
       len 32
}

function sub_7d4d3ac2(?) {
    require calldata.size - 4 >= 160
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 384
    require ('cd', 4).length < 6
    require ('cd', 4)[10] <= test266151307()
    require cd[4] + ('cd', 4)[10] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[10] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 >= 480 and ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512 <= test266151307()
    require cd[4] + ('cd', 4)[10] + cd[(cd[4] + ('cd', 4)[10] + 4)] + 36 <= calldata.size
    mem[512 len cd[(cd[4] + ('cd', 4)[10] + 4)]] = call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512] = 0
    require calldata.size - 36 >= 96
    require bool(ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 608 <= test266151307())
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 512] = uint8(cd[36])
    if ('cd', 4)[0] != sha3(address(('cd', 4)[1]), address(('cd', 4)[3]), ('cd', 4)[7], address(('cd', 4)[9])):
        return 101
    require ('cd', 4).length <= 5
    if ('cd', 4).length != 1:
        return 102
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 732] = address(('cd', 4)[1])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 764] = address(('cd', 4)[3])
    require ('cd', 4).length < 6
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 1089 len ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)])] = call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]], mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512 len ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) - cd[(cd[4] + ('cd', 4)[10] + 4)]]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 796] = cd[(cd[4] + ('cd', 4)[10] + 4)] + 261
    mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 1089] = 0x29aa9a5000000000000000000000000000000000000000000000000000000000
    idx = 0
    s = ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 732
    t = cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 1093
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(stor2)
    staticcall stor2.mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 1089 len 4] with:
            gas gas_remaining wei
           args mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) + 1093 len 64], sha3(uint8(('cd', 4).length), ('cd', 4)[0], address(('cd', 4)[1]), address(('cd', 4)[2]), address(('cd', 4)[3]), address(('cd', 4)[4]), ('cd', 4)[5], ('cd', 4)[6], ('cd', 4)[7], ('cd', 4)[8], address(('cd', 4)[9]), Mask(8 * cd[(cd[4] + ('cd', 4)[10] + 4)], -(8 * cd[(cd[4] + ('cd', 4)[10] + 4)]) + 256, call.data[cd[4] + ('cd', 4)[10] + 36 len cd[(cd[4] + ('cd', 4)[10] + 4)]], mem[cd[(cd[4] + ('cd', 4)[10] + 4)] + 512 len ceil32(cd[(cd[4] + ('cd', 4)[10] + 4)]) - cd[(cd[4] + ('cd', 4)[10] + 4)]]) << (8 * cd[(cd[4] + ('cd', 4)[10] + 4)]) - 256), 0, cd[68], cd[100], address(cd[132])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        return 0
    return 103
}

function sub_416b79f8(?) {
    require calldata.size - 4 >= 192
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 192
    require ('cd', 4).length < 6
    require ('cd', 4)[4] <= test266151307()
    require cd[4] + ('cd', 4)[4] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[4] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320 >= 288 and ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320 <= test266151307()
    require cd[4] + ('cd', 4)[4] + cd[(cd[4] + ('cd', 4)[4] + 4)] + 36 <= calldata.size
    mem[320 len cd[(cd[4] + ('cd', 4)[4] + 4)]] = call.data[cd[4] + ('cd', 4)[4] + 36 len cd[(cd[4] + ('cd', 4)[4] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 320] = 0
    require calldata.size - 36 >= 96
    require bool(ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 416 <= test266151307())
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 320] = uint8(cd[36])
    require cd[132] <= test266151307()
    require calldata.size + -cd[132] - 4 >= 544
    require bool(ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 960 <= test266151307())
    require ('cd', 132).length < 4
    require ('cd', 132)[15] <= test266151307()
    require cd[132] + ('cd', 132)[15] + 35 < calldata.size
    require cd[(cd[132] + ('cd', 132)[15] + 4)] <= test266151307()
    require ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 992 >= 960 and ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 992 <= test266151307()
    require cd[132] + ('cd', 132)[15] + cd[(cd[132] + ('cd', 132)[15] + 4)] + 36 <= calldata.size
    mem[cd[(cd[132] + ('cd', 132)[15] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + 992] = 0
    require ('cd', 4).length <= 5
    if ('cd', 4).length != 4:
        mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 992] = 107
        return Mask(8 * -ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + cd[(cd[132] + ('cd', 132)[15] + 4)] + 32, 0, 0), 
               mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + cd[(cd[132] + ('cd', 132)[15] + 4)] + 1024 len -cd[(cd[132] + ('cd', 132)[15] + 4)] + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)])]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 992] = address(('cd', 132)[1])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 1024] = address(('cd', 132)[2])
    require ('cd', 4).length < 6
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 1217 len ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)])] = call.data[cd[4] + ('cd', 4)[4] + 36 len cd[(cd[4] + ('cd', 4)[4] + 4)]], mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 320 len ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) - cd[(cd[4] + ('cd', 4)[4] + 4)]]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 1056] = cd[(cd[4] + ('cd', 4)[4] + 4)] + 129
    mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 1217] = 0x1ee64dd800000000000000000000000000000000000000000000000000000000
    idx = 0
    s = ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 992
    t = cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 1221
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(stor2)
    staticcall stor2.mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 1217 len 4] with:
            gas gas_remaining wei
           args mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + 1221 len 64], sha3(uint8(('cd', 4).length), ('cd', 4)[0], ('cd', 4)[1], ('cd', 4)[2], ('cd', 4)[3], Mask(8 * cd[(cd[4] + ('cd', 4)[4] + 4)], -(8 * cd[(cd[4] + ('cd', 4)[4] + 4)]) + 256, call.data[cd[4] + ('cd', 4)[4] + 36 len cd[(cd[4] + ('cd', 4)[4] + 4)]], mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 320 len ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) - cd[(cd[4] + ('cd', 4)[4] + 4)]]) << (8 * cd[(cd[4] + ('cd', 4)[4] + 4)]) - 256), 0, cd[68], cd[100]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        return 108
    require ('cd', 4).length < 6
    if ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) > cd[(cd[4] + ('cd', 4)[4] + 4)]:
        mem[(2 * cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) + ceil32(cd[(cd[132] + ('cd', 132)[15] + 4)]) + ceil32(return_data.size) + 1477] = 0
    require ext_code.size(address(cd[164]))
    staticcall address(cd[164]).0xe9895338 with:
            gas gas_remaining wei
           args 32, ('cd', 4).length, ('cd', 4)[0], ('cd', 4)[1], ('cd', 4)[2], ('cd', 4)[3], 192, cd[(cd[4] + ('cd', 4)[4] + 4)], call.data[cd[4] + ('cd', 4)[4] + 36 len cd[(cd[4] + ('cd', 4)[4] + 4)]], mem[cd[(cd[4] + ('cd', 4)[4] + 4)] + 320 len ceil32(cd[(cd[4] + ('cd', 4)[4] + 4)]) - cd[(cd[4] + ('cd', 4)[4] + 4)]]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_04bcf0dd(?) {
    require calldata.size - 4 >= 192
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 256
    require ('cd', 4).length < 6
    require ('cd', 4)[6] <= test266151307()
    require cd[4] + ('cd', 4)[6] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[6] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384 >= 352 and ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384 <= test266151307()
    require cd[4] + ('cd', 4)[6] + cd[(cd[4] + ('cd', 4)[6] + 4)] + 36 <= calldata.size
    mem[384 len cd[(cd[4] + ('cd', 4)[6] + 4)]] = call.data[cd[4] + ('cd', 4)[6] + 36 len cd[(cd[4] + ('cd', 4)[6] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 384] = 0
    require calldata.size - 36 >= 96
    require bool(ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 480 <= test266151307())
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384] = uint8(cd[36])
    require cd[164] <= test266151307()
    require calldata.size + -cd[164] - 4 >= 544
    require bool(ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 1024 <= test266151307())
    require ('cd', 164).length < 4
    require ('cd', 164)[15] <= test266151307()
    require cd[164] + ('cd', 164)[15] + 35 < calldata.size
    require cd[(cd[164] + ('cd', 164)[15] + 4)] <= test266151307()
    require ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056 >= 1024 and ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056 <= test266151307()
    require cd[164] + ('cd', 164)[15] + cd[(cd[164] + ('cd', 164)[15] + 4)] + 36 <= calldata.size
    mem[cd[(cd[164] + ('cd', 164)[15] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 1056] = 0
    require ('cd', 4).length <= 5
    if ('cd', 4).length != 2:
        mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056] = 104
        return Mask(8 * -ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 32, 0, 0), 
               mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 1088 len -cd[(cd[164] + ('cd', 164)[15] + 4)] + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)])]
    require ('cd', 164)[6] + ('cd', 164)[5] >= ('cd', 164)[5]
    require ('cd', 4)[2] + ('cd', 4)[1] >= ('cd', 4)[1]
    if ('cd', 4)[2] + ('cd', 4)[1] != ('cd', 164)[6] + ('cd', 164)[5]:
        mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056] = 105
        return Mask(8 * -ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 32, 0, 0), 
               mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 1088 len -cd[(cd[164] + ('cd', 164)[15] + 4)] + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)])]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056] = address(('cd', 164)[1])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1088] = address(('cd', 164)[2])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1120] = address(('cd', 164)[3])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1152] = address(('cd', 164)[4])
    require ('cd', 4).length < 6
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1409 len ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)])] = call.data[cd[4] + ('cd', 4)[6] + 36 len cd[(cd[4] + ('cd', 4)[6] + 4)]], mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 384 len ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) - cd[(cd[4] + ('cd', 4)[6] + 4)]]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1184] = cd[(cd[4] + ('cd', 4)[6] + 4)] + 193
    mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1409] = 0xd17897ec00000000000000000000000000000000000000000000000000000000
    idx = 0
    s = ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056
    t = cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1413
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    s = ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1120
    t = cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1477
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(stor2)
    staticcall stor2.mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1409 len 4] with:
            gas gas_remaining wei
           args mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1413 len 128], sha3(uint8(('cd', 4).length), ('cd', 4)[0], ('cd', 4)[1], ('cd', 4)[2], ('cd', 4)[3], ('cd', 4)[4], ('cd', 4)[5], Mask(8 * cd[(cd[4] + ('cd', 4)[6] + 4)], -(8 * cd[(cd[4] + ('cd', 4)[6] + 4)]) + 256, call.data[cd[4] + ('cd', 4)[6] + 36 len cd[(cd[4] + ('cd', 4)[6] + 4)]], mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 384 len ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) - cd[(cd[4] + ('cd', 4)[6] + 4)]]) << (8 * cd[(cd[4] + ('cd', 4)[6] + 4)]) - 256), 0, cd[68], cd[100], address(cd[132])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        return 0
    return 106
}

function sub_8ae9fcfe(?) {
    require calldata.size - 4 >= 192
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 256
    require ('cd', 4).length < 6
    require ('cd', 4)[6] <= test266151307()
    require cd[4] + ('cd', 4)[6] + 35 < calldata.size
    require cd[(cd[4] + ('cd', 4)[6] + 4)] <= test266151307()
    require ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384 >= 352 and ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384 <= test266151307()
    require cd[4] + ('cd', 4)[6] + cd[(cd[4] + ('cd', 4)[6] + 4)] + 36 <= calldata.size
    mem[384 len cd[(cd[4] + ('cd', 4)[6] + 4)]] = call.data[cd[4] + ('cd', 4)[6] + 36 len cd[(cd[4] + ('cd', 4)[6] + 4)]]
    mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 384] = 0
    require calldata.size - 36 >= 96
    require bool(ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 480 <= test266151307())
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 384] = uint8(cd[36])
    require cd[164] <= test266151307()
    require calldata.size + -cd[164] - 4 >= 544
    require bool(ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 1024 <= test266151307())
    require ('cd', 164).length < 4
    require ('cd', 164)[15] <= test266151307()
    require cd[164] + ('cd', 164)[15] + 35 < calldata.size
    require cd[(cd[164] + ('cd', 164)[15] + 4)] <= test266151307()
    require ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056 >= 1024 and ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056 <= test266151307()
    require cd[164] + ('cd', 164)[15] + cd[(cd[164] + ('cd', 164)[15] + 4)] + 36 <= calldata.size
    mem[cd[(cd[164] + ('cd', 164)[15] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + 1056] = 0
    require ('cd', 4).length <= 5
    if ('cd', 4).length != 3:
        mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056] = 114
        return Mask(8 * -ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 32, 0, 0), 
               mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 1088 len -cd[(cd[164] + ('cd', 164)[15] + 4)] + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)])]
    require ('cd', 164)[6] + ('cd', 164)[5] >= ('cd', 164)[5]
    require ('cd', 4)[2] + ('cd', 4)[1] >= ('cd', 4)[1]
    if ('cd', 4)[2] + ('cd', 4)[1] != ('cd', 164)[6] + ('cd', 164)[5]:
        mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056] = 115
        return Mask(8 * -ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 32, 0, 0), 
               mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 1088 len -cd[(cd[164] + ('cd', 164)[15] + 4)] + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)])]
    if ('cd', 4)[5] < ('cd', 164)[11]:
        mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056] = 116
        return Mask(8 * -ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 32, 0, 0), 
               mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + cd[(cd[164] + ('cd', 164)[15] + 4)] + 1088 len -cd[(cd[164] + ('cd', 164)[15] + 4)] + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)])]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056] = address(('cd', 164)[1])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1088] = address(('cd', 164)[2])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1120] = address(('cd', 164)[3])
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1152] = address(('cd', 164)[4])
    require ('cd', 4).length < 6
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1409 len ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)])] = call.data[cd[4] + ('cd', 4)[6] + 36 len cd[(cd[4] + ('cd', 4)[6] + 4)]], mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 384 len ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) - cd[(cd[4] + ('cd', 4)[6] + 4)]]
    mem[ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1184] = cd[(cd[4] + ('cd', 4)[6] + 4)] + 193
    mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1409] = 0xd17897ec00000000000000000000000000000000000000000000000000000000
    idx = 0
    s = ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1056
    t = cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1413
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    s = ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1120
    t = cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1477
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(stor2)
    staticcall stor2.mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1409 len 4] with:
            gas gas_remaining wei
           args mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) + ceil32(cd[(cd[164] + ('cd', 164)[15] + 4)]) + 1413 len 128], sha3(uint8(('cd', 4).length), ('cd', 4)[0], ('cd', 4)[1], ('cd', 4)[2], ('cd', 4)[3], ('cd', 4)[4], ('cd', 4)[5], Mask(8 * cd[(cd[4] + ('cd', 4)[6] + 4)], -(8 * cd[(cd[4] + ('cd', 4)[6] + 4)]) + 256, call.data[cd[4] + ('cd', 4)[6] + 36 len cd[(cd[4] + ('cd', 4)[6] + 4)]], mem[cd[(cd[4] + ('cd', 4)[6] + 4)] + 384 len ceil32(cd[(cd[4] + ('cd', 4)[6] + 4)]) - cd[(cd[4] + ('cd', 4)[6] + 4)]]) << (8 * cd[(cd[4] + ('cd', 4)[6] + 4)]) - 256), 0, cd[68], cd[100], address(cd[132])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        return 0
    return 117
}



}
