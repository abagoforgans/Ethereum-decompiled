contract main {


// =======================  Init code  ======================


uint8 stor0; offset 160
uint256 stor0;
uint256 stor1;
uint256 stor2;
uint256 stor3;
array of struct stor7;
uint256 stor8;
uint256 stor9;
array of uint256 stor10;
uint256 stor11;
uint256 stor12;
uint256 stor13;
uint256 stor14;
uint256 stor15;
uint256 stor16;
uint256 stor17;
uint256 stor18;
uint256 stor19;
uint8 stor20;
uint256 stor21;
uint256 stor22;
uint8 stor23;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint256 storC65A;
uint8 storC65A;
uint256 storC65A;
uint256 storC65A;
uint8 storC65A;

function _fallback() payable {
    uint8(stor0.field_160) = 16
    stor1 = 1800
    stor2 = 300
    stor3 = 10^16
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    stor7.length = 1
    if not stor7.length <= 1:
        idx = 2
        while 2 * stor7.length > idx:
            address(stor7[idx].field_0) = 0
            uint256(stor7[idx].field_256) = 0
            idx = idx + 2
            continue 
    stor8 = 50
    stor9 = 10 * 10^18
    stor10.length = 1
    if not stor10.length <= 1:
        mem[0] = 10
        idx = 13
        while sha3(10) + (13 * stor10.length) > idx + sha3(mem[0]):
            uint256(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            uint256(stor[idx + sha3(mem[0]) + 3]) = 0
            uint256(stor[idx + sha3(mem[0]) + 4]) = 0
            uint256(stor[idx + sha3(mem[0]) + 5]) = 0
            uint256(stor[idx + sha3(mem[0]) + 6]) = 0
            uint256(stor[idx + sha3(mem[0]) + 7]) = 0
            uint256(stor[idx + sha3(mem[0]) + 8]) = 0
            mem[0] = idx + sha3(mem[0]) + 8
            s = sha3(s + sha3(mem[0]) + 8)
            while sha3(s + sha3(mem[0]) + 8) + (uint256(stor[s + sha3(mem[0]) + 8]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint8(stor[s + sha3(mem[0]) + 9]) = 0
            uint256(stor[s + sha3(mem[0]) + 10]) = 0
            uint256(stor[s + sha3(mem[0]) + 11]) = 0
            uint8(stor[s + sha3(mem[0]) + 12]) = 0
            s = s + 13
            continue 
    require 0 < stor10.length
    stor11 = stor10
    stor12 = storC65A
    stor13 = storC65A
    stor14 = storC65A
    stor15 = storC65A
    stor16 = storC65A
    stor17 = storC65A
    stor18 = storC65A
    stor19 = storC65A
    if not storC65A:
        idx = 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        while (stor19 + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090 > idx:
            uint8(stor[idx]) = 0
            idx = idx + 1
            continue 
    else:
        s = 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        idx = sha3(0xc65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2b0)
        while sha3(0xc65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2b0) + (storC65A + 31 / 32) > idx:
            uint256(stor[s]) = uint256(stor[idx])
            s = s + 1
            idx = idx + 1
            continue 
        idx = (storC65A + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090
        while (stor19 + 31 / 32) + 0x66de8ffda797e3de9c05e8fc57b3bf0ec28a930d40b0d285d93c06501cf6a090 > idx:
            uint8(stor[idx]) = 0
            idx = idx + 1
            continue 
    stor20 = storC65A
    stor21 = storC65A
    stor22 = storC65A
    stor23 = storC65A
    stor22 = block.timestamp
    stor23 = 0
    stor11 = 0
    return code.data[1013 len 7298]
}



// =====================  Runtime code  =====================


#
#  - draw()
#
const N = 6


uint8 maxNumber; offset 160
uint128 stor0; offset 160
address stor0;
uint256 stor0;
array of uint256 stor1;
array of uint256 stor2;
array of uint8 stor3;
mapping of address stor5;
mapping of uint256 sub_6a52dfdb;
array of struct stor7;
uint256 sub_fa06c38a;
uint256 sub_d7a58a87;
array of uint256 stor10;
uint256 stor11;
uint256 stor12;
uint256 stor13;
uint256 stor14;
uint256 stor15;
uint256 stor16;
uint256 stor17;
uint256 stor18;
bool stor20; offset 256
uint8 stor20;
uint256 stor21;
uint256 stor22;
uint8 stor23;
uint256 stor24;
uint256 stor25;
uint256 stor26;
uint256 stor27;
uint256 stor28;
uint256 stor29;
uint256 stor30;
uint256 stor31;
uint8 stor33;
uint256 stor34;
uint256 stor35;
uint8 stor36;
array of uint256 description;
array of uint8 stor39143100329280468107556231533410151018419134684842411016866935372961967991761;
array of uint256 stor62514009886607029107290561805838585334079798074568712924583230797734656856477;
array of uint256 stor70402538955001568223061751915610164204544900569080421535842365952732583900870;
array of address stor71709625427275648070435571067103625102151317872053819652964380875187535702993;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726057;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726058;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726059;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726060;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726061;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726062;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726063;
array of uint8 stor89717814153306320011181716697424560163256864414616650038987186496166826726065;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726066;
array of uint256 stor89717814153306320011181716697424560163256864414616650038987186496166826726067;
array of uint8 stor89717814153306320011181716697424560163256864414616650038987186496166826726068;

function ticketPrice() payable {
    return stor3.length
}

function sub_27ecc221(?) payable {
    return stor2.length
}

function maxNumber() payable {
    return maxNumber
}

function sub_6a52dfdb(?) payable {
    return sub_6a52dfdb[arg1]
}

function description() payable {
    return description[0 len description.length]
}

function sub_ae466313(?) payable {
    return stor1.length
}

function sub_d7a58a87(?) payable {
    return sub_d7a58a87
}

function sub_fa06c38a(?) payable {
    return sub_fa06c38a
}

function _fallback() payable {
    stor13 += msg.value
}

function sub_0db35d8c(?) payable {
    require msg.sender == address(stor0.field_0)
    sub_fa06c38a = arg2
    sub_d7a58a87 = 10^18 * arg1
}

function sub_766fc3ef(?) payable {
    require msg.sender == address(stor0.field_0)
    description[] = Array(len=arg1.length, data=arg1[all])
}

function sub_d9ddb179(?) payable {
    return stor24, stor25, stor26, stor27, stor28, stor29, stor30, stor31, stor33, stor34, stor35, bool(stor36)
}

function sub_80322dd5(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 >= 10^15
    stor3.length = arg1
    stor21 = arg1
}

function sub_60b663bb(?) payable {
    return stor11, stor12, stor13, stor14, stor15, stor16, stor17, stor18, uint8(stor20.field_0), stor21, stor22, bool(stor23)
}

function transferOwnership(address arg1) payable {
    require address(stor0.field_0) == msg.sender
    uint256(stor0.field_0) = arg1 or Mask(96, 160, uint256(stor0.field_0))
}

function tickets(uint256 arg1) payable {
    require arg1 < stor4.length
    return stor9E8A[arg1], stor8A35[arg1], stor568A[arg1], uint256(stor[(5 * arg1) + code.data[7266 len 32]])
}

function sub_b28c7c25(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 > 6
    Mask(96, 0, stor0.field_160) = Mask(96, 0, arg1)
    uint8(stor20.field_0) = arg1
    stor20.field_256 % 1 = 0
}

function sub_236af88c(?) payable {
    require not address(stor5[address(msg.sender)])
    require sub_6a52dfdb[address(arg1)]
    uint256(stor5[address(msg.sender)]) = arg1 or Mask(96, 160, uint256(stor5[address(msg.sender)]))
}

function games(uint256 arg1) payable {
    require arg1 < stor10.length
    return stor10[arg1], 
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           storC65A[arg1],
           bool(storC65A[arg1])
}

function sub_d2a8bcf5(?) payable {
    require sub_fa06c38a > 0
    require msg.value >= sub_d7a58a87
    stor7.length++
    if not stor7.length <= stor7.length + 1:
        idx = 2 * stor7.length + 1
        while 2 * stor7.length > idx:
            address(stor7[idx].field_0) = 0
            uint256(stor7[idx].field_256) = 0
            idx = idx + 2
            continue 
    require stor7.length - 1 < stor7.length
    uint256(stor7[stor7.length - 1].field_0) = msg.sender or Mask(96, 160, uint256(stor7[stor7.length - 1].field_0))
    sub_6a52dfdb[address(msg.sender)] = stor7.length - 1
    sub_fa06c38a--
    call address(stor0.field_0) with:
       value msg.value wei
         gas 0 wei
    if not ext_call.success:
        stor13 += msg.value
}

function sub_612c10bf(?) payable {
    mem[96] = arg1.length
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    require arg1.length == 6
    require maxNumber == arg2
    require msg.value >= stor3.length
    require bool(stor23) != 1
    require block.timestamp <= stor22 + stor1.length - stor2.length
    require block.timestamp >= stor22 + stor2.length
    mem[(32 * arg1.length) + 128] = 0
    s = 0
    t = 0
    idx = 0
    while uint8(idx) < 5:
        u = s
        t = idx + 1
        while uint8(t) < 6:
            require uint8(t) < arg1.length
            require uint8(idx) < arg1.length
            if mem[(32 * uint8(idx)) + 159 len 1] <= mem[(32 * uint8(t)) + 159 len 1]:
                u = u
                t = t + 1
                continue 
            require uint8(idx) < arg1.length
            _47 = mem[(32 * uint8(idx)) + 128]
            require uint8(t) < arg1.length
            require uint8(idx) < arg1.length
            mem[(32 * uint8(idx)) + 128] = mem[(32 * uint8(t)) + 159 len 1]
            require uint8(t) < arg1.length
            mem[(32 * uint8(t)) + 128] = uint8(_47)
            u = _47
            t = t + 1
            continue 
        s = u
        t = t
        idx = idx + 1
        continue 
    s = 0
    idx = 0
    s = 0
    while uint8(idx) < 6:
        require uint8(idx) < arg1.length
        require mem[(32 * uint8(idx)) + 159 len 1] >= 1
        require mem[(32 * uint8(idx)) + 159 len 1] <= maxNumber
        require mem[(32 * uint8(idx)) + 159 len 1] > uint8(s)
        s = mem[(32 * uint8(idx)) + 128]
        idx = idx + 1
        s = mem[(32 * uint8(idx)) + 128]
        continue 
    stor4.length++
    if not stor4.length <= stor4.length + 1:
        mem[0] = 4
        idx = (5 * stor4.length) + 5
        while sha3(4) + (5 * stor4.length) > idx + sha3(mem[0]):
            address(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            mem[0] = idx + sha3(mem[0]) + 1
            s = sha3(s + sha3(mem[0]) + 1)
            while sha3(s + sha3(mem[0]) + 1) + (uint256(stor[s + sha3(mem[0]) + 1]) + 31 / 32) > s + sha3(mem[0]):
                uint256(stor[s + sha3(mem[0])]) = 0
                s = s + 1
                continue 
            uint256(stor[s + sha3(mem[0]) + 2]) = 0
            uint8(stor[s + sha3(mem[0]) + 3]) = 0
            uint256(stor[s + sha3(mem[0]) + 4]) = 0
            s = s + 5
            continue 
    stor15++
    require stor15 < stor4.length
    uint256(stor4[stor15].field_512) = msg.value / stor3.length
    uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
    uint256(stor4[stor15].field_256) = 6
    if not uint256(stor4[stor15].field_256) <= 6:
        idx = 1
        while uint256(stor4[stor15].field_256) + 31 / 32 > idx:
            uint256(stor[idx + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = 0
            idx = idx + 1
            continue 
    idx = 0
    while uint8(idx) < 6:
        require uint8(idx) < arg1.length
        require uint8(idx) < uint256(stor4[stor15].field_256)
        mem[0] = (5 * stor15) + sha3(4) + 1
        uint256(stor[(uint8(idx) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(idx)) + 128] * 256^(idx % 32) or !(255 * 256^(idx % 32)) and uint256(stor[(uint8(idx) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
        idx = idx + 1
        continue 
    stor16 += uint256(stor4[stor15].field_512)
    stor14 += msg.value
    stor13 += 85 * msg.value / 100
    stor17 += 5 * msg.value / 100
    stor18 += 10 * msg.value / 100
    if address(stor5[address(msg.sender)]) != 0:
        require sub_6a52dfdb[address(stor5[address(msg.sender)])] < stor7.length
        stor9BA6[stor6[address(stor5[address(msg.sender)])]] += 5 * msg.value / 100
}

function sub_d7264f6c(?) payable {
    mem[64] = 128
    mem[96] = 0
    require msg.value >= arg1 * stor3.length
    s = 96
    idx = 0
    while idx < arg1:
        _491 = mem[64]
        mem[64] = mem[64] + 32
        mem[_491] = 0
        _492 = mem[64]
        mem[64] = mem[64] + 32
        mem[_492] = 0
        _493 = mem[64]
        if msize < mem[64]:
            mem[mem[64]] = uint8(maxNumber + 1)
            mem[64] = mem[64] + (32 * uint8(maxNumber + 1)) + 32
            s = 0
            t = 0
            u = 0
            while s < 123456789:
                mem[mem[64]] = block.difficulty
                mem[mem[64] + 32] = address(block.coinbase)
                mem[mem[64] + 52] = block.timestamp
                mem[mem[64] + 84] = address(msg.sender)
                mem[mem[64] + 104] = s
                if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber):
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_493]
                if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + _493 + 63 len 1]:
                    s = s + 1
                    t = t
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber) < mem[_493]
                mem[_493 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)) + 32] = 1
                require uint8(t) < mem[_491]
                mem[_491 + (32 * uint8(t)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber)
                if uint8(t + 1) != 6:
                    s = s + 1
                    t = t + 1
                    u = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, s) % maxNumber
                    continue 
                _551 = mem[64]
                mem[64] = mem[64] + 32
                mem[_551] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_491]
                        require uint8(s) < mem[_491]
                        if mem[(32 * uint8(s)) + _491 + 63 len 1] <= mem[(32 * uint8(idx)) + _491 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_491]
                        _772 = mem[(32 * uint8(s)) + _491 + 32]
                        require uint8(idx) < mem[_491]
                        require uint8(s) < mem[_491]
                        mem[_491 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _491 + 63 len 1]
                        require uint8(idx) < mem[_491]
                        mem[_491 + (32 * uint8(idx)) + 32] = uint8(_772)
                        u = _772
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                require mem[_491] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require bool(stor23) != 1
                require block.timestamp <= stor22 + stor1.length - stor2.length
                require block.timestamp >= stor22 + stor2.length
                _718 = mem[64]
                mem[64] = mem[64] + 32
                mem[_718] = 0
                t = 0
                u = 0
                s = 0
                while uint8(s) < 5:
                    u = t
                    idx = s + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_491]
                        require uint8(s) < mem[_491]
                        if mem[(32 * uint8(s)) + _491 + 63 len 1] <= mem[(32 * uint8(idx)) + _491 + 63 len 1]:
                            u = u
                            idx = idx + 1
                            continue 
                        require uint8(s) < mem[_491]
                        _925 = mem[(32 * uint8(s)) + _491 + 32]
                        require uint8(idx) < mem[_491]
                        require uint8(s) < mem[_491]
                        mem[_491 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _491 + 63 len 1]
                        require uint8(idx) < mem[_491]
                        mem[_491 + (32 * uint8(idx)) + 32] = uint8(_925)
                        u = _925
                        idx = idx + 1
                        continue 
                    t = u
                    u = idx
                    s = s + 1
                    continue 
                t = 0
                s = 0
                t = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_491]
                    require mem[(32 * uint8(s)) + _491 + 63 len 1] >= 1
                    require mem[(32 * uint8(s)) + _491 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(s)) + _491 + 63 len 1] > uint8(t)
                    t = mem[(32 * uint8(s)) + _491 + 32]
                    s = s + 1
                    t = mem[(32 * uint8(s)) + _491 + 32]
                    continue 
                stor4.length++
                if not stor4.length <= stor4.length + 1:
                    mem[0] = 4
                    s = sha3(mem[0]) + (5 * stor4.length) + 5
                    while sha3(4) + (5 * stor4.length) > s:
                        address(stor[s]) = 0
                        stor1[s] = 0
                        mem[0] = s + 1
                        t = sha3(t + 1)
                        while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                            uint256(stor[t]) = 0
                            t = t + 1
                            continue 
                        stor2[t] = 0
                        stor3[t] = 0
                        uint256(stor4[t].field_0) = 0
                        t = t + 5
                        continue 
                stor15++
                require stor15 < stor4.length
                mem[0] = 4
                uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
                uint256(stor4[stor15].field_256) = 6
                if not uint256(stor4[stor15].field_256) <= 6:
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    s = sha3((5 * stor15) + sha3(4) + 1) + 1
                    while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                s = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_491]
                    require uint8(s) < uint256(stor4[stor15].field_256)
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _491 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                    s = s + 1
                    continue 
                stor16 += uint256(stor4[stor15].field_512)
                s = _491
                idx = idx + 1
                continue 
            _520 = mem[64]
            mem[64] = mem[64] + 32
            mem[_520] = 0
            t = 0
            v = 0
            u = 0
            while uint8(u) < 5:
                s = t
                idx = u + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_491]
                    require uint8(u) < mem[_491]
                    if mem[(32 * uint8(u)) + _491 + 63 len 1] <= mem[(32 * uint8(idx)) + _491 + 63 len 1]:
                        s = s
                        idx = idx + 1
                        continue 
                    require uint8(u) < mem[_491]
                    _686 = mem[(32 * uint8(u)) + _491 + 32]
                    require uint8(idx) < mem[_491]
                    require uint8(u) < mem[_491]
                    mem[_491 + (32 * uint8(u)) + 32] = mem[(32 * uint8(idx)) + _491 + 63 len 1]
                    require uint8(idx) < mem[_491]
                    mem[_491 + (32 * uint8(idx)) + 32] = uint8(_686)
                    s = _686
                    idx = idx + 1
                    continue 
                t = s
                v = idx
                u = u + 1
                continue 
            require mem[_491] == 6
            require maxNumber == maxNumber
            require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
            require bool(stor23) != 1
            require block.timestamp <= stor22 + stor1.length - stor2.length
            require block.timestamp >= stor22 + stor2.length
            _634 = mem[64]
            mem[64] = mem[64] + 32
            mem[_634] = 0
            t = 0
            u = 0
            s = 0
            while uint8(s) < 5:
                u = t
                idx = s + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_491]
                    require uint8(s) < mem[_491]
                    if mem[(32 * uint8(s)) + _491 + 63 len 1] <= mem[(32 * uint8(idx)) + _491 + 63 len 1]:
                        u = u
                        idx = idx + 1
                        continue 
                    require uint8(s) < mem[_491]
                    _834 = mem[(32 * uint8(s)) + _491 + 32]
                    require uint8(idx) < mem[_491]
                    require uint8(s) < mem[_491]
                    mem[_491 + (32 * uint8(s)) + 32] = mem[(32 * uint8(idx)) + _491 + 63 len 1]
                    require uint8(idx) < mem[_491]
                    mem[_491 + (32 * uint8(idx)) + 32] = uint8(_834)
                    u = _834
                    idx = idx + 1
                    continue 
                t = u
                u = idx
                s = s + 1
                continue 
            t = 0
            s = 0
            t = 0
            while uint8(s) < 6:
                require uint8(s) < mem[_491]
                require mem[(32 * uint8(s)) + _491 + 63 len 1] >= 1
                require mem[(32 * uint8(s)) + _491 + 63 len 1] <= maxNumber
                require mem[(32 * uint8(s)) + _491 + 63 len 1] > uint8(t)
                t = mem[(32 * uint8(s)) + _491 + 32]
                s = s + 1
                t = mem[(32 * uint8(s)) + _491 + 32]
                continue 
            stor4.length++
            if not stor4.length <= stor4.length + 1:
                mem[0] = 4
                s = sha3(mem[0]) + (5 * stor4.length) + 5
                while sha3(4) + (5 * stor4.length) > s:
                    address(stor[s]) = 0
                    stor1[s] = 0
                    mem[0] = s + 1
                    t = sha3(t + 1)
                    while sha3(t + 1) + (stor1[t] + 31 / 32) > t:
                        uint256(stor[t]) = 0
                        t = t + 1
                        continue 
                    stor2[t] = 0
                    stor3[t] = 0
                    uint256(stor4[t].field_0) = 0
                    t = t + 5
                    continue 
        else:
            _497 = msize
            mem[msize] = uint8(maxNumber + 1)
            mem[64] = _497 + (32 * uint8(maxNumber + 1)) + 32
            t = 0
            u = 0
            v = 0
            while t < 123456789:
                mem[mem[64]] = block.difficulty
                mem[mem[64] + 32] = address(block.coinbase)
                mem[mem[64] + 52] = block.timestamp
                mem[mem[64] + 84] = address(msg.sender)
                mem[mem[64] + 104] = t
                if 0 == uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber):
                    t = t + 1
                    u = u
                    v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber) < mem[_497]
                if 1 == mem[(32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)) + _497 + 63 len 1]:
                    t = t + 1
                    u = u
                    v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                    continue 
                require uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber) < mem[_497]
                mem[_497 + (32 * uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)) + 32] = 1
                require uint8(u) < mem[_491]
                mem[_491 + (32 * uint8(u)) + 32] = uint8(sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber)
                if uint8(u + 1) != 6:
                    t = t + 1
                    u = u + 1
                    v = sha3(block.difficulty, block.coinbase, block.timestamp, msg.sender, t) % maxNumber
                    continue 
                _553 = mem[64]
                mem[64] = mem[64] + 32
                mem[_553] = 0
                u = 0
                v = 0
                t = 0
                while uint8(t) < 5:
                    s = u
                    idx = t + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_491]
                        require uint8(t) < mem[_491]
                        if mem[(32 * uint8(t)) + _491 + 63 len 1] <= mem[(32 * uint8(idx)) + _491 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(t) < mem[_491]
                        _778 = mem[(32 * uint8(t)) + _491 + 32]
                        require uint8(idx) < mem[_491]
                        require uint8(t) < mem[_491]
                        mem[_491 + (32 * uint8(t)) + 32] = mem[(32 * uint8(idx)) + _491 + 63 len 1]
                        require uint8(idx) < mem[_491]
                        mem[_491 + (32 * uint8(idx)) + 32] = uint8(_778)
                        s = _778
                        idx = idx + 1
                        continue 
                    u = s
                    v = idx
                    t = t + 1
                    continue 
                require mem[_491] == 6
                require maxNumber == maxNumber
                require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
                require bool(stor23) != 1
                require block.timestamp <= stor22 + stor1.length - stor2.length
                require block.timestamp >= stor22 + stor2.length
                _719 = mem[64]
                mem[64] = mem[64] + 32
                mem[_719] = 0
                u = 0
                v = 0
                t = 0
                while uint8(t) < 5:
                    s = u
                    idx = t + 1
                    while uint8(idx) < 6:
                        require uint8(idx) < mem[_491]
                        require uint8(t) < mem[_491]
                        if mem[(32 * uint8(t)) + _491 + 63 len 1] <= mem[(32 * uint8(idx)) + _491 + 63 len 1]:
                            s = s
                            idx = idx + 1
                            continue 
                        require uint8(t) < mem[_491]
                        _928 = mem[(32 * uint8(t)) + _491 + 32]
                        require uint8(idx) < mem[_491]
                        require uint8(t) < mem[_491]
                        mem[_491 + (32 * uint8(t)) + 32] = mem[(32 * uint8(idx)) + _491 + 63 len 1]
                        require uint8(idx) < mem[_491]
                        mem[_491 + (32 * uint8(idx)) + 32] = uint8(_928)
                        s = _928
                        idx = idx + 1
                        continue 
                    u = s
                    v = idx
                    t = t + 1
                    continue 
                s = 0
                idx = 0
                s = 0
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_491]
                    require mem[(32 * uint8(idx)) + _491 + 63 len 1] >= 1
                    require mem[(32 * uint8(idx)) + _491 + 63 len 1] <= maxNumber
                    require mem[(32 * uint8(idx)) + _491 + 63 len 1] > uint8(s)
                    s = mem[(32 * uint8(idx)) + _491 + 32]
                    idx = idx + 1
                    s = mem[(32 * uint8(idx)) + _491 + 32]
                    continue 
                stor4.length++
                if not stor4.length <= stor4.length + 1:
                    mem[0] = 4
                    idx = sha3(mem[0]) + (5 * stor4.length) + 5
                    while sha3(4) + (5 * stor4.length) > idx:
                        address(stor[idx]) = 0
                        stor1[idx] = 0
                        mem[0] = idx + 1
                        s = sha3(s + 1)
                        while sha3(s + 1) + (stor1[s] + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        stor2[s] = 0
                        stor3[s] = 0
                        uint256(stor4[s].field_0) = 0
                        s = s + 5
                        continue 
                stor15++
                require stor15 < stor4.length
                mem[0] = 4
                uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
                uint256(stor4[stor15].field_256) = 6
                if not uint256(stor4[stor15].field_256) <= 6:
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    idx = sha3((5 * stor15) + sha3(4) + 1) + 1
                    while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > idx:
                        uint256(stor[idx]) = 0
                        idx = idx + 1
                        continue 
                idx = 0
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_491]
                    require uint8(idx) < uint256(stor4[stor15].field_256)
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    uint256(stor[(uint8(idx) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(idx)) + _491 + 32] * 256^(idx % 32) or !(255 * 256^(idx % 32)) and uint256(stor[(uint8(idx) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                    idx = idx + 1
                    continue 
                stor16 += uint256(stor4[stor15].field_512)
                u = _491
                v = v + 1
                continue 
            _522 = mem[64]
            mem[64] = mem[64] + 32
            mem[_522] = 0
            u = 0
            w = 0
            v = 0
            while uint8(v) < 5:
                s = u
                idx = v + 1
                while uint8(idx) < 6:
                    require uint8(idx) < mem[_491]
                    require uint8(v) < mem[_491]
                    if mem[(32 * uint8(v)) + _491 + 63 len 1] <= mem[(32 * uint8(idx)) + _491 + 63 len 1]:
                        s = s
                        idx = idx + 1
                        continue 
                    require uint8(v) < mem[_491]
                    _691 = mem[(32 * uint8(v)) + _491 + 32]
                    require uint8(idx) < mem[_491]
                    require uint8(v) < mem[_491]
                    mem[_491 + (32 * uint8(v)) + 32] = mem[(32 * uint8(idx)) + _491 + 63 len 1]
                    require uint8(idx) < mem[_491]
                    mem[_491 + (32 * uint8(idx)) + 32] = uint8(_691)
                    s = _691
                    idx = idx + 1
                    continue 
                u = s
                w = idx
                v = v + 1
                continue 
            require mem[_491] == 6
            require maxNumber == maxNumber
            require msg.value / arg1 * stor3.length * stor3.length >= stor3.length
            require bool(stor23) != 1
            require block.timestamp <= stor22 + stor1.length - stor2.length
            require block.timestamp >= stor22 + stor2.length
            _635 = mem[64]
            mem[64] = mem[64] + 32
            mem[_635] = 0
            u = 0
            v = 0
            t = 0
            while uint8(t) < 5:
                w = u
                v = t + 1
                while uint8(v) < 6:
                    require uint8(v) < mem[_491]
                    require uint8(t) < mem[_491]
                    if mem[(32 * uint8(t)) + _491 + 63 len 1] <= mem[(32 * uint8(v)) + _491 + 63 len 1]:
                        w = w
                        v = v + 1
                        continue 
                    require uint8(t) < mem[_491]
                    _838 = mem[(32 * uint8(t)) + _491 + 32]
                    require uint8(v) < mem[_491]
                    require uint8(t) < mem[_491]
                    mem[_491 + (32 * uint8(t)) + 32] = mem[(32 * uint8(v)) + _491 + 63 len 1]
                    require uint8(v) < mem[_491]
                    mem[_491 + (32 * uint8(v)) + 32] = uint8(_838)
                    w = _838
                    v = v + 1
                    continue 
                u = w
                v = v
                t = t + 1
                continue 
            u = 0
            t = 0
            u = 0
            while uint8(t) < 6:
                require uint8(t) < mem[_491]
                require mem[(32 * uint8(t)) + _491 + 63 len 1] >= 1
                require mem[(32 * uint8(t)) + _491 + 63 len 1] <= maxNumber
                require mem[(32 * uint8(t)) + _491 + 63 len 1] > uint8(u)
                u = mem[(32 * uint8(t)) + _491 + 32]
                t = t + 1
                u = mem[(32 * uint8(t)) + _491 + 32]
                continue 
            stor4.length++
            if not stor4.length > stor4.length + 1:
                stor15++
                require stor15 < stor4.length
                mem[0] = 4
                uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
                uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
                uint256(stor4[stor15].field_256) = 6
                if not uint256(stor4[stor15].field_256) <= 6:
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    s = sha3((5 * stor15) + sha3(4) + 1) + 1
                    while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                s = 0
                while uint8(s) < 6:
                    require uint8(s) < mem[_491]
                    require uint8(s) < uint256(stor4[stor15].field_256)
                    mem[0] = (5 * stor15) + sha3(4) + 1
                    uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _491 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
                    s = s + 1
                    continue 
                stor16 += uint256(stor4[stor15].field_512)
                s = _491
                idx = idx + 1
                continue 
            mem[0] = 4
            t = sha3(mem[0]) + (5 * stor4.length) + 5
            while sha3(4) + (5 * stor4.length) > t:
                address(stor[t]) = 0
                stor1[t] = 0
                mem[0] = t + 1
                s = sha3(s + 1)
                while sha3(s + 1) + (stor1[s] + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
                stor2[s] = 0
                stor3[s] = 0
                uint256(stor4[s].field_0) = 0
                s = s + 5
                continue 
        stor15++
        require stor15 < stor4.length
        mem[0] = 4
        uint256(stor4[stor15].field_512) = msg.value / arg1 * stor3.length * stor3.length / stor3.length
        uint256(stor4[stor15].field_0) = msg.sender or Mask(96, 160, uint256(stor4[stor15].field_0))
        uint256(stor4[stor15].field_256) = 6
        if not uint256(stor4[stor15].field_256) <= 6:
            mem[0] = (5 * stor15) + sha3(4) + 1
            s = sha3((5 * stor15) + sha3(4) + 1) + 1
            while sha3((5 * stor15) + sha3(4) + 1) + (uint256(stor4[stor15].field_256) + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
        s = 0
        while uint8(s) < 6:
            require uint8(s) < mem[_491]
            require uint8(s) < uint256(stor4[stor15].field_256)
            mem[0] = (5 * stor15) + sha3(4) + 1
            uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0) = mem[(32 * uint8(s)) + _491 + 32] * 256^(s % 32) or !(255 * 256^(s % 32)) and uint256(stor[(uint8(s) / 32) + sha3((5 * stor15) + ('name', 'stor4', 4) + 1)].field_0)
            s = s + 1
            continue 
        stor16 += uint256(stor4[stor15].field_512)
        t = _491
        idx = idx + 1
        continue 
    stor14 += msg.value
    stor13 += 85 * msg.value / 100
    stor17 += 5 * msg.value / 100
    stor18 += 10 * msg.value / 100
    if address(stor5[address(msg.sender)]) != 0:
        require sub_6a52dfdb[address(stor5[address(msg.sender)])] < stor7.length
        stor9BA6[stor6[address(stor5[address(msg.sender)])]] += 5 * msg.value / 100
}



}
