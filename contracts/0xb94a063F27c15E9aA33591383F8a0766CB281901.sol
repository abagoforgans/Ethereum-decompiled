contract main {


// =======================  Init code  ======================


const _fallback = code.data[30 len 3038]




// =====================  Runtime code  =====================


#
#  - sub_05db737f(?)
#
array of uint256 stor2;
array of struct stor3;
array of uint256 stor5;

function _fallback() payable {
    revert
}

function sub_aeaedb20(?) payable {
    uint256(stor[arg1 + 4][address(msg.sender)].field_0) = 0
    call msg.sender with:
       value uint256(stor[arg1 + 4][address(msg.sender)].field_0) wei
         gas 2300 * is_zero(value) wei
}

function sub_687fe185(?) payable {
    require uint256(stor[arg1 + 6][address(msg.sender)].field_0) > 0
    require uint256(stor[arg1 + 6][address(msg.sender)].field_0) - 1 < stor5[arg1]
    Mask(216, 0, stor[(4 * uint256(stor[arg1 + 6][address(msg.sender)].field_0) - 1) + sha3(arg1 + 5) + 3].field_40) = Mask(216, 0, not arg2)
}

function sub_7d85a304(?) payable {
    require ext_code.size(address(stor[arg1].field_0))
    call address(stor[arg1].field_0).0x8da5cb5b with:
         gas gas_remaining - 710 wei
    require ext_call.success
    require ext_call.return_data[12 len 20] == msg.sender
    require arg2 < stor5[arg1]
    Mask(224, 0, stor[(4 * uint32(arg2)) + sha3(arg1 + 5) + 3].field_32) = Mask(224, 0, arg3)
}

function sub_25a6204a(?) payable {
    require ext_code.size(address(stor[arg1].field_0))
    call address(stor[arg1].field_0).0x8da5cb5b with:
         gas gas_remaining - 710 wei
    require ext_call.success
    require ext_call.return_data[12 len 20] == msg.sender
    uint256(stor[sha3(arg1 + 1)][].field_0) = Array(len=arg2.length, data=arg2[all])
    stor2[arg1] = arg3
    uint32(stor3[arg1].field_0) = arg4
    Mask(224, 0, stor3[arg1].field_32) = Mask(224, 0, arg5)
}

function sub_43156529(?) payable {
    require stor2[arg1]
    if uint32(stor3[arg1].field_0) <= 0:
        if not stor2[arg1]:
            if arg2 >= uint32(arg2 / stor2[arg1]) * stor2[arg1]:
                if arg2 >= arg2 - (uint32(arg2 / stor2[arg1]) * stor2[arg1]):
                    return arg2 / stor2[arg1] << 224, uint32(arg2 / stor2[arg1]) * stor2[arg1], arg2 - (uint32(arg2 / stor2[arg1]) * stor2[arg1])
        else:
            if stor2[arg1]:
                if uint32(arg2 / stor2[arg1]) * stor2[arg1] / stor2[arg1] == uint32(arg2 / stor2[arg1]):
                    if arg2 >= uint32(arg2 / stor2[arg1]) * stor2[arg1]:
                        if arg2 >= arg2 - (uint32(arg2 / stor2[arg1]) * stor2[arg1]):
                            return arg2 / stor2[arg1] << 224, uint32(arg2 / stor2[arg1]) * stor2[arg1], arg2 - (uint32(arg2 / stor2[arg1]) * stor2[arg1])
    else:
        if uint32((arg2 / stor2[arg1]) + uint32(stor3[arg1].field_40)) <= uint32(stor3[arg1].field_0):
            if not stor2[arg1]:
                if arg2 >= uint32(arg2 / stor2[arg1]) * stor2[arg1]:
                    if arg2 >= arg2 - (uint32(arg2 / stor2[arg1]) * stor2[arg1]):
                        return arg2 / stor2[arg1] << 224, uint32(arg2 / stor2[arg1]) * stor2[arg1], arg2 - (uint32(arg2 / stor2[arg1]) * stor2[arg1])
            else:
                if stor2[arg1]:
                    if uint32(arg2 / stor2[arg1]) * stor2[arg1] / stor2[arg1] == uint32(arg2 / stor2[arg1]):
                        if arg2 >= uint32(arg2 / stor2[arg1]) * stor2[arg1]:
                            if arg2 >= arg2 - (uint32(arg2 / stor2[arg1]) * stor2[arg1]):
                                return arg2 / stor2[arg1] << 224, uint32(arg2 / stor2[arg1]) * stor2[arg1], arg2 - (uint32(arg2 / stor2[arg1]) * stor2[arg1])
        else:
            if not arg3:
                if not stor2[arg1]:
                    if arg2 >= 0:
                        if arg2 >= arg2:
                            return 0, 0, arg2
                else:
                    if stor2[arg1]:
                        if not 0 / stor2[arg1]:
                            if arg2 >= 0:
                                if arg2 >= arg2:
                                    return 0, 0, arg2
            else:
                if not stor2[arg1]:
                    if arg2 >= uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1]:
                        if arg2 >= arg2 - (uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1]):
                            return uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40) << 224, 
                                   uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1],
                                   arg2 - (uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1])
                else:
                    if stor2[arg1]:
                        if uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1] / stor2[arg1] == uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)):
                            if arg2 >= uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1]:
                                if arg2 >= arg2 - (uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1]):
                                    return uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40) << 224, 
                                           uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1],
                                           arg2 - (uint32(uint32(stor3[arg1].field_0) - uint32(stor3[arg1].field_40)) * stor2[arg1])
    revert
}



}
