contract main {


// =======================  Init code  ======================


uint8 stor0; offset 160
uint256 stor0;
uint256 stor1;
uint256 stor2;
uint256 stor3;
uint256 stor7;
uint256 stor8;
array of struct stor10;
uint256 stor11;
array of uint256 stor12;
uint8 storDF69;
uint256 storDF69;
uint256 storDF69;

function _fallback() payable {
    uint8(stor0.field_160) = 16
    stor1 = 900
    stor2 = 180
    stor3 = 10^16
    stor7 = 50
    stor8 = 2 * 10^16
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    stor10.length = 1
    if not stor10.length <= 1:
        idx = 2
        while 2 * stor10.length > idx:
            address(stor10[idx].field_0) = 0
            uint256(stor10[idx].field_256) = 0
            idx = idx + 2
            continue 
    stor12.length = 1
    if not stor12.length <= 1:
        mem[0] = 12
        idx = 15
        while sha3(12) + (15 * stor12.length) > idx + sha3(mem[0]):
            uint256(stor[idx + sha3(mem[0])]) = 0
            uint256(stor[idx + sha3(mem[0]) + 1]) = 0
            uint256(stor[idx + sha3(mem[0]) + 2]) = 0
            uint256(stor[idx + sha3(mem[0]) + 3]) = 0
            uint256(stor[idx + sha3(mem[0]) + 4]) = 0
            uint256(stor[idx + sha3(mem[0]) + 5]) = 0
            uint256(stor[idx + sha3(mem[0]) + 6]) = 0
            uint256(stor[idx + sha3(mem[0]) + 7]) = 0
            uint256(stor[idx + sha3(mem[0]) + 8]) = 0
            mem[0] = idx + sha3(mem[0]) + 8
            s = sha3(idx + sha3(mem[0]) + 8)
            while sha3(idx + sha3(mem[0]) + 8) + (uint256(stor[idx + sha3(mem[0]) + 8]) + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
            uint256(stor[idx + sha3(mem[0]) + 9]) = 0
            if 31 < stor[idx + sha3(mem[0]) + 9].length:
                mem[0] = idx + sha3(mem[0]) + 9
                s = sha3(idx + sha3(mem[0]) + 9)
                while sha3(idx + sha3(mem[0]) + 9) + (stor[idx + sha3(mem[0]) + 9].length + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
            uint8(stor[idx + sha3(mem[0]) + 10]) = 0
            uint256(stor[idx + sha3(mem[0]) + 11]) = 0
            uint256(stor[idx + sha3(mem[0]) + 12]) = 0
            uint256(stor[idx + sha3(mem[0]) + 13]) = 0
            uint256(stor[idx + sha3(mem[0]) + 14]) = 0
            idx = idx + 15
            continue 
    stor11 = 0
    require 0 < stor12.length
    storDF69 = block.timestamp
    stor12 = 0
    storDF69 = stor3
    storDF69 = uint8(stor0.field_160)
    return code.data[707 len 15380]
}



// =====================  Runtime code  =====================


#
#  - sub_d44b75ff(?)
#
const N = 6


uint8 maxNumber; offset 160
uint128 stor0; offset 160
address stor0;
uint256 stor0;
uint256 sub_ae466313;
uint256 sub_27ecc221;
uint256 ticketPrice;
array of uint256 description;
uint256 numTickets;
array of uint256 sub_6de769f3;
uint256 sub_fa06c38a;
uint256 sub_d7a58a87;
mapping of uint256 sub_6a52dfdb;
array of struct stor10;
uint256 gameID;
uint256 stor12;
array of struct sub_3963ef83;
uint256 stor14;
uint256 numPlayers;
mapping of struct players;
array of struct sub_44d855f1;
array of uint256 stor39249365189697262212649556357205408732595607600233223271220075824908968655314;
array of uint256 stor76383292911929570351855712120526694787215725815043447318800596511708409558184;
array of uint256 stor76835605760512836740229036280716881927267561692643605772079727699239320220840;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896574;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896575;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896576;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896577;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896578;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896579;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896580;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896581;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896582;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896583;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896584;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896585;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896586;
array of uint256 stor90341508186318815664823735350012552759840342637429673805233737881817932243139;
array of uint256 stor91309616915177361168175409406802870408926309775848676277011925700228461425832;
array of uint256 stor92666555460927160333295381887373431829081817408649151636849319262821193413800;
array of uint256 stor93118868309510426721668706047563618969133653286249310090128450450352104076456;
array of uint256 stor96285058249593291440281975168894928949496504429450419263082368763068478715048;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386058;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386059;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386062;
array of struct stor101051993584849178915136821395265346177868384823507754984078593667947067386065;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386066;
array of uint256 stor101051993584849178915136821395265346177868384823507754984078593667947067386069;
array of uint256 stor114785610903102749070994691108966661121252199159459684968834984142571049318866;

function ticketPrice() payable {
    return ticketPrice
}

function sub_27ecc221(?) payable {
    return sub_27ecc221
}

function numTickets() payable {
    return numTickets
}

function sub_3963ef83(?) payable {
    require arg2 < sub_3963ef83[arg1].field_0
    mem[544] = stor[sha3((14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 7)].field_0
    idx = 544
    s = 0
    while stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 7].length + 544 > idx + 32:
        mem[idx + 32] = stor[s + sha3((14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 7)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return sub_3963ef83[arg1][arg2].field_0, 
           sub_3963ef83[arg1][arg2].field_256,
           sub_3963ef83[arg1][arg2].field_512,
           address(sub_3963ef83[arg1][arg2].field_768),
           sub_3963ef83[arg1][arg2].field_1024,
           sub_3963ef83[arg1][arg2].field_1280,
           Array(len=stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 7].length, data=mem[544 len stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 7].length + (floor32(stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 7].length - 1) + -stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_3963ef83', 13)) + 7].length + 32 % 32)]),
           sub_3963ef83[arg1][arg2].field_2048,
           uint8(sub_3963ef83[arg1][arg2].field_2304),
           sub_3963ef83[arg1][arg2].field_2560,
           bool(uint8(sub_3963ef83[arg1][arg2].field_2816)),
           sub_3963ef83[arg1][arg2].field_3072,
           sub_3963ef83[arg1][arg2].field_3328
}

function maxNumber() payable {
    return maxNumber
}

function sub_44d855f1(?) payable {
    require arg2 < sub_44d855f1[arg1].field_0
    mem[544] = stor[sha3((14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 17)) + 7)].field_0
    idx = 544
    s = 0
    while stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 17)) + 7].length + 544 > idx + 32:
        mem[idx + 32] = stor[s + sha3((14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 17)) + 7)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return sub_44d855f1[arg1][arg2].field_0, 
           sub_44d855f1[arg1][arg2].field_256,
           sub_44d855f1[arg1][arg2].field_512,
           address(sub_44d855f1[arg1][arg2].field_768),
           sub_44d855f1[arg1][arg2].field_1024,
           sub_44d855f1[arg1][arg2].field_1280,
           Array(len=stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 17)) + 7].length, data=mem[544 len stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 17)) + 7].length + (floor32(stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 17)) + 7].length - 1) + -stor[(14 * arg2) + ('map', ('param', 'arg1'), ('name', 'sub_44d855f1', 17)) + 7].length + 32 % 32)]),
           sub_44d855f1[arg1][arg2].field_2048,
           uint8(sub_44d855f1[arg1][arg2].field_2304),
           sub_44d855f1[arg1][arg2].field_2560,
           bool(uint8(sub_44d855f1[arg1][arg2].field_2816)),
           sub_44d855f1[arg1][arg2].field_3072,
           sub_44d855f1[arg1][arg2].field_3328
}

function sub_6a52dfdb(?) payable {
    return sub_6a52dfdb[arg1]
}

function sub_6de769f3(?) payable {
    return sub_6de769f3[0 len sub_6de769f3.length]
}

function description() payable {
    return description[0 len description.length]
}

function numPlayers() payable {
    return numPlayers
}

function sub_ae466313(?) payable {
    return sub_ae466313
}

function gameID() payable {
    return gameID
}

function sub_d7a58a87(?) payable {
    return sub_d7a58a87
}

function players(address arg1) payable {
    return players[arg1].field_0, 
           address(players[arg1].field_256),
           players[arg1].field_512,
           players[arg1].field_768,
           players[arg1].field_1024,
           players[arg1].field_1280
}

function sub_fa06c38a(?) payable {
    return sub_fa06c38a
}

function kill() payable {
    require msg.sender == address(stor0.field_0)
    selfdestruct(address(stor0.field_0))
}

function sub_2631cea8(?) payable {
    require msg.sender == address(stor0.field_0)
    require msg.value > 0
}

function _fallback() payable {
    require gameID < stor12
    storD4DF[stor11] += msg.value
    storDF69[stor11] += msg.value
}

function sub_0db35d8c(?) payable {
    require msg.sender == address(stor0.field_0)
    sub_fa06c38a = arg2
    sub_d7a58a87 = 10^18 * arg1
}

function sub_766fc3ef(?) payable {
    require msg.sender == address(stor0.field_0)
    description[] = Array(len=arg1.length, data=arg1[all])
}

function transferOwnership(address arg1) payable {
    require address(stor0.field_0) == msg.sender
    uint256(stor0.field_0) = arg1 or Mask(96, 160, uint256(stor0.field_0))
}

function sub_80322dd5(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 >= 10^15
    ticketPrice = arg1
    require gameID < stor12
    storDF69[stor11] = arg1
}

function sub_236af88c(?) payable {
    require not players[address(msg.sender)].field_512
    require sub_6a52dfdb[address(arg1)]
    players[address(msg.sender)].field_512 = sub_6a52dfdb[address(arg1)]
}

function sub_b28c7c25(?) payable {
    require msg.sender == address(stor0.field_0)
    require arg1 > 6
    require arg1 > maxNumber
    Mask(96, 0, stor0.field_160) = Mask(96, 0, arg1)
    require gameID < stor12
    uint8(storDF69[stor11].field_0) = arg1
    storDF69[stor11].field_256 % 1 = 0
}

function sub_25496b5c(?) payable {
    require arg1 < stor14
    return storC7BB[arg1], 
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1],
           storBB7B[arg1]
}

function sub_d2a8bcf5(?) payable {
    require sub_fa06c38a > 0
    require msg.value >= sub_d7a58a87
    require sub_6a52dfdb[address(msg.sender)] <= 0
    stor10.length++
    if not stor10.length <= stor10.length + 1:
        idx = 2 * stor10.length + 1
        while 2 * stor10.length > idx:
            address(stor10[idx].field_0) = 0
            stor10[idx].field_256 = 0
            idx = idx + 2
            continue 
    require stor10.length - 1 < stor10.length
    storFDC6[stor10.length - 1] = msg.sender or Mask(96, 160, storFDC6[stor10.length - 1])
    sub_6a52dfdb[address(msg.sender)] = stor10.length - 1
    sub_fa06c38a--
    call address(stor0.field_0) with:
       value msg.value wei
         gas 0 wei
    if not ext_call.success:
        require gameID < stor12
        storD4DF[stor11] += msg.value
}

function games(uint256 arg1) payable {
    require arg1 < stor12
    mem[576] = stor[sha3((15 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730)]
    idx = 576
    s = 0
    while stor[(15 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length + 576 > idx + 32:
        mem[idx + 32] = stor[s + sha3((15 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730) + 1]
        idx = idx + 32
        s = s + 1
        continue 
    return storA9DF[arg1], 
           storC9DF[arg1],
           storD4DF[arg1],
           storDF69[arg1],
           storDF69[arg1],
           storA8DF[arg1],
           storCCDF[arg1],
           storDF69[arg1],
           Array(len=stor[(15 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length, data=mem[576 len stor[(15 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length + (floor32(stor[(15 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length - 1) + -stor[(15 * arg1) - 0x209699368efae3c2ab13a6e9d9f9aceb6c5aebfb5ffd7bd0a9ff6281a30b5730].length + 32 % 32)]),
           uint8(storDF69[arg1].field_0),
           storDF69[arg1],
           stor[(15 * arg1) + code.data[15348 len 32]],
           storCDDF[arg1],
           storDF69[arg1]
}

function draw() payable {
    mem[96] = 0
    require gameID < stor12
    require block.timestamp >= stor[code.data[15348 len 32] + (15 * stor11)] + sub_ae466313
    require gameID < stor12
    require storCDDF[stor11] <= 0
    require gameID < stor12
    mem[0] = 12
    storCDDF[stor11] = block.timestamp
    mem[128] = 0
    mem[160] = 0
    mem[192] = 6
    mem[416] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 448
    mem[(32 * uint8(maxNumber + 1)) + 448] = block.difficulty
    mem[(32 * uint8(maxNumber + 1)) + 480] = address(block.coinbase)
    mem[(32 * uint8(maxNumber + 1)) + 500] = numTickets
    mem[(32 * uint8(maxNumber + 1)) + 532] = block.timestamp
    mem[(32 * uint8(maxNumber + 1)) + 564] = address(msg.sender)
    mem[(32 * uint8(maxNumber + 1)) + 584] = var17001
    if uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var17001) % uint8(maxNumber + 1)):
        require uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var17001) % uint8(maxNumber + 1)) < uint8(maxNumber + 1)
        if mem[(32 * uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var17001) % uint8(maxNumber + 1))) + 479 len 1] != 1:
            require uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var17001) % uint8(maxNumber + 1)) < uint8(maxNumber + 1)
            mem[(32 * uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var17001) % uint8(maxNumber + 1))) + 448] = 1
            mem[224] = uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var17001) % uint8(maxNumber + 1))
    var17001 = var17001 + 1
    var17004 = sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var17001) % uint8(maxNumber + 1)
    continue 
}

function sub_0cda01b0(?) payable {
    mem[96] = 0
    require msg.value >= arg1 * ticketPrice
    if 0 >= arg1:
        require gameID < stor12
        storDF69[stor11] += msg.value
        storD4DF[stor11] += 80 * msg.value / 100
        storCCDF[stor11] += 5 * msg.value / 100
        if 0 == players[address(msg.sender)].field_512:
            require gameID < stor12
            storD4DF[stor11] += 15 * msg.value / 100
        else:
            require players[address(msg.sender)].field_512 < stor10.length
            stor56C6[stor16[address(msg.sender)].field_512] += 15 * msg.value / 100
            require gameID < stor12
            storDF69[stor11] += 15 * msg.value / 100
    mem[128] = 0
    mem[160] = 0
    mem[192] = 6
    mem[416] = uint8(maxNumber + 1)
    mem[64] = (32 * uint8(maxNumber + 1)) + 448
    mem[(32 * uint8(maxNumber + 1)) + 448] = block.difficulty
    mem[(32 * uint8(maxNumber + 1)) + 480] = address(block.coinbase)
    mem[(32 * uint8(maxNumber + 1)) + 500] = numTickets
    mem[(32 * uint8(maxNumber + 1)) + 532] = block.timestamp
    mem[(32 * uint8(maxNumber + 1)) + 564] = address(msg.sender)
    mem[(32 * uint8(maxNumber + 1)) + 584] = var15001
    if uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1)):
        require uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1)) < uint8(maxNumber + 1)
        if mem[(32 * uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1))) + 479 len 1] != 1:
            require uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1)) < uint8(maxNumber + 1)
            mem[(32 * uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1))) + 448] = 1
            mem[224] = uint8(sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1))
    var15001 = var15001 + 1
    var15004 = sha3(block.difficulty, block.coinbase, numTickets, block.timestamp, msg.sender, var15001) % uint8(maxNumber + 1)
    continue 
}



}
