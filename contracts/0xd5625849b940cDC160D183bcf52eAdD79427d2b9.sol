contract main {


// =======================  Init code  ======================


uint256 stor1;

function _fallback() payable {
    stor1 = 0
    return code.data[26 len 1523]
}



// =====================  Runtime code  =====================


uint256 stor0;
uint256 sub_5e02eb7d;
mapping of uint256 stor2;
array of uint256 stor18569430475105882587588266137607568536673111973893317399460219858819262702949;

function sub_5e02eb7d(?) payable {
    return sub_5e02eb7d
}

function test() payable {
    call msg.sender with:
       value eth.balance(this.address) wei
         gas 0 wei
}

function sqrt(uint256 arg1) payable {
    if arg1 > stor0:
        return 0
    require arg1 < stor0
    return stor290D[arg1]
}

function changeName(string arg1) payable {
    if stor2[address(msg.sender)] != 0:
        require stor2[address(msg.sender)] < stor0
        uint256(stor[sha3(code.data[1491 len 32] + (3 * stor2[address(msg.sender)]) + 1)][].field_0) = Array(len=arg1.length, data=arg1[all])
}

function sub_f26f09aa(?) payable {
    require arg1 < stor0
    mem[224] = uint256(stor[sha3((3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564)].field_0)
    idx = 224
    s = 0
    while stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length + 224 > idx + 32:
        mem[idx + 32] = uint256(stor[s + sha3((3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564) + 1].field_0)
        idx = idx + 32
        s = s + 1
        continue 
    return address(stor[(3 * arg1) + code.data[1491 len 32]].field_0), 
           Array(len=stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length, data=mem[224 len stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length + (floor32(stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length - 1) + -stor[(3 * arg1) + 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564].length + 32 % 32)]),
           stor290D[arg1]
}

function Enter() payable {
    if 10^15 == msg.value:
        stor0++
        if not stor0 <= stor0 + 1:
            mem[0] = 0
            idx = (3 * stor0) + 3
            while sha3(0) + (3 * stor0) > idx + sha3(mem[0]):
                address(stor[idx + sha3(mem[0])].field_0) = 0
                uint256(stor[idx + sha3(mem[0]) + 1].field_0) = 0
                if 31 < stor[idx + sha3(mem[0]) + 1].length:
                    mem[0] = idx + sha3(mem[0]) + 1
                    s = sha3(idx + sha3(mem[0]) + 1)
                    while sha3(idx + sha3(mem[0]) + 1) + (stor[idx + sha3(mem[0]) + 1].length + 31 / 32) > s:
                        uint256(stor[s].field_0) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 2].field_0) = 0
                idx = idx + 1
                continue 
        require stor0 < stor0
        uint256(stor[code.data[1491 len 32] + (3 * stor0)].field_0) = msg.sender or Mask(96, 160, uint256(stor[code.data[1491 len 32] + (3 * stor0)].field_0))
        bool(stor[code.data[1491 len 32] + (3 * stor0) + 1].field_0) = 0
        uint255(stor[code.data[1491 len 32] + (3 * stor0) + 1].field_1) = 10
        Mask(248, 0, stor[code.data[1491 len 32] + (3 * stor0) + 1].field_8) = 'Calculated' / 256
        idx = 0
        while stor[code.data[1491 len 32] + (3 * stor0) + 1].length + 31 / 32 > idx:
            uint256(stor[idx + sha3(code.data[1491 len 32] + (3 * stor0) + 1)].field_0) = 0
            idx = idx + 1
            continue 
        s = (10^18 * stor0) + 1 / 2
        t = 10^18 * stor0
        while s < t:
            s = s + (10^18 * stor0 / s) / 2
            t = s
            continue 
        require stor0 < stor0
        stor290D[stor0] = t
}

function _fallback() payable {
    if 10^15 == msg.value:
        stor0++
        if not stor0 <= stor0 + 1:
            mem[0] = 0
            idx = (3 * stor0) + 3
            while sha3(0) + (3 * stor0) > idx + sha3(mem[0]):
                address(stor[idx + sha3(mem[0])].field_0) = 0
                uint256(stor[idx + sha3(mem[0]) + 1].field_0) = 0
                if 31 < stor[idx + sha3(mem[0]) + 1].length:
                    mem[0] = idx + sha3(mem[0]) + 1
                    s = sha3(idx + sha3(mem[0]) + 1)
                    while sha3(idx + sha3(mem[0]) + 1) + (stor[idx + sha3(mem[0]) + 1].length + 31 / 32) > s:
                        uint256(stor[s].field_0) = 0
                        s = s + 1
                        continue 
                uint256(stor[idx + sha3(mem[0]) + 2].field_0) = 0
                idx = idx + 1
                continue 
        require stor0 < stor0
        uint256(stor[code.data[1491 len 32] + (3 * stor0)].field_0) = msg.sender or Mask(96, 160, uint256(stor[code.data[1491 len 32] + (3 * stor0)].field_0))
        bool(stor[code.data[1491 len 32] + (3 * stor0) + 1].field_0) = 0
        uint255(stor[code.data[1491 len 32] + (3 * stor0) + 1].field_1) = 10
        Mask(248, 0, stor[code.data[1491 len 32] + (3 * stor0) + 1].field_8) = 'Calculated' / 256
        idx = 0
        while stor[code.data[1491 len 32] + (3 * stor0) + 1].length + 31 / 32 > idx:
            uint256(stor[idx + sha3(code.data[1491 len 32] + (3 * stor0) + 1)].field_0) = 0
            idx = idx + 1
            continue 
        s = (10^18 * stor0) + 1 / 2
        t = 10^18 * stor0
        while s < t:
            s = s + (10^18 * stor0 / s) / 2
            t = s
            continue 
        require stor0 < stor0
        stor290D[stor0] = t
}



}
