contract main {


// =======================  Init code  ======================


address stor0;
mapping of uint8 stor1;
mapping of uint8 stor2;
uint256 stor7;

function _fallback() payable {
    stor7 = 10
    require not msg.value
    stor0 = msg.sender
    require stor0 == msg.sender
    require msg.sender
    stor1[address(msg.sender)] = 1
    require stor1[address(msg.sender)]
    stor2[address(msg.sender)] = 1
    return code.data[305 len 16660]
}



// =====================  Runtime code  =====================


const name = 'MAGICACADEMY JADE'

const decimals = 0

const symbol = 'Jade'


address owner;
mapping of uint8 stor1;
mapping of uint8 stor2;
uint256 roughSupply;
uint256 totalJadeProduction;
array of uint256 totalJadeProductionSnapshots;
uint256 nextSnapshotTime;
uint256 researchDivPercent;
mapping of uint256 jadeBalance;
mapping of uint256 coinBalance;
mapping of uint256 totalEtherPool;
mapping of uint256 jadeProduction;
mapping of uint8 stor12;
mapping of uint256 lastJadeSaveTime;
mapping of uint256 lastJadeProductionUpdate;
mapping of uint256 stor15;
array of uint256 stor17;
mapping of uint256 allowance;
array of address stor19;
uint8 stor20;
address schemaAddress; offset 8
mapping of uint256 ownedCount;
mapping of uint256 upgradesOwned;
mapping of uint256 uintsOwnerCount;
mapping of uint256 uintProduction;
mapping of uint256 unitCoinProductionIncreases;
mapping of uint256 unitCoinProductionMultiplier;
mapping of uint256 unitAttackIncreases;
mapping of uint256 unitAttackMultiplier;
mapping of uint256 unitDefenseIncreases;
mapping of uint256 unitDefenseMultiplier;
mapping of uint256 unitJadeStealingIncreases;
mapping of uint256 unitJadeStealingMultiplier;
mapping of uint256 maxCap;

function unitCoinProductionIncreases(address arg1, uint256 arg2) {
    return unitCoinProductionIncreases[arg1][arg2]
}

function upgradesOwned(address arg1, uint256 arg2) {
    return upgradesOwned[arg1][arg2]
}

function unitAttackMultiplier(address arg1, uint256 arg2) {
    return unitAttackMultiplier[arg1][arg2]
}

function getlastJadeProductionUpdate(address arg1) {
    return lastJadeProductionUpdate[address(arg1)]
}

function totalSupply() {
    return roughSupply
}

function getOwnedCount(address arg1, uint256 arg2) {
    return ownedCount[address(arg1)][arg2]
}

function getUnitJadeStealingMultiplier(address arg1, uint256 arg2) {
    return unitJadeStealingMultiplier[address(arg1)][arg2]
}

function unitCoinProductionMultiplier(address arg1, uint256 arg2) {
    return unitCoinProductionMultiplier[arg1][arg2]
}

function getUnitAttackIncreases(address arg1, uint256 arg2) {
    return unitAttackIncreases[address(arg1)][arg2]
}

function getJadeProduction(address arg1) {
    return jadeProduction[address(arg1)][stor14[address(arg1)]]
}

function lastJadeProductionUpdate(address arg1) {
    return lastJadeProductionUpdate[arg1]
}

function getUnitDefenseIncreases(address arg1, uint256 arg2) {
    return unitDefenseIncreases[address(arg1)][arg2]
}

function uintsOwnerCount(address arg1) {
    return uintsOwnerCount[arg1]
}

function jadeBalance(address arg1) {
    return jadeBalance[arg1]
}

function unitDefenseMultiplier(address arg1, uint256 arg2) {
    return unitDefenseMultiplier[arg1][arg2]
}

function unitJadeStealingIncreases(address arg1, uint256 arg2) {
    return unitJadeStealingIncreases[arg1][arg2]
}

function unitAttackIncreases(address arg1, uint256 arg2) {
    return unitAttackIncreases[arg1][arg2]
}

function getUnitDefenseMultiplier(address arg1, uint256 arg2) {
    return unitDefenseMultiplier[address(arg1)][arg2]
}

function lastJadeSaveTime(address arg1) {
    return lastJadeSaveTime[arg1]
}

function jadeProductionSnapshots(address arg1, uint256 arg2) {
    return jadeProduction[arg1][arg2]
}

function totalJadeProduction() {
    return totalJadeProduction
}

function getNextSnapshotTime() {
    return nextSnapshotTime
}

function getUnitJadeStealingIncreases(address arg1, uint256 arg2) {
    return unitJadeStealingIncreases[address(arg1)][arg2]
}

function owner() {
    return owner
}

function totalJadeProductionSnapshots(uint256 arg1) {
    require arg1 < totalJadeProductionSnapshots.length
    return totalJadeProductionSnapshots[arg1]
}

function getGameStarted() {
    return bool(stor20)
}

function getTotalEtherPool(uint8 arg1) {
    return totalEtherPool[arg1 << 248]
}

function researchDivPercent() {
    return researchDivPercent
}

function roughSupply() {
    return roughSupply
}

function getMaxCap(address arg1, uint256 arg2) {
    return maxCap[address(arg1)][arg2]
}

function coinBalance(address arg1, uint8 arg2) {
    return coinBalance[arg1][arg2]
}

function getTotalUsers() {
    return stor19.length
}

function getUintsOwnerCount(address arg1) {
    return uintsOwnerCount[address(arg1)]
}

function nextSnapshotTime() {
    return nextSnapshotTime
}

function getUnitAttackMultiplier(address arg1, uint256 arg2) {
    return unitAttackMultiplier[address(arg1)][arg2]
}

function unitJadeStealingMultiplier(address arg1, uint256 arg2) {
    return unitJadeStealingMultiplier[arg1][arg2]
}

function getTotalJadeProduction() {
    return totalJadeProduction
}

function getUnitCoinProductionMultiplier(address arg1, uint256 arg2) {
    return unitCoinProductionMultiplier[address(arg1)][arg2]
}

function uintProduction(address arg1, uint256 arg2) {
    return uintProduction[arg1][arg2]
}

function unitsOwned(address arg1, uint256 arg2) {
    return ownedCount[arg1][arg2]
}

function getUnitCoinProductionIncreases(address arg1, uint256 arg2) {
    return unitCoinProductionIncreases[address(arg1)][arg2]
}

function allowance(address arg1, address arg2) {
    return allowance[address(arg1)][address(arg2)]
}

function unitDefenseIncreases(address arg1, uint256 arg2) {
    return unitDefenseIncreases[arg1][arg2]
}

function getUintCoinProduction(address arg1, uint256 arg2) {
    return uintProduction[address(arg1)][arg2]
}

function coinBalanceOf(address arg1, uint8 arg2) {
    return coinBalance[address(arg1)][arg2 << 248]
}

function getUpgradesOwned(address arg1, uint256 arg2) {
    return upgradesOwned[address(arg1)][arg2]
}

function schema() {
    return schemaAddress
}

function _fallback() payable {
    totalEtherPool[1] += msg.value
}

function endGame() payable {
    require owner == msg.sender
    require stor20
    stor20 = 0
}

function setConfigAddress(address arg1) {
    require owner == msg.sender
    schemaAddress = arg1
}

function setJadeCoinZero(address arg1) {
    require stor2[address(msg.sender)]
    jadeBalance[address(arg1)] = 0
}

function setActionContract(address arg1, bool arg2) {
    require stor1[address(msg.sender)]
    stor2[address(arg1)] = uint8(arg2)
}

function setLastJadeSaveTime(address arg1) {
    require stor2[address(msg.sender)]
    lastJadeSaveTime[address(arg1)] = block.timestamp
}

function setAdminContract(address arg1, bool arg2) {
    require owner == msg.sender
    require arg1
    stor1[address(arg1)] = uint8(arg2)
}

function setRoughSupply(uint256 arg1) {
    require stor2[address(msg.sender)]
    require arg1 + roughSupply >= roughSupply
    roughSupply += arg1
}

function tweakDailyDividends(uint256 arg1) {
    require owner == msg.sender
    require arg1 > 0
    require arg1 <= 10
    researchDivPercent = arg1
}

function transferOwnership(address arg1) {
    require owner == msg.sender
    require arg1
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) {
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function beginGame(uint256 arg1) payable {
    require owner == msg.sender
    require not stor20
    stor20 = 1
    nextSnapshotTime = arg1
    totalEtherPool[1] = msg.value
}

function setUpgradesOwned(address arg1, uint256 arg2) {
    require stor2[address(msg.sender)]
    require upgradesOwned[address(arg1)][arg2] + 1 >= upgradesOwned[address(arg1)][arg2]
    upgradesOwned[address(arg1)][arg2]++
}

function JadeCoinMining(address arg1, uint256 arg2) {
    require stor1[address(msg.sender)]
    require arg2 + roughSupply >= roughSupply
    roughSupply += arg2
    require arg2 + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
    jadeBalance[address(arg1)] += arg2
}

function AddPlayers(address arg1) {
    require stor2[address(msg.sender)]
    stor19.length++
    if not stor19.length <= stor19.length + 1:
        idx = stor19.length + 1
        while stor19.length > idx:
            stor19[idx] = 0
            idx = idx + 1
            continue 
    stor19[stor19.length] = arg1
}

function setJadeCoin(address arg1, uint256 arg2, bool arg3) {
    require stor2[address(msg.sender)]
    if not arg3:
        require arg2 <= jadeBalance[address(arg1)]
        jadeBalance[address(arg1)] -= arg2
    else:
        require arg2 + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
        jadeBalance[address(arg1)] += arg2
}

function setTotalEtherPool(uint256 arg1, uint8 arg2, bool arg3) {
    require stor2[address(msg.sender)]
    if not arg3:
        require arg1 <= totalEtherPool[arg2 << 248]
        totalEtherPool[arg2 << 248] -= arg1
    else:
        require arg1 + totalEtherPool[arg2 << 248] >= totalEtherPool[arg2 << 248]
        totalEtherPool[arg2 << 248] += arg1
}

function setUintsOwnerCount(address arg1, uint256 arg2, bool arg3) {
    require stor2[address(msg.sender)]
    if not arg3:
        require arg2 <= uintsOwnerCount[address(arg1)]
        uintsOwnerCount[address(arg1)] -= arg2
    else:
        require arg2 + uintsOwnerCount[address(arg1)] >= uintsOwnerCount[address(arg1)]
        uintsOwnerCount[address(arg1)] += arg2
}

function setOwnedCount(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= ownedCount[address(arg1)][arg2]
        ownedCount[address(arg1)][arg2] -= arg3
    else:
        require arg3 + ownedCount[address(arg1)][arg2] >= ownedCount[address(arg1)][arg2]
        ownedCount[address(arg1)][arg2] += arg3
}

function setUintCoinProduction(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= uintProduction[address(arg1)][arg2]
        uintProduction[address(arg1)][arg2] -= arg3
    else:
        require arg3 + uintProduction[address(arg1)][arg2] >= uintProduction[address(arg1)][arg2]
        uintProduction[address(arg1)][arg2] += arg3
}

function setCoinBalance(address arg1, uint256 arg2, uint8 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg2 <= coinBalance[address(arg1)][arg3 << 248]
        coinBalance[address(arg1)][arg3 << 248] -= arg2
    else:
        require arg2 + coinBalance[address(arg1)][arg3 << 248] >= coinBalance[address(arg1)][arg3 << 248]
        coinBalance[address(arg1)][arg3 << 248] += arg2
}

function setUnitAttackIncreases(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= unitAttackIncreases[address(arg1)][arg2]
        unitAttackIncreases[address(arg1)][arg2] -= arg3
    else:
        require arg3 + unitAttackIncreases[address(arg1)][arg2] >= unitAttackIncreases[address(arg1)][arg2]
        unitAttackIncreases[address(arg1)][arg2] += arg3
}

function setUnitAttackMultiplier(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= unitAttackMultiplier[address(arg1)][arg2]
        unitAttackMultiplier[address(arg1)][arg2] -= arg3
    else:
        require arg3 + unitAttackMultiplier[address(arg1)][arg2] >= unitAttackMultiplier[address(arg1)][arg2]
        unitAttackMultiplier[address(arg1)][arg2] += arg3
}

function setUnitDefenseIncreases(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= unitDefenseIncreases[address(arg1)][arg2]
        unitDefenseIncreases[address(arg1)][arg2] -= arg3
    else:
        require arg3 + unitDefenseIncreases[address(arg1)][arg2] >= unitDefenseIncreases[address(arg1)][arg2]
        unitDefenseIncreases[address(arg1)][arg2] += arg3
}

function setunitDefenseMultiplier(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= unitDefenseMultiplier[address(arg1)][arg2]
        unitDefenseMultiplier[address(arg1)][arg2] -= arg3
    else:
        require arg3 + unitDefenseMultiplier[address(arg1)][arg2] >= unitDefenseMultiplier[address(arg1)][arg2]
        unitDefenseMultiplier[address(arg1)][arg2] += arg3
}

function getUnitsInProduction(address arg1, uint256 arg2, uint256 arg3) {
    if not arg3:
        if ownedCount[address(arg1)][arg2]:
            return (0 / ownedCount[address(arg1)][arg2])
    else:
        if uintProduction[address(arg1)][arg2] * arg3 / arg3 == uintProduction[address(arg1)][arg2]:
            if ownedCount[address(arg1)][arg2]:
                return (uintProduction[address(arg1)][arg2] * arg3 / ownedCount[address(arg1)][arg2])
    revert
}

function setUnitJadeStealingIncreases(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= unitJadeStealingIncreases[address(arg1)][arg2]
        unitJadeStealingIncreases[address(arg1)][arg2] -= arg3
    else:
        require arg3 + unitJadeStealingIncreases[address(arg1)][arg2] >= unitJadeStealingIncreases[address(arg1)][arg2]
        unitJadeStealingIncreases[address(arg1)][arg2] += arg3
}

function setUnitJadeStealingMultiplier(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= unitJadeStealingMultiplier[address(arg1)][arg2]
        unitJadeStealingMultiplier[address(arg1)][arg2] -= arg3
    else:
        require arg3 + unitJadeStealingMultiplier[address(arg1)][arg2] >= unitJadeStealingMultiplier[address(arg1)][arg2]
        unitJadeStealingMultiplier[address(arg1)][arg2] += arg3
}

function setUnitCoinProductionIncreases(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= unitCoinProductionIncreases[address(arg1)][arg2]
        unitCoinProductionIncreases[address(arg1)][arg2] -= arg3
    else:
        require arg3 + unitCoinProductionIncreases[address(arg1)][arg2] >= unitCoinProductionIncreases[address(arg1)][arg2]
        unitCoinProductionIncreases[address(arg1)][arg2] += arg3
}

function setUnitCoinProductionMultiplier(address arg1, uint256 arg2, uint256 arg3, bool arg4) {
    require stor2[address(msg.sender)]
    if not arg4:
        require arg3 <= unitCoinProductionMultiplier[address(arg1)][arg2]
        unitCoinProductionMultiplier[address(arg1)][arg2] -= arg3
    else:
        require arg3 + unitCoinProductionMultiplier[address(arg1)][arg2] >= unitCoinProductionMultiplier[address(arg1)][arg2]
        unitCoinProductionMultiplier[address(arg1)][arg2] += arg3
}

function increasePlayersJadeProduction(address arg1, uint256 arg2) {
    require stor2[address(msg.sender)]
    require arg2 + jadeProduction[address(arg1)][stor14[address(arg1)]] >= jadeProduction[address(arg1)][stor14[address(arg1)]]
    jadeProduction[address(arg1)][stor17.length] = arg2 + jadeProduction[address(arg1)][stor14[address(arg1)]]
    lastJadeProductionUpdate[address(arg1)] = stor17.length
    require arg2 + totalJadeProduction >= totalJadeProduction
    totalJadeProduction += arg2
}

function getUnitsProduction(address arg1, uint256 arg2, uint256 arg3) {
    require ext_code.size(schemaAddress)
    call schemaAddress.unitCoinProduction(uint256 arg1) with:
         gas gas_remaining wei
        args arg2
    require ext_call.success
    return ((10 * ext_call.return_data[0] * arg3) + (unitCoinProductionMultiplier[address(arg1)][arg2] * ext_call.return_data[0] * arg3) + (10 * unitCoinProductionIncreases[address(arg1)][arg2] * arg3) + (unitCoinProductionMultiplier[address(arg1)][arg2] * unitCoinProductionIncreases[address(arg1)][arg2] * arg3) / 10)
}

function reducePlayersJadeProduction(address arg1, uint256 arg2) {
    require stor2[address(msg.sender)]
    require arg2 <= jadeProduction[address(arg1)][stor14[address(arg1)]]
    if jadeProduction[address(arg1)][stor14[address(arg1)]] - arg2:
        jadeProduction[address(arg1)][stor17.length] = jadeProduction[address(arg1)][stor14[address(arg1)]] - arg2
    else:
        stor12[address(arg1)][stor17.length] = 1
        jadeProduction[address(arg1)][stor17.length] = 0
    lastJadeProductionUpdate[address(arg1)] = stor17.length
    require arg2 <= totalJadeProduction
    totalJadeProduction -= arg2
}

function balanceOfUnclaimed(address arg1) {
    if lastJadeSaveTime[address(arg1)] <= 0:
        return 0
    if lastJadeSaveTime[address(arg1)] >= block.timestamp:
        return 0
    require lastJadeSaveTime[address(arg1)] <= block.timestamp
    if not jadeProduction[address(arg1)][stor14[address(arg1)]]:
        return 0
    require block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]] / jadeProduction[address(arg1)][stor14[address(arg1)]] == block.timestamp - lastJadeSaveTime[address(arg1)] / 10
    return (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]])
}

function snapshotDailyGooResearchFunding() {
    require stor1[address(msg.sender)]
    totalEtherPool[1] -= totalEtherPool[1] * researchDivPercent / 100
    totalJadeProductionSnapshots.length++
    if not totalJadeProductionSnapshots.length <= totalJadeProductionSnapshots.length + 1:
        idx = totalJadeProductionSnapshots.length + 1
        while totalJadeProductionSnapshots.length > idx:
            totalJadeProductionSnapshots[idx] = 0
            idx = idx + 1
            continue 
    totalJadeProductionSnapshots[totalJadeProductionSnapshots.length] = totalJadeProduction
    stor17.length++
    if not stor17.length <= stor17.length + 1:
        idx = stor17.length + 1
        while stor17.length > idx:
            stor17[idx] = 0
            idx = idx + 1
            continue 
    stor17[stor17.length] = totalEtherPool[1] * researchDivPercent / 100
    nextSnapshotTime = block.timestamp + (24 * 3600)
}

function balanceOf(address arg1) {
    if lastJadeSaveTime[address(arg1)] <= 0:
        if jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]:
            return jadeBalance[address(arg1)]
    else:
        if lastJadeSaveTime[address(arg1)] >= block.timestamp:
            if jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]:
                return jadeBalance[address(arg1)]
        else:
            if lastJadeSaveTime[address(arg1)] <= block.timestamp:
                if not jadeProduction[address(arg1)][stor14[address(arg1)]]:
                    if jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]:
                        return jadeBalance[address(arg1)]
                else:
                    if block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]] / jadeProduction[address(arg1)][stor14[address(arg1)]] == block.timestamp - lastJadeSaveTime[address(arg1)] / 10:
                        if (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]:
                            return ((block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) + jadeBalance[address(arg1)])
    revert
}

function updatePlayersCoinByOut(address arg1) {
    require stor2[address(msg.sender)]
    if lastJadeSaveTime[address(arg1)] <= 0:
        lastJadeSaveTime[address(arg1)] = block.timestamp
        require roughSupply >= roughSupply
        require jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
    if lastJadeSaveTime[address(arg1)] >= block.timestamp:
        lastJadeSaveTime[address(arg1)] = block.timestamp
        require roughSupply >= roughSupply
        require jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
    require lastJadeSaveTime[address(arg1)] <= block.timestamp
    if not jadeProduction[address(arg1)][stor14[address(arg1)]]:
        lastJadeSaveTime[address(arg1)] = block.timestamp
        require roughSupply >= roughSupply
        require jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
    require block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]] / jadeProduction[address(arg1)][stor14[address(arg1)]] == block.timestamp - lastJadeSaveTime[address(arg1)] / 10
    lastJadeSaveTime[address(arg1)] = block.timestamp
    require (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) + roughSupply >= roughSupply
    roughSupply += block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]
    require (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
    jadeBalance[address(arg1)] += block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]
}

function viewUnclaimedResearchDividends() {
    s = 0
    s = 0
    idx = stor15[address(msg.sender)]
    s = 0
    while idx <= stor17.length - 1:
        mem[32] = sha3(address(msg.sender), 12)
        if jadeProduction[address(msg.sender)][idx]:
            if idx < totalJadeProductionSnapshots.length:
                if idx < stor17.length:
                    mem[0] = 17
                    if totalJadeProductionSnapshots[idx]:
                        s = stor12[address(msg.sender)][idx]
                        s = jadeProduction[address(msg.sender)][idx]
                        idx = idx + 1
                        s = (stor17[idx] * jadeProduction[address(msg.sender)][idx] / totalJadeProductionSnapshots[idx]) + s
                        continue 
        else:
            if stor12[address(msg.sender)][idx]:
                if idx < totalJadeProductionSnapshots.length:
                    if idx < stor17.length:
                        mem[0] = 17
                        if totalJadeProductionSnapshots[idx]:
                            s = stor12[address(msg.sender)][idx]
                            s = jadeProduction[address(msg.sender)][idx]
                            idx = idx + 1
                            s = (stor17[idx] * jadeProduction[address(msg.sender)][idx] / totalJadeProductionSnapshots[idx]) + s
                            continue 
            else:
                if idx < totalJadeProductionSnapshots.length:
                    if idx < stor17.length:
                        mem[0] = 17
                        if totalJadeProductionSnapshots[idx]:
                            s = stor12[address(msg.sender)][idx]
                            s = jadeProduction[address(msg.sender)][stor15[address(msg.sender)] - 1]
                            idx = idx + 1
                            s = (stor17[idx] * jadeProduction[address(msg.sender)][stor15[address(msg.sender)] - 1] / totalJadeProductionSnapshots[idx]) + s
                            continue 
        revert
    return s, stor15[address(msg.sender)], stor17.length - 1
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    if lastJadeSaveTime[address(arg1)] <= 0:
        lastJadeSaveTime[address(arg1)] = block.timestamp
        require roughSupply >= roughSupply
        require jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
    else:
        if lastJadeSaveTime[address(arg1)] >= block.timestamp:
            lastJadeSaveTime[address(arg1)] = block.timestamp
            require roughSupply >= roughSupply
            require jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
        else:
            require lastJadeSaveTime[address(arg1)] <= block.timestamp
            if not jadeProduction[address(arg1)][stor14[address(arg1)]]:
                lastJadeSaveTime[address(arg1)] = block.timestamp
                require roughSupply >= roughSupply
                require jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
            else:
                require block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]] / jadeProduction[address(arg1)][stor14[address(arg1)]] == block.timestamp - lastJadeSaveTime[address(arg1)] / 10
                lastJadeSaveTime[address(arg1)] = block.timestamp
                require (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) + roughSupply >= roughSupply
                roughSupply += block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]
                require (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
                jadeBalance[address(arg1)] += block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]
    require arg3 <= allowance[address(arg1)][address(msg.sender)]
    require arg3 <= jadeBalance[address(arg1)]
    require arg3 <= jadeBalance[address(arg1)]
    jadeBalance[address(arg1)] -= arg3
    require arg3 + jadeBalance[arg2] >= jadeBalance[arg2]
    jadeBalance[address(arg2)] = arg3 + jadeBalance[arg2]
    require arg3 <= allowance[address(arg1)][address(msg.sender)]
    allowance[address(arg1)][address(msg.sender)] -= arg3
    emit Transfer(arg3, arg1, arg2);
    return 1
}

function transfer(address arg1, uint256 arg2) {
    if lastJadeSaveTime[address(msg.sender)] <= 0:
        lastJadeSaveTime[address(msg.sender)] = block.timestamp
        require roughSupply >= roughSupply
        require jadeBalance[address(msg.sender)] >= jadeBalance[address(msg.sender)]
    else:
        if lastJadeSaveTime[address(msg.sender)] >= block.timestamp:
            lastJadeSaveTime[address(msg.sender)] = block.timestamp
            require roughSupply >= roughSupply
            require jadeBalance[address(msg.sender)] >= jadeBalance[address(msg.sender)]
        else:
            require lastJadeSaveTime[address(msg.sender)] <= block.timestamp
            if not jadeProduction[address(msg.sender)][stor14[address(msg.sender)]]:
                lastJadeSaveTime[address(msg.sender)] = block.timestamp
                require roughSupply >= roughSupply
                require jadeBalance[address(msg.sender)] >= jadeBalance[address(msg.sender)]
            else:
                require block.timestamp - lastJadeSaveTime[address(msg.sender)] / 10 * jadeProduction[address(msg.sender)][stor14[address(msg.sender)]] / jadeProduction[address(msg.sender)][stor14[address(msg.sender)]] == block.timestamp - lastJadeSaveTime[address(msg.sender)] / 10
                lastJadeSaveTime[address(msg.sender)] = block.timestamp
                require (block.timestamp - lastJadeSaveTime[address(msg.sender)] / 10 * jadeProduction[address(msg.sender)][stor14[address(msg.sender)]]) + roughSupply >= roughSupply
                roughSupply += block.timestamp - lastJadeSaveTime[address(msg.sender)] / 10 * jadeProduction[address(msg.sender)][stor14[address(msg.sender)]]
                require (block.timestamp - lastJadeSaveTime[address(msg.sender)] / 10 * jadeProduction[address(msg.sender)][stor14[address(msg.sender)]]) + jadeBalance[address(msg.sender)] >= jadeBalance[address(msg.sender)]
                jadeBalance[address(msg.sender)] += block.timestamp - lastJadeSaveTime[address(msg.sender)] / 10 * jadeProduction[address(msg.sender)][stor14[address(msg.sender)]]
    require arg2 <= jadeBalance[address(msg.sender)]
    require arg2 <= jadeBalance[address(msg.sender)]
    jadeBalance[address(msg.sender)] -= arg2
    require arg2 + jadeBalance[arg1] >= jadeBalance[arg1]
    jadeBalance[address(arg1)] = arg2 + jadeBalance[arg1]
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function claimResearchDividends(address arg1, uint256 arg2, uint256 arg3) {
    require arg2 <= arg3
    require arg2 >= stor15[address(msg.sender)]
    require arg3 < stor17.length
    s = 0
    s = 0
    idx = arg2
    s = 0
    while idx <= arg3:
        mem[32] = sha3(address(msg.sender), 12)
        if jadeProduction[address(msg.sender)][idx]:
            if idx < totalJadeProductionSnapshots.length:
                if idx < stor17.length:
                    mem[0] = 17
                    if totalJadeProductionSnapshots[idx]:
                        s = stor12[address(msg.sender)][idx]
                        s = jadeProduction[address(msg.sender)][idx]
                        idx = idx + 1
                        s = (stor17[idx] * jadeProduction[address(msg.sender)][idx] / totalJadeProductionSnapshots[idx]) + s
                        continue 
        else:
            if stor12[address(msg.sender)][idx]:
                if idx < totalJadeProductionSnapshots.length:
                    if idx < stor17.length:
                        mem[0] = 17
                        if totalJadeProductionSnapshots[idx]:
                            s = stor12[address(msg.sender)][idx]
                            s = jadeProduction[address(msg.sender)][idx]
                            idx = idx + 1
                            s = (stor17[idx] * jadeProduction[address(msg.sender)][idx] / totalJadeProductionSnapshots[idx]) + s
                            continue 
            else:
                if idx < totalJadeProductionSnapshots.length:
                    if idx < stor17.length:
                        mem[0] = 17
                        if totalJadeProductionSnapshots[idx]:
                            s = stor12[address(msg.sender)][idx]
                            s = jadeProduction[address(msg.sender)][stor15[address(msg.sender)] - 1]
                            idx = idx + 1
                            s = (stor17[idx] * jadeProduction[address(msg.sender)][stor15[address(msg.sender)] - 1] / totalJadeProductionSnapshots[idx]) + s
                            continue 
        revert
    if not jadeProduction[address(msg.sender)][arg3]:
        if not stor12[address(msg.sender)][arg3]:
            if jadeProduction[address(msg.sender)][stor15[address(msg.sender)] - 1] > 0:
                jadeProduction[address(msg.sender)][arg3] = jadeProduction[address(msg.sender)][stor15[address(msg.sender)] - 1]
    stor15[address(msg.sender)] = arg3 + 1
    if not arg1:
        require 0 <= s
        coinBalance[address(msg.sender)][1] += s
    else:
        if arg1 == msg.sender:
            require 0 <= s
            coinBalance[address(msg.sender)][1] += s
        else:
            coinBalance[address(arg1)][1] += s / 100
            emit ReferalGain(address(arg1), msg.sender, s / 100);
            require s / 100 <= s
            coinBalance[address(msg.sender)][1] = s - (s / 100) + coinBalance[address(msg.sender)][1]
}

function upgradeUnitMultipliers(address arg1, uint256 arg2, uint256 arg3, uint256 arg4) {
    require stor2[address(msg.sender)]
    if not arg2:
        unitCoinProductionIncreases[address(arg1)][arg3] += arg4
        require stor2[address(msg.sender)]
        require (10 * arg4 * ownedCount[address(arg1)][arg3]) + (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + jadeProduction[address(arg1)][stor14[address(arg1)]] >= jadeProduction[address(arg1)][stor14[address(arg1)]]
        jadeProduction[address(arg1)][stor17.length] = (10 * arg4 * ownedCount[address(arg1)][arg3]) + (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + jadeProduction[address(arg1)][stor14[address(arg1)]]
        lastJadeProductionUpdate[address(arg1)] = stor17.length
        require (10 * arg4 * ownedCount[address(arg1)][arg3]) + (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + totalJadeProduction >= totalJadeProduction
        totalJadeProduction = (10 * arg4 * ownedCount[address(arg1)][arg3]) + (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + totalJadeProduction
    else:
        if arg2 != 1:
            if 2 == arg2:
                unitAttackIncreases[address(arg1)][arg3] += arg4
            else:
                if 3 == arg2:
                    unitAttackMultiplier[address(arg1)][arg3] += arg4
                else:
                    if 4 == arg2:
                        unitDefenseIncreases[address(arg1)][arg3] += arg4
                    else:
                        if 5 == arg2:
                            unitDefenseMultiplier[address(arg1)][arg3] += arg4
                        else:
                            if 6 == arg2:
                                unitJadeStealingIncreases[address(arg1)][arg3] += arg4
                            else:
                                if 7 == arg2:
                                    unitJadeStealingMultiplier[address(arg1)][arg3] += arg4
                                else:
                                    if 8 == arg2:
                                        maxCap[address(arg1)][arg3] = arg4
        else:
            unitCoinProductionMultiplier[address(arg1)][arg3] += arg4
            require ext_code.size(schemaAddress)
            call schemaAddress.unitCoinProduction(uint256 arg1) with:
                 gas gas_remaining wei
                args arg3
            require ext_call.success
            require stor2[address(msg.sender)]
            require (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3]) + jadeProduction[address(arg1)][stor14[address(arg1)]] >= jadeProduction[address(arg1)][stor14[address(arg1)]]
            jadeProduction[address(arg1)][stor17.length] = (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3]) + jadeProduction[address(arg1)][stor14[address(arg1)]]
            lastJadeProductionUpdate[address(arg1)] = stor17.length
            require (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3]) + totalJadeProduction >= totalJadeProduction
            totalJadeProduction = (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3]) + totalJadeProduction
}

function removeUnitMultipliers(address arg1, uint256 arg2, uint256 arg3, uint256 arg4) {
    require stor2[address(msg.sender)]
    if not arg2:
        unitCoinProductionIncreases[address(arg1)][arg3] -= arg4
        require stor2[address(msg.sender)]
        require (10 * arg4 * ownedCount[address(arg1)][arg3]) + (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) <= jadeProduction[address(arg1)][stor14[address(arg1)]]
        if jadeProduction[address(arg1)][stor14[address(arg1)]] - (10 * arg4 * ownedCount[address(arg1)][arg3]) - (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]):
            jadeProduction[address(arg1)][stor17.length] = jadeProduction[address(arg1)][stor14[address(arg1)]] - (10 * arg4 * ownedCount[address(arg1)][arg3]) - (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3])
        else:
            stor12[address(arg1)][stor17.length] = 1
            jadeProduction[address(arg1)][stor17.length] = 0
        lastJadeProductionUpdate[address(arg1)] = stor17.length
        require (10 * arg4 * ownedCount[address(arg1)][arg3]) + (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) <= totalJadeProduction
        totalJadeProduction = totalJadeProduction - (10 * arg4 * ownedCount[address(arg1)][arg3]) - (unitCoinProductionMultiplier[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3])
    else:
        if arg2 != 1:
            if 2 == arg2:
                unitAttackIncreases[address(arg1)][arg3] -= arg4
            else:
                if 3 == arg2:
                    unitAttackMultiplier[address(arg1)][arg3] -= arg4
                else:
                    if 4 == arg2:
                        unitDefenseIncreases[address(arg1)][arg3] -= arg4
                    else:
                        if 5 == arg2:
                            unitDefenseMultiplier[address(arg1)][arg3] -= arg4
                        else:
                            if 6 == arg2:
                                unitJadeStealingIncreases[address(arg1)][arg3] -= arg4
                            else:
                                if 7 == arg2:
                                    unitJadeStealingMultiplier[address(arg1)][arg3] -= arg4
        else:
            unitCoinProductionMultiplier[address(arg1)][arg3] -= arg4
            require ext_code.size(schemaAddress)
            call schemaAddress.unitCoinProduction(uint256 arg1) with:
                 gas gas_remaining wei
                args arg3
            require ext_call.success
            require stor2[address(msg.sender)]
            require (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3]) <= jadeProduction[address(arg1)][stor14[address(arg1)]]
            if jadeProduction[address(arg1)][stor14[address(arg1)]] - (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) - (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3]):
                jadeProduction[address(arg1)][stor17.length] = jadeProduction[address(arg1)][stor14[address(arg1)]] - (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) - (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3])
            else:
                stor12[address(arg1)][stor17.length] = 1
                jadeProduction[address(arg1)][stor17.length] = 0
            lastJadeProductionUpdate[address(arg1)] = stor17.length
            require (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) + (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3]) <= totalJadeProduction
            totalJadeProduction = totalJadeProduction - (unitCoinProductionIncreases[address(arg1)][arg3] * arg4 * ownedCount[address(arg1)][arg3]) - (ext_call.return_data[0] * arg4 * ownedCount[address(arg1)][arg3])
}

function updatePlayersCoinByPurchase(address arg1, uint256 arg2) {
    require stor2[address(msg.sender)]
    if lastJadeSaveTime[address(arg1)] <= 0:
        if arg2 <= 0:
            require -arg2 + roughSupply >= roughSupply
            roughSupply -= arg2
            require -arg2 + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
            jadeBalance[address(arg1)] -= arg2
        else:
            require 0 <= arg2
            require jadeBalance[address(arg1)] >= arg2
            require arg2 <= roughSupply
            roughSupply -= arg2
            require arg2 <= jadeBalance[address(arg1)]
            jadeBalance[address(arg1)] -= arg2
    else:
        if lastJadeSaveTime[address(arg1)] >= block.timestamp:
            if arg2 <= 0:
                require -arg2 + roughSupply >= roughSupply
                roughSupply -= arg2
                require -arg2 + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
                jadeBalance[address(arg1)] -= arg2
            else:
                require 0 <= arg2
                require jadeBalance[address(arg1)] >= arg2
                require arg2 <= roughSupply
                roughSupply -= arg2
                require arg2 <= jadeBalance[address(arg1)]
                jadeBalance[address(arg1)] -= arg2
        else:
            require lastJadeSaveTime[address(arg1)] <= block.timestamp
            if not jadeProduction[address(arg1)][stor14[address(arg1)]]:
                if arg2 <= 0:
                    require -arg2 + roughSupply >= roughSupply
                    roughSupply -= arg2
                    require -arg2 + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
                    jadeBalance[address(arg1)] -= arg2
                else:
                    require 0 <= arg2
                    require jadeBalance[address(arg1)] >= arg2
                    require arg2 <= roughSupply
                    roughSupply -= arg2
                    require arg2 <= jadeBalance[address(arg1)]
                    jadeBalance[address(arg1)] -= arg2
            else:
                require block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]] / jadeProduction[address(arg1)][stor14[address(arg1)]] == block.timestamp - lastJadeSaveTime[address(arg1)] / 10
                if arg2 <= block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]:
                    require (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) - arg2 + roughSupply >= roughSupply
                    roughSupply = (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) - arg2 + roughSupply
                    require (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) - arg2 + jadeBalance[address(arg1)] >= jadeBalance[address(arg1)]
                    jadeBalance[address(arg1)] = (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) - arg2 + jadeBalance[address(arg1)]
                else:
                    require block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]] <= arg2
                    require jadeBalance[address(arg1)] >= arg2 - (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]])
                    require arg2 - (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) <= roughSupply
                    roughSupply = roughSupply - arg2 + (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]])
                    require arg2 - (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]]) <= jadeBalance[address(arg1)]
                    jadeBalance[address(arg1)] = jadeBalance[address(arg1)] - arg2 + (block.timestamp - lastJadeSaveTime[address(arg1)] / 10 * jadeProduction[address(arg1)][stor14[address(arg1)]])
    lastJadeSaveTime[address(arg1)] = block.timestamp
}

function getPlayersBattleStats(address arg1) {
    require ext_code.size(schemaAddress)
    call schemaAddress.battleCardIdRange() with:
         gas gas_remaining wei
    mem[96 len 64] = ext_call.return_data[0 len 64]
    require ext_call.success
    idx = mem[96]
    s = 0
    t = 0
    u = 0
    v = 0
    while idx <= ext_call.return_data[32]:
        _39 = sha3(idx, sha3(address(arg1), 21))
        _43 = sha3(idx, sha3(address(arg1), 28))
        _45 = sha3(idx, sha3(address(arg1), 27))
        require ext_code.size(schemaAddress)
        call schemaAddress.unitAttack(uint256 arg1) with:
             gas gas_remaining wei
            args idx
        require ext_call.success
        _49 = ext_call.return_data[0]
        require ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitAttackMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitAttackIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitAttackMultiplier[address(arg1)][idx] * unitAttackIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + v >= v
        require ext_code.size(schemaAddress)
        call schemaAddress.unitStealingCapacity(uint256 arg1) with:
             gas gas_remaining wei
            args idx
        require ext_call.success
        require ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitJadeStealingMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitJadeStealingIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitJadeStealingMultiplier[address(arg1)][idx] * unitJadeStealingIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + t >= t
        mem[0] = idx
        mem[32] = sha3(address(arg1), 29)
        mem[100] = idx
        require ext_code.size(schemaAddress)
        call schemaAddress.unitDefense(uint256 arg1) with:
             gas gas_remaining wei
            args idx
        mem[96] = ext_call.return_data[0]
        require ext_call.success
        require ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitDefenseMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitDefenseIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitDefenseMultiplier[address(arg1)][idx] * unitDefenseIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + u >= u
        require ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitDefenseMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitDefenseIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitDefenseMultiplier[address(arg1)][idx] * unitDefenseIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + u >= 0
        idx = idx + 1
        s = ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitDefenseMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitDefenseIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitDefenseMultiplier[address(arg1)][idx] * unitDefenseIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + u + ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitAttackMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitAttackIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitAttackMultiplier[address(arg1)][idx] * unitAttackIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + v
        t = ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitJadeStealingMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitJadeStealingIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitJadeStealingMultiplier[address(arg1)][idx] * unitJadeStealingIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + t
        u = ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitDefenseMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitDefenseIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitDefenseMultiplier[address(arg1)][idx] * unitDefenseIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + u
        v = ((10 * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (unitAttackMultiplier[address(arg1)][idx] * ext_call.return_data[0] * ownedCount[address(arg1)][idx]) + (10 * unitAttackIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) + (unitAttackMultiplier[address(arg1)][idx] * unitAttackIncreases[address(arg1)][idx] * ownedCount[address(arg1)][idx]) / 10) + v
        continue 
    mem[96] = ((10 * _49 * stor[_39]) + (stor[_43] * _49 * stor[_39]) + (10 * stor[_45] * stor[_39]) + (stor[_43] * stor[_45] * stor[_39]) / 10) + (ext_call.return_data[32] * (10 * _49 * stor[_39]) + (stor[_43] * _49 * stor[_39]) + (10 * stor[_45] * stor[_39]) + (stor[_43] * stor[_45] * stor[_39]) / 10) - (mem[96] * (10 * _49 * stor[_39]) + (stor[_43] * _49 * stor[_39]) + (10 * stor[_45] * stor[_39]) + (stor[_43] * stor[_45] * stor[_39]) / 10)
    return mem[96], u, t, s
}

function getRanking() {
    if 320 < (32 * stor19.length) + 320:
        mem[(32 * stor19.length) + 320] = stor19.length
        if 32 * stor19.length < 64 * stor19.length:
            mem[(64 * stor19.length) + 352] = stor19.length
            idx = 0
            s = 0
            while idx < stor19.length:
                mem[32] = sha3(stor19[idx], 11)
                require s < stor19.length
                mem[(32 * s) + 320] = jadeProduction[stor19[idx]][stor14[stor19[idx]]]
                require idx < stor19.length
                require s < mem[(32 * stor19.length) + 320]
                mem[(32 * stor19.length) + (32 * s) + 352] = stor19[idx]
                require idx < stor19.length
                mem[0] = 19
                require ext_code.size(schemaAddress)
                call schemaAddress.battleCardIdRange() with:
                     gas gas_remaining wei
                mem[(98 * stor19.length) + 384 len 64] = ext_call.return_data[0 len 64]
                require ext_call.success
                t = mem[(98 * stor19.length) + 384]
                u = 0
                u = 0
                v = 0
                w = 0
                while t <= ext_call.return_data[32]:
                    require ext_code.size(schemaAddress)
                    call schemaAddress.unitAttack(uint256 arg1) with:
                         gas gas_remaining wei
                        args t
                    require ext_call.success
                    require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w >= w
                    require ext_code.size(schemaAddress)
                    call schemaAddress.unitStealingCapacity(uint256 arg1) with:
                         gas gas_remaining wei
                        args t
                    require ext_call.success
                    require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + u >= u
                    _1677 = sha3(t, sha3(stor19[idx], 21))
                    _1709 = sha3(t, sha3(stor19[idx], 30))
                    mem[0] = t
                    mem[32] = sha3(stor19[idx], 29)
                    _1711 = sha3(t, sha3(stor19[idx], 29))
                    mem[(98 * stor19.length) + 388] = t
                    require ext_code.size(schemaAddress)
                    call schemaAddress.unitDefense(uint256 arg1) with:
                         gas gas_remaining wei
                        args t
                    mem[(98 * stor19.length) + 384] = ext_call.return_data[0]
                    require ext_call.success
                    require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v >= v
                    require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v >= 0
                    t = t + 1
                    u = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v + ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w
                    u = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + u
                    v = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v
                    w = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w
                    continue 
                require s < mem[(64 * stor19.length) + 352]
                mem[(64 * stor19.length) + (32 * s) + 384] = ((10 * _1741 * stor[_1677]) + (stor[_1709] * _1741 * stor[_1677]) + (10 * stor[_1711] * stor[_1677]) + (stor[_1709] * stor[_1711] * stor[_1677]) / 10) + (ext_call.return_data[32] * (10 * _1741 * stor[_1677]) + (stor[_1709] * _1741 * stor[_1677]) + (10 * stor[_1711] * stor[_1677]) + (stor[_1709] * stor[_1711] * stor[_1677]) / 10) - (mem[(98 * stor19.length) + 384] * (10 * _1741 * stor[_1677]) + (stor[_1709] * _1741 * stor[_1677]) + (10 * stor[_1711] * stor[_1677]) + (stor[_1709] * stor[_1711] * stor[_1677]) / 10)
                idx = idx + 1
                s = s + 1
                continue 
            s = 0
            t = 0
            u = 0
            v = 0
            idx = 0
            while idx < stor19.length - 1:
                v = s
                w = t
                x = u
                y = 0
                while y < stor19.length + -idx - 1:
                    require y + 1 < stor19.length
                    require y < stor19.length
                    if mem[(32 * y) + 320] >= mem[(32 * y + 1) + 320]:
                        v = v
                        w = w
                        x = x
                        y = y + 1
                        continue 
                    require y < stor19.length
                    _2118 = mem[(32 * y) + 320]
                    require y < mem[(32 * stor19.length) + 320]
                    _2140 = mem[(32 * y) + (32 * stor19.length) + 352]
                    require y < mem[(64 * stor19.length) + 352]
                    _2156 = mem[(32 * y) + (64 * stor19.length) + 384]
                    require y + 1 < stor19.length
                    require y < stor19.length
                    mem[(32 * y) + 320] = mem[(32 * y + 1) + 320]
                    require y + 1 < stor19.length
                    mem[(32 * y + 1) + 320] = _2118
                    require y + 1 < mem[(32 * stor19.length) + 320]
                    require y < mem[(32 * stor19.length) + 320]
                    mem[(32 * stor19.length) + (32 * y) + 352] = mem[(32 * y + 1) + (32 * stor19.length) + 364 len 20]
                    require y + 1 < mem[(32 * stor19.length) + 320]
                    mem[(32 * stor19.length) + (32 * y + 1) + 352] = address(_2140)
                    require y + 1 < mem[(64 * stor19.length) + 352]
                    require y < mem[(64 * stor19.length) + 352]
                    mem[(64 * stor19.length) + (32 * y) + 384] = mem[(32 * y + 1) + (64 * stor19.length) + 384]
                    require y + 1 < mem[(64 * stor19.length) + 352]
                    mem[(64 * stor19.length) + (32 * y + 1) + 384] = _2156
                    v = _2156
                    w = _2140
                    x = _2118
                    y = y + 1
                    continue 
                s = v
                t = w
                u = x
                v = y
                idx = idx + 1
                continue 
            mem[(98 * stor19.length) + 384] = 96
            mem[(98 * stor19.length) + 480] = mem[(32 * stor19.length) + 320]
            mem[(98 * stor19.length) + 512 len floor32(mem[(32 * stor19.length) + 320])] = mem[(32 * stor19.length) + 352 len floor32(mem[(32 * stor19.length) + 320])]
            mem[(98 * stor19.length) + 416] = (32 * mem[(32 * stor19.length) + 320]) + 128
            mem[(32 * mem[(32 * stor19.length) + 320]) + (98 * stor19.length) + 512] = stor19.length
            mem[(32 * mem[(32 * stor19.length) + 320]) + (98 * stor19.length) + 544 len floor32(stor19.length)] = mem[320 len floor32(stor19.length)]
            mem[(98 * stor19.length) + 448] = (32 * stor19.length) + (32 * mem[(32 * stor19.length) + 320]) + 160
            mem[(131 * stor19.length) + (32 * mem[(32 * stor19.length) + 320]) + 544] = mem[(64 * stor19.length) + 352]
            mem[(131 * stor19.length) + (32 * mem[(32 * stor19.length) + 320]) + 576 len floor32(mem[(64 * stor19.length) + 352])] = mem[(64 * stor19.length) + 384 len floor32(mem[(64 * stor19.length) + 352])]
            return 96, 
                   mem[(98 * stor19.length) + 416 len (32 * mem[(32 * stor19.length) + 320]) + 96],
                   stor19.length,
                   mem[(98 * stor19.length) + (32 * mem[(32 * stor19.length) + 320]) + 544 len (32 * mem[(64 * stor19.length) + 352]) + (32 * stor19.length) + 32]
        mem[(32 * stor19.length) + 352] = stor19.length
        idx = 0
        s = 0
        while idx < stor19.length:
            mem[32] = sha3(stor19[idx], 11)
            require s < stor19.length
            mem[(32 * s) + 320] = jadeProduction[stor19[idx]][stor14[stor19[idx]]]
            require idx < stor19.length
            require s < mem[(32 * stor19.length) + 320]
            mem[(32 * stor19.length) + (32 * s) + 352] = stor19[idx]
            require idx < stor19.length
            mem[0] = 19
            require ext_code.size(schemaAddress)
            call schemaAddress.battleCardIdRange() with:
                 gas gas_remaining wei
            mem[(64 * stor19.length) + 384 len 64] = ext_call.return_data[0 len 64]
            require ext_call.success
            t = mem[(64 * stor19.length) + 384]
            u = 0
            u = 0
            v = 0
            w = 0
            while t <= ext_call.return_data[32]:
                require ext_code.size(schemaAddress)
                call schemaAddress.unitAttack(uint256 arg1) with:
                     gas gas_remaining wei
                    args t
                require ext_call.success
                require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w >= w
                require ext_code.size(schemaAddress)
                call schemaAddress.unitStealingCapacity(uint256 arg1) with:
                     gas gas_remaining wei
                    args t
                require ext_call.success
                require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + u >= u
                _1679 = sha3(t, sha3(stor19[idx], 21))
                _1715 = sha3(t, sha3(stor19[idx], 30))
                mem[0] = t
                mem[32] = sha3(stor19[idx], 29)
                _1717 = sha3(t, sha3(stor19[idx], 29))
                mem[(64 * stor19.length) + 388] = t
                require ext_code.size(schemaAddress)
                call schemaAddress.unitDefense(uint256 arg1) with:
                     gas gas_remaining wei
                    args t
                mem[(64 * stor19.length) + 384] = ext_call.return_data[0]
                require ext_call.success
                require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v >= v
                require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v >= 0
                t = t + 1
                u = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v + ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w
                u = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + u
                v = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v
                w = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w
                continue 
            require s < mem[(32 * stor19.length) + 352]
            mem[(32 * stor19.length) + (32 * s) + 384] = ((10 * _1743 * stor[_1679]) + (stor[_1715] * _1743 * stor[_1679]) + (10 * stor[_1717] * stor[_1679]) + (stor[_1715] * stor[_1717] * stor[_1679]) / 10) + (ext_call.return_data[32] * (10 * _1743 * stor[_1679]) + (stor[_1715] * _1743 * stor[_1679]) + (10 * stor[_1717] * stor[_1679]) + (stor[_1715] * stor[_1717] * stor[_1679]) / 10) - (mem[(64 * stor19.length) + 384] * (10 * _1743 * stor[_1679]) + (stor[_1715] * _1743 * stor[_1679]) + (10 * stor[_1717] * stor[_1679]) + (stor[_1715] * stor[_1717] * stor[_1679]) / 10)
            idx = idx + 1
            s = s + 1
            continue 
        s = 0
        t = 0
        u = 0
        v = 0
        idx = 0
        while idx < stor19.length - 1:
            v = s
            w = t
            x = u
            y = 0
            while y < stor19.length + -idx - 1:
                require y + 1 < stor19.length
                require y < stor19.length
                if mem[(32 * y) + 320] >= mem[(32 * y + 1) + 320]:
                    v = v
                    w = w
                    x = x
                    y = y + 1
                    continue 
                require y < stor19.length
                _2122 = mem[(32 * y) + 320]
                require y < mem[(32 * stor19.length) + 320]
                _2142 = mem[(32 * y) + (32 * stor19.length) + 352]
                require y < mem[(32 * stor19.length) + 352]
                _2158 = mem[(32 * y) + (32 * stor19.length) + 384]
                require y + 1 < stor19.length
                require y < stor19.length
                mem[(32 * y) + 320] = mem[(32 * y + 1) + 320]
                require y + 1 < stor19.length
                mem[(32 * y + 1) + 320] = _2122
                require y + 1 < mem[(32 * stor19.length) + 320]
                require y < mem[(32 * stor19.length) + 320]
                mem[(32 * stor19.length) + (32 * y) + 352] = mem[(32 * y + 1) + (32 * stor19.length) + 364 len 20]
                require y + 1 < mem[(32 * stor19.length) + 320]
                mem[(32 * stor19.length) + (32 * y + 1) + 352] = address(_2142)
                require y + 1 < mem[(32 * stor19.length) + 352]
                require y < mem[(32 * stor19.length) + 352]
                mem[(32 * stor19.length) + (32 * y) + 384] = mem[(32 * y + 1) + (32 * stor19.length) + 384]
                require y + 1 < mem[(32 * stor19.length) + 352]
                mem[(32 * stor19.length) + (32 * y + 1) + 384] = _2158
                v = _2158
                w = _2142
                x = _2122
                y = y + 1
                continue 
            s = v
            t = w
            u = x
            v = y
            idx = idx + 1
            continue 
        mem[(64 * stor19.length) + 384] = 96
        mem[(64 * stor19.length) + 480] = mem[(32 * stor19.length) + 320]
        mem[(64 * stor19.length) + 512 len floor32(mem[(32 * stor19.length) + 320])] = mem[(32 * stor19.length) + 352 len floor32(mem[(32 * stor19.length) + 320])]
        mem[(64 * stor19.length) + 416] = (32 * mem[(32 * stor19.length) + 320]) + 128
        mem[(32 * mem[(32 * stor19.length) + 320]) + (64 * stor19.length) + 512] = stor19.length
        mem[(32 * mem[(32 * stor19.length) + 320]) + (64 * stor19.length) + 544 len floor32(stor19.length)] = mem[320 len floor32(stor19.length)]
        mem[(64 * stor19.length) + 448] = (32 * stor19.length) + (32 * mem[(32 * stor19.length) + 320]) + 160
        mem[(98 * stor19.length) + (32 * mem[(32 * stor19.length) + 320]) + 544] = mem[(32 * stor19.length) + 352]
        mem[(98 * stor19.length) + (32 * mem[(32 * stor19.length) + 320]) + 576 len floor32(mem[(32 * stor19.length) + 352])] = mem[(32 * stor19.length) + 384 len floor32(mem[(32 * stor19.length) + 352])]
        return 96, 
               mem[(64 * stor19.length) + 416 len (32 * mem[(32 * stor19.length) + 320]) + 96],
               stor19.length,
               mem[(64 * stor19.length) + (32 * mem[(32 * stor19.length) + 320]) + 544 len (32 * mem[(32 * stor19.length) + 352]) + (32 * stor19.length) + 32]
    mem[320] = stor19.length
    if 352 < (32 * stor19.length) + 352:
        mem[(32 * stor19.length) + 352] = stor19.length
        idx = 0
        s = 0
        while idx < stor19.length:
            mem[32] = sha3(stor19[idx], 11)
            require s < stor19.length
            mem[(32 * s) + 320] = jadeProduction[stor19[idx]][stor14[stor19[idx]]]
            require idx < stor19.length
            require s < mem[320]
            mem[(32 * s) + 352] = stor19[idx]
            require idx < stor19.length
            mem[0] = 19
            require ext_code.size(schemaAddress)
            call schemaAddress.battleCardIdRange() with:
                 gas gas_remaining wei
            mem[(64 * stor19.length) + 384 len 64] = ext_call.return_data[0 len 64]
            require ext_call.success
            t = mem[(64 * stor19.length) + 384]
            u = 0
            u = 0
            v = 0
            w = 0
            while t <= ext_call.return_data[32]:
                require ext_code.size(schemaAddress)
                call schemaAddress.unitAttack(uint256 arg1) with:
                     gas gas_remaining wei
                    args t
                require ext_call.success
                require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w >= w
                require ext_code.size(schemaAddress)
                call schemaAddress.unitStealingCapacity(uint256 arg1) with:
                     gas gas_remaining wei
                    args t
                require ext_call.success
                require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + u >= u
                _1681 = sha3(t, sha3(stor19[idx], 21))
                _1721 = sha3(t, sha3(stor19[idx], 30))
                mem[0] = t
                mem[32] = sha3(stor19[idx], 29)
                _1723 = sha3(t, sha3(stor19[idx], 29))
                mem[(64 * stor19.length) + 388] = t
                require ext_code.size(schemaAddress)
                call schemaAddress.unitDefense(uint256 arg1) with:
                     gas gas_remaining wei
                    args t
                mem[(64 * stor19.length) + 384] = ext_call.return_data[0]
                require ext_call.success
                require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v >= v
                require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v >= 0
                t = t + 1
                u = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v + ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w
                u = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + u
                v = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v
                w = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w
                continue 
            require s < mem[(32 * stor19.length) + 352]
            mem[(32 * stor19.length) + (32 * s) + 384] = ((10 * _1745 * stor[_1681]) + (stor[_1721] * _1745 * stor[_1681]) + (10 * stor[_1723] * stor[_1681]) + (stor[_1721] * stor[_1723] * stor[_1681]) / 10) + (ext_call.return_data[32] * (10 * _1745 * stor[_1681]) + (stor[_1721] * _1745 * stor[_1681]) + (10 * stor[_1723] * stor[_1681]) + (stor[_1721] * stor[_1723] * stor[_1681]) / 10) - (mem[(64 * stor19.length) + 384] * (10 * _1745 * stor[_1681]) + (stor[_1721] * _1745 * stor[_1681]) + (10 * stor[_1723] * stor[_1681]) + (stor[_1721] * stor[_1723] * stor[_1681]) / 10)
            idx = idx + 1
            s = s + 1
            continue 
        s = 0
        t = 0
        u = 0
        v = 0
        idx = 0
        while idx < stor19.length - 1:
            v = s
            w = t
            x = u
            y = 0
            while y < stor19.length + -idx - 1:
                require y + 1 < stor19.length
                require y < stor19.length
                if mem[(32 * y) + 320] >= mem[(32 * y + 1) + 320]:
                    v = v
                    w = w
                    x = x
                    y = y + 1
                    continue 
                require y < stor19.length
                _2126 = mem[(32 * y) + 320]
                require y < mem[320]
                _2144 = mem[(32 * y) + 352]
                require y < mem[(32 * stor19.length) + 352]
                _2160 = mem[(32 * y) + (32 * stor19.length) + 384]
                require y + 1 < stor19.length
                require y < stor19.length
                mem[(32 * y) + 320] = mem[(32 * y + 1) + 320]
                require y + 1 < stor19.length
                mem[(32 * y + 1) + 320] = _2126
                require y + 1 < mem[320]
                require y < mem[320]
                mem[(32 * y) + 352] = mem[(32 * y + 1) + 364 len 20]
                require y + 1 < mem[320]
                mem[(32 * y + 1) + 352] = address(_2144)
                require y + 1 < mem[(32 * stor19.length) + 352]
                require y < mem[(32 * stor19.length) + 352]
                mem[(32 * stor19.length) + (32 * y) + 384] = mem[(32 * y + 1) + (32 * stor19.length) + 384]
                require y + 1 < mem[(32 * stor19.length) + 352]
                mem[(32 * stor19.length) + (32 * y + 1) + 384] = _2160
                v = _2160
                w = _2144
                x = _2126
                y = y + 1
                continue 
            s = v
            t = w
            u = x
            v = y
            idx = idx + 1
            continue 
        mem[(64 * stor19.length) + 384] = 96
        mem[(64 * stor19.length) + 480] = mem[320]
        mem[(64 * stor19.length) + 512 len floor32(mem[320])] = mem[352 len floor32(mem[320])]
        mem[(64 * stor19.length) + 416] = (32 * mem[320]) + 128
        mem[(32 * mem[320]) + (64 * stor19.length) + 512] = stor19.length
        mem[(32 * mem[320]) + (64 * stor19.length) + 544 len floor32(stor19.length)] = mem[320 len floor32(stor19.length)]
        mem[(64 * stor19.length) + 448] = (32 * stor19.length) + (32 * mem[320]) + 160
        mem[(98 * stor19.length) + (32 * mem[320]) + 544] = mem[(32 * stor19.length) + 352]
        mem[(98 * stor19.length) + (32 * mem[320]) + 576 len floor32(mem[(32 * stor19.length) + 352])] = mem[(32 * stor19.length) + 384 len floor32(mem[(32 * stor19.length) + 352])]
        return memory
          from (64 * stor19.length) + 384
           len (32 * mem[(32 * stor19.length) + 352]) + (32 * stor19.length) + (32 * mem[320]) + 192
    mem[352] = stor19.length
    idx = 0
    s = 0
    while idx < stor19.length:
        mem[32] = sha3(stor19[idx], 11)
        require s < stor19.length
        mem[(32 * s) + 320] = jadeProduction[stor19[idx]][stor14[stor19[idx]]]
        require idx < stor19.length
        require s < mem[320]
        mem[(32 * s) + 352] = stor19[idx]
        require idx < stor19.length
        mem[0] = 19
        require ext_code.size(schemaAddress)
        call schemaAddress.battleCardIdRange() with:
             gas gas_remaining wei
        mem[(32 * stor19.length) + 384 len 64] = ext_call.return_data[0 len 64]
        require ext_call.success
        t = mem[(32 * stor19.length) + 384]
        u = 0
        u = 0
        v = 0
        w = 0
        while t <= ext_call.return_data[32]:
            require ext_code.size(schemaAddress)
            call schemaAddress.unitAttack(uint256 arg1) with:
                 gas gas_remaining wei
                args t
            require ext_call.success
            require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w >= w
            require ext_code.size(schemaAddress)
            call schemaAddress.unitStealingCapacity(uint256 arg1) with:
                 gas gas_remaining wei
                args t
            require ext_call.success
            require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + u >= u
            _1683 = sha3(t, sha3(stor19[idx], 21))
            _1727 = sha3(t, sha3(stor19[idx], 30))
            mem[0] = t
            mem[32] = sha3(stor19[idx], 29)
            _1729 = sha3(t, sha3(stor19[idx], 29))
            mem[(32 * stor19.length) + 388] = t
            require ext_code.size(schemaAddress)
            call schemaAddress.unitDefense(uint256 arg1) with:
                 gas gas_remaining wei
                args t
            mem[(32 * stor19.length) + 384] = ext_call.return_data[0]
            require ext_call.success
            require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v >= v
            require ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v >= 0
            t = t + 1
            u = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v + ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w
            u = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitJadeStealingMultiplier[stor19[idx]][t] * unitJadeStealingIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + u
            v = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitDefenseMultiplier[stor19[idx]][t] * unitDefenseIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + v
            w = ((10 * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * ext_call.return_data[0] * ownedCount[stor19[idx]][t]) + (10 * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) + (unitAttackMultiplier[stor19[idx]][t] * unitAttackIncreases[stor19[idx]][t] * ownedCount[stor19[idx]][t]) / 10) + w
            continue 
        require s < mem[352]
        mem[(32 * s) + 384] = ((10 * _1747 * stor[_1683]) + (stor[_1727] * _1747 * stor[_1683]) + (10 * stor[_1729] * stor[_1683]) + (stor[_1727] * stor[_1729] * stor[_1683]) / 10) + (ext_call.return_data[32] * (10 * _1747 * stor[_1683]) + (stor[_1727] * _1747 * stor[_1683]) + (10 * stor[_1729] * stor[_1683]) + (stor[_1727] * stor[_1729] * stor[_1683]) / 10) - (mem[(32 * stor19.length) + 384] * (10 * _1747 * stor[_1683]) + (stor[_1727] * _1747 * stor[_1683]) + (10 * stor[_1729] * stor[_1683]) + (stor[_1727] * stor[_1729] * stor[_1683]) / 10)
        idx = idx + 1
        s = s + 1
        continue 
    s = 0
    t = 0
    u = 0
    v = 0
    idx = 0
    while idx < stor19.length - 1:
        v = s
        w = t
        x = u
        y = 0
        while y < stor19.length + -idx - 1:
            require y + 1 < stor19.length
            require y < stor19.length
            if mem[(32 * y) + 320] >= mem[(32 * y + 1) + 320]:
                v = v
                w = w
                x = x
                y = y + 1
                continue 
            require y < stor19.length
            _2130 = mem[(32 * y) + 320]
            require y < mem[320]
            _2146 = mem[(32 * y) + 352]
            require y < mem[352]
            _2162 = mem[(32 * y) + 384]
            require y + 1 < stor19.length
            require y < stor19.length
            mem[(32 * y) + 320] = mem[(32 * y + 1) + 320]
            require y + 1 < stor19.length
            mem[(32 * y + 1) + 320] = _2130
            require y + 1 < mem[320]
            require y < mem[320]
            mem[(32 * y) + 352] = mem[(32 * y + 1) + 364 len 20]
            require y + 1 < mem[320]
            mem[(32 * y + 1) + 352] = address(_2146)
            require y + 1 < mem[352]
            require y < mem[352]
            mem[(32 * y) + 384] = mem[(32 * y + 1) + 384]
            require y + 1 < mem[352]
            mem[(32 * y + 1) + 384] = _2162
            v = _2162
            w = _2146
            x = _2130
            y = y + 1
            continue 
        s = v
        t = w
        u = x
        v = y
        idx = idx + 1
        continue 
    mem[(32 * stor19.length) + 384] = 96
    mem[(32 * stor19.length) + 480] = mem[320]
    mem[(32 * stor19.length) + 512 len floor32(mem[320])] = mem[352 len floor32(mem[320])]
    mem[(32 * stor19.length) + 416] = (32 * mem[320]) + 128
    mem[(32 * mem[320]) + (32 * stor19.length) + 512] = stor19.length
    mem[(32 * mem[320]) + (32 * stor19.length) + 544 len floor32(stor19.length)] = mem[320 len floor32(stor19.length)]
    mem[(32 * stor19.length) + 448] = (32 * stor19.length) + (32 * mem[320]) + 160
    mem[(64 * stor19.length) + (32 * mem[320]) + 544] = mem[352]
    mem[(64 * stor19.length) + (32 * mem[320]) + 576 len floor32(mem[352])] = mem[384 len floor32(mem[352])]
    return Array(len=mem[320], data=mem[(32 * stor19.length) + 512 len (32 * mem[320]) + 32], mem[320 len floor32(stor19.length)], mem[(32 * stor19.length) + (32 * mem[320]) + floor32(stor19.length) + 544 len (32 * stor19.length) + (32 * mem[352]) + -floor32(stor19.length) + 32]), 
           (32 * mem[320]) + 128,
           (32 * stor19.length) + (32 * mem[320]) + 160
}



}
