contract main {


// =======================  Init code  ======================


address stor0;
uint256 stor4;

function _fallback() payable {
    stor4 = 10^18
    require not msg.value
    stor0 = msg.sender
    return code.data[72 len 1354]
}



// =====================  Runtime code  =====================


address stor0;
mapping of uint8 stor1;
mapping of uint256 stor2;
array of address stor3;
uint256 stor4;

function sub_a135f3d8(?) {
    require stor0 == msg.sender
    idx = 0
    s = 0
    while idx < stor3.length:
        mem[0] = address(stor3[idx])
        mem[32] = 2
        require s + stor2[address(stor3[idx])] >= stor2[address(stor3[idx])]
        idx = idx + 1
        s = s + stor2[address(stor3[idx])]
        continue 
    return (s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length)
}

function sub_0a87f7b6(?) {
    require stor0 == msg.sender
    require stor4 >= arg2
    require stor0 == msg.sender
    idx = 0
    s = 0
    while idx < stor3.length:
        mem[0] = address(stor3[idx])
        mem[32] = 2
        require s + stor2[address(stor3[idx])] >= stor2[address(stor3[idx])]
        idx = idx + 1
        s = s + stor2[address(stor3[idx])]
        continue 
    require stor2[address(arg1)] <= s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length
    require stor4 - arg2 > (s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length) - stor2[address(arg1)]
    stor2[address(arg1)] = arg2
    return 0
}

function _fallback() payable {
    require stor4
    require msg.value == (stor4 * msg.value / stor4) + (msg.value % stor4)
    s = 0
    s = 0
    s = 0
    idx = 0
    s = 0
    while idx < stor3.length:
        mem[0] = address(stor3[idx])
        mem[32] = 2
        if not stor2[address(stor3[idx])]:
            if uint32(ext_code.size(address(stor3[idx]))) > 0:
                if (msg.value / stor4 * stor2[address(stor3[idx])]) + s >= s:
                    s = 1
                    s = msg.value / stor4 * stor2[address(stor3[idx])]
                    s = address(stor3[idx])
                    idx = idx + 1
                    s = (msg.value / stor4 * stor2[address(stor3[idx])]) + s
                    continue 
            else:
                call address(stor3[idx]) with:
                   value msg.value / stor4 * stor2[address(stor3[idx])] wei
                     gas 2300 * is_zero(value) wei
                if (msg.value / stor4 * stor2[address(stor3[idx])]) + s >= s:
                    s = ext_call.success
                    s = msg.value / stor4 * stor2[address(stor3[idx])]
                    s = address(stor3[idx])
                    idx = idx + 1
                    s = (msg.value / stor4 * stor2[address(stor3[idx])]) + s
                    continue 
            ('lt', ('add', ('mul', ('div', 'callvalue', ('stor', ('name', 'stor4', 4))), ('stor', ('map', ('type', 160, ('stor', ('array', ('var', 0), ('name', 'stor3', 3)))), ('name', 'stor2', 2)))), ('var', 1)), ('var', 1))
        else:
            if stor2[address(stor3[idx])]:
                if msg.value / stor4 * stor2[address(stor3[idx])] / stor2[address(stor3[idx])] == msg.value / stor4:
                    if uint32(ext_code.size(address(stor3[idx]))) > 0:
                        if (msg.value / stor4 * stor2[address(stor3[idx])]) + s >= s:
                            s = 1
                            s = msg.value / stor4 * stor2[address(stor3[idx])]
                            s = address(stor3[idx])
                            idx = idx + 1
                            s = (msg.value / stor4 * stor2[address(stor3[idx])]) + s
                            continue 
                    else:
                        call address(stor3[idx]) with:
                           value msg.value / stor4 * stor2[address(stor3[idx])] wei
                             gas 2300 * is_zero(value) wei
                        if (msg.value / stor4 * stor2[address(stor3[idx])]) + s >= s:
                            s = ext_call.success
                            s = msg.value / stor4 * stor2[address(stor3[idx])]
                            s = address(stor3[idx])
                            idx = idx + 1
                            s = (msg.value / stor4 * stor2[address(stor3[idx])]) + s
                            continue 
                    ('lt', ('add', ('mul', ('div', 'callvalue', ('stor', ('name', 'stor4', 4))), ('stor', ('map', ('type', 160, ('stor', ('array', ('var', 0), ('name', 'stor3', 3)))), ('name', 'stor2', 2)))), ('var', 1)), ('var', 1))
        revert
    require s <= msg.value
    if uint32(ext_code.size(msg.sender)) <= 0:
        call msg.sender with:
           value msg.value - s wei
             gas 2300 * is_zero(value) wei
}

function sub_52c96632(?) {
    require stor0 == msg.sender
    require stor4 >= arg2
    if stor1[address(arg1)]:
        require stor0 == msg.sender
        require stor4 >= arg2
        require stor0 == msg.sender
        idx = 0
        s = 0
        while idx < stor3.length:
            mem[0] = address(stor3[idx])
            mem[32] = 2
            require s + stor2[address(stor3[idx])] >= stor2[address(stor3[idx])]
            idx = idx + 1
            s = s + stor2[address(stor3[idx])]
            continue 
    else:
        stor1[address(arg1)] = 1
        stor2[address(arg1)] = 0
        stor3.length++
        if not stor3.length <= stor3.length + 1:
            idx = stor3.length + 1
            while stor3.length > idx:
                uint256(stor3[idx]) = 0
                idx = idx + 1
                continue 
        address(stor3[stor3.length]) = arg1
        require stor0 == msg.sender
        require stor4 >= arg2
        require stor0 == msg.sender
        idx = 0
        s = 0
        while idx < stor3.length:
            mem[0] = address(stor3[idx])
            mem[32] = 2
            require s + stor2[address(stor3[idx])] >= stor2[address(stor3[idx])]
            idx = idx + 1
            s = s + stor2[address(stor3[idx])]
            continue 
    require stor2[address(arg1)] <= s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length
    require stor4 - arg2 > (s * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length * stor3.length) - stor2[address(arg1)]
    stor2[address(arg1)] = arg2
    return 0
}



}
